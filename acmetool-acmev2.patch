diff --git a/.drone.yml b/.drone.yml
new file mode 100644
index 0000000..cbfe8a9
--- /dev/null
+++ b/.drone.yml
@@ -0,0 +1,15 @@
+pipeline:
+  doc:
+    image: asciidoctor/docker-asciidoctor
+    secrets: [ rsync_password ]
+    commands:
+      - apk add --no-cache libxslt docbook-xsl rsync
+      - "(cd _doc/guide && make && make deploy; )"
+
+  test:
+    image: golang:latest
+    commands:
+      - export GOPATH=/drone
+      - export CGO_ENABLED=0
+      - export PEBBLE_VA_ALWAYS_VALID=1
+      - .drone/script
diff --git a/.drone/script b/.drone/script
new file mode 100755
index 0000000..9ba1540
--- /dev/null
+++ b/.drone/script
@@ -0,0 +1,8 @@
+#!/usr/bin/env bash
+set -euxo pipefail
+ACMEAPI="$GOPATH/src/git.devever.net/hlandau/acmeapi"
+
+go get ./... github.com/letsencrypt/pebble/cmd/pebble
+go install ./... github.com/letsencrypt/pebble/cmd/pebble
+
+"$ACMEAPI/.drone/with-pebble" go test -tags integration ./...
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..c2e92d7
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,4 @@
+acmetool
+_doc/guide/out
+_doc/guide/tmp
+_doc/guide/docbook-xsl
diff --git a/.travis/after_success b/.travis/after_success
index c0b464a..26e11f6 100644
--- a/.travis/after_success
+++ b/.travis/after_success
@@ -91,13 +91,14 @@ done
 echo travis_fold:end:build-srpm
 
 COPR_CHROOTS="$(curl "https://copr.fedorainfracloud.org/api_2/projects/$COPR_PROJECT_ID/chroots" | jq '.chroots|map(.chroot.name)')"
+COPR_CHROOTS_CGO="$(echo "$COPR_CHROOTS" | jq 'map(select(contains("86")))')"
 
 for srpm in $HOME/rpmbuild/SRPMS/acmetool-*.rpm; do
   if [[ $srpm != *nocgo* ]]; then
     cat <<END > /tmp/rpm-metadata
 {
   "project_id": $COPR_PROJECT_ID,
-  "chroots": $COPR_CHROOTS
+  "chroots": $COPR_CHROOTS_CGO
 }
 END
   else
diff --git a/Makefile b/Makefile
index 51ac6a9..5546b6a 100644
--- a/Makefile
+++ b/Makefile
@@ -1,5 +1,5 @@
-PROJNAME=github.com/hlandau/acme
-BINARIES=$(PROJNAME)/cmd/acmetool
+PROJNAME=git.devever.net/hlandau/acmetool
+BINARIES=$(PROJNAME)
 
 ###############################################################################
 # v1.12  NNSC:github.com/hlandau/degoutils/_stdenv/Makefile.ref
diff --git a/README.md b/README.md
index 5690fc4..76ce03e 100644
--- a/README.md
+++ b/README.md
@@ -1,8 +1,6 @@
 # <div align="center"><img src="https://hlandau.github.io/acme/img/acmetool-logo-black.png" alt="acmetool" /></div>
 
-<p align="center">  <a href="http://issuestats.com/github/hlandau/acme"><img
-src="http://issuestats.com/github/hlandau/acme/badge/issue?style=flat"
-alt="[issue stats]" /></a> <a
+<p align="center"><a
 href="https://webchat.freenode.net/?channels=%23acmetool"><img
 src="https://img.shields.io/badge/webchat-freenode%20%23acmetool-blue.svg"
 alt="[webchat: freenode #acmetool]" /></a> <br/> <a
@@ -11,14 +9,12 @@ src="https://img.shields.io/github/downloads/hlandau/acme/total.svg"
 alt="[download count]" /></a> <a
 href="https://github.com/hlandau/acme/releases"><img
 src="https://img.shields.io/github/release/hlandau/acme.svg" alt="[version]"
-/></a> <a
+/></a><br/> <a
 href="https://launchpad.net/~hlandau/+archive/ubuntu/rhea/+packages"><img
 src="https://img.shields.io/badge/ppa-debian%2Fubuntu-lightgrey.svg" alt="[ppa
-debian/ubuntu]"/></a><br/> <a href="https://travis-ci.org/hlandau/acme"><img
+debian/ubuntu]"/></a> <a href="https://travis-ci.org/hlandau/acme"><img
 src="https://travis-ci.org/hlandau/acme.svg?branch=master" alt="Build Status"
-/></a> <a href="http://issuestats.com/github/hlandau/acme"><img
-src="http://issuestats.com/github/hlandau/acme/badge/pr?style=flat" alt="[pull
-request stats]" /></a></p>
+/></a></p>
 
 acmetool is an easy-to-use command line tool for automatically acquiring
 certificates from ACME servers (such as Let's Encrypt). Designed to flexibly
diff --git a/_doc/PACKAGING-PATHS.md b/_doc/PACKAGING-PATHS.md
index 36b2fb2..6bf040b 100644
--- a/_doc/PACKAGING-PATHS.md
+++ b/_doc/PACKAGING-PATHS.md
@@ -15,9 +15,9 @@ pursing reproducible builds.)
 
 ```sh
 $ go build -ldflags "
-    -X github.com/hlandau/acme/storage.RecommendedPath=\"/var/lib/acme\"
-    -X github.com/hlandau/acme/hooks.DefaultPath=\"/usr/lib/acme/hooks\"
-    -X github.com/hlandau/acme/responder.StandardWebrootPath=\"/var/run/acme/acme-challenge\"
-    $($GOPATH/src/github.com/hlandau/buildinfo/gen github.com/hlandau/acme/cmd/acmetool)
-  " github.com/hlandau/acme/cmd/acmetool
+    -X git.devever.net/hlandau/acmetool/storage.RecommendedPath=\"/var/lib/acme\"
+    -X git.devever.net/hlandau/acmetool/hooks.DefaultPath=\"/usr/lib/acme/hooks\"
+    -X git.devever.net/hlandau/acmetool/responder.StandardWebrootPath=\"/var/run/acme/acme-challenge\"
+    $($GOPATH/src/github.com/hlandau/buildinfo/gen git.devever.net/hlandau/acmetool)
+  " git.devever.net/hlandau/acmetool
 ```
diff --git a/_doc/SCHEMA.md b/_doc/SCHEMA.md
index fa6bff3..7116536 100644
--- a/_doc/SCHEMA.md
+++ b/_doc/SCHEMA.md
@@ -33,12 +33,12 @@ that shown below is used.
         www.example.com     ;
 
       certs/
-        (certificate ID)/
+        (certificate/order ID)/
           cert              ; Contains the certificate
           chain             ; Contains the necessary chaining certificates
           fullchain         ; Contains the certificate and the necessary chaining certificates
           privkey           ; Symlink to a key privkey file
-          url               ; URL of the certificate
+          url               ; URL of the finalised order resource
           revoke            ; Empty file indicating certificate should be revoked
           revoked           ; Empty file indicating certificate has been revoked
 
@@ -49,10 +49,6 @@ that shown below is used.
       accounts/
         (account ID)/
           privkey           ; PEM-encoded account private key
-          authorizations/
-            (domain)/
-              expiry        ; File containing RFC 3336 expiry timestamp
-              url           ; URL of the authorization (optional)
 
       conf/                 ; Configuration data
         target              ; This has the same format as a target expression file
@@ -118,6 +114,13 @@ parameters of a new certificate request made to satisfy the target.
     to their equivalent ASCII form. (All text files in a State Directory must be
     UTF-8 encoded.)
 
+  - `key`: `type`: Optional string containing "", "rsa" or "ecdsa". If set to a
+    non-empty value, only satisfied by keys with a public key of that type.
+
+  - `margin`: Optional positive integer. If set, expresses the number of days
+    before expiry at which a certificate should be replaced. The default value
+    is implementation-dependent.
+
 (The lumping of hostnames into different target files controls when separate
 certificates are issued, and when single certificates with multiple SANs are
 issued. For example, creating two empty files, `example.com` and
@@ -142,6 +145,9 @@ and if present, move them to the "satisfy" and "request" sections respectively.
 **Target set disjunction priority.** The "priority" value is special. It is an
 integer defaulting to 0.
 
+**Target set label.** The "label" value is an optional string value and
+defaults to "".
+
 **Target set disjunction procedure.** In order to ensure consistent and
 deterministic behaviour, and to minimise the number of certificate requests
 which need to be made in regard of overlapping name sets, the sets of names to
@@ -149,7 +155,7 @@ be satisfied by each target are modified to ensure that the sets are fully
 disjoint. That is, any given hostname must appear in at most one target's list
 of names to be satisfied.
 
-The procedure operates as follows:
+The procedure operates as follows for all targets with a given label:
 
 - Take the list of targets and sort it in descending order of priority value.
   For targets with equal priority, tiebreak using the number of hostnames to be
@@ -173,9 +179,9 @@ Keep both the full set of hostnames to be satisfied and the reduced set of
 hostnames to be satisfied in memory for each target. The on-disk target files
 are not modified.
 
-Wildcard certificates, if ACME ever supports them, may be indicated just as
-they would be in a certificate. For example, an empty file named
-`*.example.com` could be created in the desired directory.
+Wildcard certificates may be requested just as the wildcard name would be
+encoded in a certificate. For example, an empty file named `*.example.com`
+could be created in the "desired" directory.
 
 **Disjunction example.** This section is non-normative. Suppose that the
 following targets were created:
@@ -294,23 +300,6 @@ expressed by a target or used as a default) which finds that no account
 corresponding to that provider URL exists should generate a new account key and
 store it for that provider URL.
 
-#### authorizations
-
-An ACME client MAY keep track of unexpired ACME authorizations it has obtained
-from a provider in order to avoid unnecessarily rerequesting authorizations. It
-does this by maintaining a directory "authorizations" underneath a given
-account directory. Each directory in this directory represents a hostname. Each
-such directory MAY contain the following files:
-
-  - "expiry", a file containing an RFC 3336 timestamp representing the expiry
-    time of the authorization.
-
-  - "url", a file containing the URL of the authorization.
-
-An authorization is deemed valid and useable for the purposes of requesting a
-certificate only if it has an "expiry" file expressing a point in time in the
-future.
-
 ### keys
 
 An ACME State Directory MUST contain a subdirectory "keys" which contains
@@ -332,9 +321,16 @@ subdirectories, each of which relates to a specific certificate. Each
 subdirectory MUST be named after the Certificate ID.
 
 Each certificate subdirectory MUST contain a file "url" which contains the URL
-for the certificate encoded in UTF-8. Clients MUST NOT include trailing
+for the finalised order encoded in UTF-8. Clients MUST NOT include trailing
 newlines or whitespace but SHOULD accept such whitespace and strip it.
 
+NOTE: In previous versions of this specification (which targeted the draft ACME
+protocol prior to the addition of orders), the URL contained in the "url" file
+was the URL to the certificate. Such certificates may still exist in a state
+directory; it is recommended that implementations be able to detect whether an
+URL leads to a certificate or order via the Content-Type of the response
+yielded when dereferencing the URL.
+
 A client SHOULD automatically delete any certificate directory if the
 certificate it contains is expired AND is not referenced by the "live"
 directory. Certificates which have expired but are still referenced by the
@@ -352,6 +348,12 @@ the certificate:
     client tries again later. If provided, the Retry-After HTTP header should be
     consulted.
 
+  - If retrieval of the certificate yields an `application/json` resource suggesting
+    an order (rather than the certificate itself), it is parsed as an order to
+    find the certificate URL. If the order is still in status "processing",
+    handle it like a temporary error as above; if the order has somehow
+    transitioned to "invalid", handle it like a permanent error as above.
+
   - If retrieval of the certificate succeeds, but the private key required to use
     it cannot be found, the certificate directory SHOULD be deleted.
 
@@ -378,7 +380,9 @@ be written in the certificate subdirectory:
 An ACME State Directory MUST contain a subdirectory "live". It contains zero or
 more relative symlinks, each of which MUST link to a subdirectory of the
 "certs" directory. The name of each symlink MUST be a hostname which is
-expressed, or was previously expressed by one or more targets.
+expressed, or was previously expressed by one or more targets, followed by a
+colon and the label of the target. If the label of the target is "", the colon
+is omitted.
 
 The "live" directory MUST point to the Most Preferred Certificate for each
 target, as specified below.  Thus an application requiring a certificate for a
@@ -645,8 +649,8 @@ The reconcile operation is the actual act of “building” the State Directory.
   - Begin by performing the Conform operation.
 
   - If there are any uncached certificates (certificate directories containing
-    only an "url" file), cache them, waiting for them to become available if
-    necessary.
+    only an "url" file), cache them, waiting for them to become available
+    (orders to finish processing, etc.) if necessary.
 
   - If there are any certificates marked for revocation (meaning that a
     "revoke" file exists in the certificate directory), but which are not
@@ -671,14 +675,18 @@ The reconcile operation is the actual act of “building” the State Directory.
 
     To request a certificate:
 
-    - Obtain any necessary authorizations, using the authorization information
-      stored for the account to be used in the State Directory to determine
-      which authorizations definitely do not need to be acquired.
+    - Create an order with the necessary identifiers and satisfy the
+      authorizations specified within the newly created order. If the order
+      becomes invalid due to a failed authorization, create another order and
+      start again, until an order's authorization requirements are successfully
+      fulfilled or it is determined that no further forward progress can be
+      made regarding one or more authorizations.
 
-    - Having successfully acquired all necessary authorizations, form an
-      appropriate CSR containing the SANs specified in the "request" section of
-      the applicable target and request a certificate. Write the certificate
-      URL to the State Directory.
+    - Having obtained an order with status "ready", form an appropriate CSR
+      containing the SANs specified in the "request" section of the applicable
+      target and finalise the order. Write the order URL to the State
+      Directory; there is no need to wait for it to exit the "processing"
+      state.
 
 - Update the "live" directory as follows:
 
@@ -781,10 +789,11 @@ to test using HTTP. Where an HTTP URL is specified, it is prefixed with `http:`.
   `http:example.com%2fdirectory/irq7564p5siu3zngnc2caqygp3v53dfmh6idwtpyfkxojssqglta`
 
 **Certificate ID:** A certificate ID must be assignable before a certificate
-has been issued, when only the public key and certificate URL are known.
+has been issued, when only the public key and order URL are known.
 
 Thus, the Certificate ID shall be the lowercase base32 encoding with padding
-stripped of the SHA256 hash of the certificate URL.
+stripped of the SHA256 hash of the order URL (or, for legacy certificates, the
+certificate URL).
 
 A certificate directory is invalid if the "url" file does not match the
 Certificate ID. Such a directory should be deleted.
diff --git a/_doc/APKBUILD b/_doc/contrib/APKBUILD
similarity index 100%
rename from _doc/APKBUILD
rename to _doc/contrib/APKBUILD
diff --git a/_doc/dns.hook b/_doc/contrib/dns.hook
similarity index 100%
rename from _doc/dns.hook
rename to _doc/contrib/dns.hook
diff --git a/_doc/ovh.hook b/_doc/contrib/ovh.hook
similarity index 100%
rename from _doc/ovh.hook
rename to _doc/contrib/ovh.hook
diff --git a/_doc/perm.example b/_doc/contrib/perm.example
similarity index 100%
rename from _doc/perm.example
rename to _doc/contrib/perm.example
diff --git a/_doc/response-file.yaml b/_doc/contrib/response-file.yaml
similarity index 100%
rename from _doc/response-file.yaml
rename to _doc/contrib/response-file.yaml
diff --git a/_doc/tinydns.hook b/_doc/contrib/tinydns.hook
similarity index 100%
rename from _doc/tinydns.hook
rename to _doc/contrib/tinydns.hook
diff --git a/_doc/guide/ENTER b/_doc/guide/ENTER
new file mode 100755
index 0000000..98d11fe
--- /dev/null
+++ b/_doc/guide/ENTER
@@ -0,0 +1,4 @@
+#!/bin/sh
+set -euo pipefail
+exec nix-shell -p ruby libxslt libxml2 docbook5_xsl plantuml "$@"
+#asciidoctor
diff --git a/_doc/guide/Makefile b/_doc/guide/Makefile
new file mode 100644
index 0000000..e02d3bf
--- /dev/null
+++ b/_doc/guide/Makefile
@@ -0,0 +1,36 @@
+ifneq ($(NIX_PATH),)
+  # NixOS
+  DOCBOOK_XSL := $(shell echo "$(buildInputs)" | tr ' ' '\n' | grep docbook)/xml/xsl/docbook
+else
+  # Alpine
+  DOCBOOK_XSL := $(shell echo /usr/share/xml/docbook/xsl-stylesheets-*)
+endif
+
+all: out/index.xhtml out/img out/style.css
+
+clean:
+	rm -rf tmp out
+
+deploy:
+	rsync -rltv --perms=D755,F644 out/ drone@rem.devever.net::doc/acmetool/
+
+out/img: img
+	rsync -a "$<"/ "$@"/
+
+out/style.css: style.css out/index.xhtml
+	cat out/docbook.css style.css > "$@"
+
+out/index.xhtml: out/index.docbook tmp/acmetool.8.docbook include-man.xsl to-xhtml.xsl
+	rm -f docbook-xsl
+	ln -s "$(DOCBOOK_XSL)" docbook-xsl
+	xsltproc \
+	  --stringparam html.stylesheet style.css \
+	  --nonet --output "$@" \
+	  to-xhtml.xsl "$<"
+
+out/index.docbook: tmp/index.docbook tmp/acmetool.8.docbook include-man.xsl to-xhtml.xsl
+	xsltproc --xinclude --xincludestyle --nonet --output "$@" include-man.xsl "$<"
+
+tmp/%.docbook: %.adoc
+	mkdir -p tmp
+	asciidoctor -r asciidoctor-diagram -b docbook5 -o "$@" "$<"
diff --git a/_doc/guide/acmetool.8.adoc b/_doc/guide/acmetool.8.adoc
new file mode 100644
index 0000000..b6399ff
--- /dev/null
+++ b/_doc/guide/acmetool.8.adoc
@@ -0,0 +1,248 @@
+ACMETOOL(8)
+===========
+Hugo Landau
+:doctype: manpage
+:manmanual: ACMETOOL
+:mansource: ACMETOOL
+
+NAME
+----
+acmetool - request certificates from ACME servers automatically
+
+SYNOPSIS
+--------
+*acmetool* ['flags'] 'command' ['args']
+
+[[description]]
+DESCRIPTION
+-----------
+
+acmetool is a utility for the automated retrieval, management and renewal of
+PKI certificates from ACME servers such as those provided by Let's Encrypt. The
+tool emphasises automation, idempotency and the minimisation of state.
+
+You use acmetool by configuring targets (typically using the "want" command).
+acmetool then requests certificates as necessary to satisfy the configured
+targets. New certificates are requested where existing ones are soon to expire.
+
+acmetool stores its state in a state directory. It can be specified on
+invocation via the *--state* option; otherwise, the path in environment
+variable *ACME_STATE_DIR* is used, or, failing that, the path '/var/lib/acme'
+(recommended).
+
+The '--xlog' options control the logging. The '--service' options control
+privilege dropping and daemonization and are applicable only to the
+'redirector' subcommand.
+
+[[global-options]]
+GLOBAL OPTIONS
+--------------
+
+### FUNDAMENTAL OPTIONS
+
+*--state=/var/lib/acme*::
+  Path to the state directory (defaults to environment variable
+  *ACME_STATE_DIR*, or, failing that, '/var/lib/acme'.)
+*--hooks=/usr/lib/acme/hooks*::
+  Path to the notification hooks directory (defaults to environment variable
+  *ACME_HOOKS_DIR* or, failing that, '/usr/lib/acme/hooks' or
+  '/usr/libexec/acme/hooks', depending on your system.) You may disable hooks
+  by setting this to '/var/empty'.
+
+### INFORMATION OPTIONS
+
+*--help*::
+  Show context-sensitive help (also try --help-long).
+*--version*::
+  Print version information.
+
+### INTERACTION OPTIONS
+
+*--batch*::
+  Never attempt interaction; useful for cron jobs. If it is impossible to
+  continue without interaction, exits unsuccessfully. (acmetool can still
+  obtain responses from a response file, if one was provided.)
+*--stdio*::
+  Don't attempt to use console dialogs for interaction; fall back to stdio prompts.
+*--response-file=RESPONSE-FILE*::
+  Read dialog responses from the given YAML file. (Defaults to
+  '$ACME_STATE_DIR/conf/responses', if it exists.)
+
+### LOGGING OPTIONS
+
+*--xlog.facility=daemon*::
+  Syslog facility to use.
+*--xlog.syslog*::
+  Log to syslog? Defaults to false.
+*--xlog.syslogseverity=DEBUG*::
+  Syslog severity limit.
+*--xlog.journal*::
+  Log to systemd journal? Defaults to false.
+*--xlog.journalseverity=DEBUG*::
+  Systemd journal severity limit.
+*--xlog.severity=NOTICE*::
+  Log severity (any syslog severity name or number).
+*--xlog.file=""*::
+  Log to filename. Disabled by default.
+*--xlog.fileseverity=TRACE*::
+  File logging severity limit.
+*--xlog.stderr*::
+  Log to stderr?
+*--xlog.stderrseverity=TRACE*::
+  Stderr logging severity limit.
+
+### REDIRECTOR OPTIONS
+
+*--service.cpuprofile=""*::
+  Redirector mode: Write CPU profile to file.
+*--service.debugserveraddr=""*::
+  Redirector mode: Address for debug server to listen on (insecure, do not
+  specify a public address). Disabled by default.
+*--service.uid=""*::
+  Redirector mode: UID to run as. If not specified, doesn't drop privileges.
+  Note: On Linux, this option is only available if acmetool was built with cgo.
+  You can find out whether this is the case by running 'acmetool --version'.
+  Note: Regardless of platform, this value can only be specified by name rather
+  than numerically if acmetool was built with cgo.
+*--service.gid=""*::
+  Redirector mode: GID to run as. If not specified, doesn't drop privileges.
+  See --service.uid for caveats.
+*--service.daemon*::
+  Redirector mode: Run as a daemon? (Doesn't fork.)
+*--service.stderr*::
+  Redirector mode: Keep stderr open when daemonizing.
+*--service.chroot=""*::
+  Redirector mode: Chroot to a directory. If you set this, you must set a UID and GID. Set to '/' to disable.
+*--service.pidfile=""*::
+  Redirector mode: Write PID to file with given filename and hold a write lock.
+*--service.fork*::
+  Redirector mode: Fork? Implies --service.daemon. Not recommended.
+
+[[subcommands]]
+SUBCOMMANDS
+-----------
+
+[[fbquickstart_ltflagsgtfr]]
+*quickstart [<flags>]*
+~~~~~~~~~~~~~~~~~~~~~~
+
+Interactively ask some getting started questions and install default hooks
+(recommended).
+
+*--expert*::
+  Ask more questions in quickstart wizard
+
+[[fbreconcilefr]]
+*reconcile*
+~~~~~~~~~~~
+
+Reconcile ACME state, idempotently requesting and renewing certificates
+to satisfy configured targets.
+
+This is the default command.
+
+[[fbwant_ltflagsgt_lthostnamegtfr]]
+*want [<flags>] <hostname>...*
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Add a target with one or more hostnames
+
+*--no-reconcile*::
+  Do not reconcile automatically after adding the target.
+
+[[fbunwant_lthostnamegtfr]]
+*unwant <hostname>...*
+~~~~~~~~~~~~~~~~~~~~~~
+
+Modify targets to remove any mentions of the given hostnames
+
+[[fbcull_ltflagsgtfr]]
+*cull [<flags>]*
+~~~~~~~~~~~~~~~~
+
+Delete expired, unused certificates
+
+*-n, --simulate*::
+  Show which certificates would be deleted without deleting any.
+
+[[fbstatusfr]]
+*status*
+~~~~~~~~
+
+Show active configuration
+
+[[fbaccountthumbprintfr]]
+*account-thumbprint*
+~~~~~~~~~~~~~~~~~~~~
+
+Prints account thumbprints.
+
+[[fbrevoke_ltcertificateidorpathgtfr]]
+*revoke [<certificate-id-or-path>]*
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Revoke a certificate.
+
+[[fbredirector_ltflagsgtfr]]
+*redirector [<flags>]*
+~~~~~~~~~~~~~~~~~~~~~~
+
+HTTP to HTTPS redirector with challenge response support.
+
+*--path=PATH*::
+  Path to serve challenge files from. Defaults to '/var/run/acme/acme-challenge'.
+*--challenge-gid=CHALLENGE-GID*::
+  GID to chgrp the challenge path to. Optional.
+*--read-timeout=10s*::
+  Maximum duration before timing out read of the request. Defaults to '10s'.
+*--write-timeout=20s*::
+  Maximum duration before timing out write of the request. Defaults to '20s'.
+*--status-code=308*::
+  HTTP status code to use when redirecting. Defaults to '308'.
+*--bind=":80"*::
+  Bind address for redirector. Defaults to ':80'.
+
+[[fbtestnotify_lthostnamegtfr]]
+*test-notify [<hostname>...]*
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Test-execute notification hooks as though given hostnames were updated.
+
+[[fbimportjwkaccount_ltproviderurlgt_ltpri]]
+*import-jwk-account <provider-url> <private-key-file>*
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Import a JWK account key.
+
+[[fbimportpemaccount_ltproviderurlgt_ltpri]]
+*import-pem-account <provider-url> <private-key-file>*
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Import a PEM account key.
+
+[[fbimportkey_ltprivatekeyfilegtfr]]
+*import-key <private-key-file>*
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Import a certificate private key.
+
+[[fbhelp_ltcommandgtfr]]
+*help [<command>...]*
+~~~~~~~~~~~~~~~~~~~~~
+
+Show help.
+
+
+[[author]]
+AUTHOR
+------
+
+© 2015—2018 Hugo Landau <hlandau@devever.net> MIT License
+
+[[see_also]]
+SEE ALSO
+--------
+
+Documentation: <https://doc.devever.net/acmetool/>
+
+Report bugs at: <https://git.devever.net/hlandau/acmetool/issues>
diff --git a/_doc/guide/img/acmetool-logo-black.png b/_doc/guide/img/acmetool-logo-black.png
new file mode 100755
index 0000000..7661a11
Binary files /dev/null and b/_doc/guide/img/acmetool-logo-black.png differ
diff --git a/_doc/guide/img/acmetool-logo.png b/_doc/guide/img/acmetool-logo.png
new file mode 100755
index 0000000..f29d003
Binary files /dev/null and b/_doc/guide/img/acmetool-logo.png differ
diff --git a/_doc/guide/include-man.xsl b/_doc/guide/include-man.xsl
new file mode 100644
index 0000000..7cb80cd
--- /dev/null
+++ b/_doc/guide/include-man.xsl
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns="http://www.w3.org/1999/xhtml" version="1.0" xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude">
+  <xsl:output method="xml" />
+
+  <xsl:template match="node()|@*">
+    <xsl:copy>
+      <xsl:apply-templates select="node()|@*"/>
+    </xsl:copy>
+  </xsl:template>
+
+  <xsl:template match="/db:book">
+    <xsl:copy>
+      <xsl:apply-templates select="node()" />
+      <db:reference xml:id="manpages">
+        <db:title>Manual Pages</db:title>
+        <xi:include href="tmp/acmetool.8.docbook" />
+      </db:reference>
+    </xsl:copy>
+  </xsl:template>
+
+</xsl:stylesheet>
diff --git a/_doc/guide/index.adoc b/_doc/guide/index.adoc
new file mode 100644
index 0000000..7606c87
--- /dev/null
+++ b/_doc/guide/index.adoc
@@ -0,0 +1,830 @@
+[[acmetool-manual]]
+= The Acmetool Manual
+:doctype: book
+
+[[users-guide]]
+= User's Guide
+
+[[introduction-design-philosophy]]
+== Introduction & Design Philosophy
+
+acmetool is an easy-to-use command line tool for automatically acquiring
+TLS certificates from ACME servers such as Let’s Encrypt, designed to
+flexibly integrate into your webserver setup to enable automatic
+verification.
+
+*Non-interference.* Unlike the official Let’s Encrypt client, this
+doesn’t modify your web server configuration.
+
+*Target-oriented and idempotent.* acmetool is designed to work like
+``make'': you specify what certificates you want, and acmetool obtains
+certificates as necessary to satisfy those requirements. If the
+requirements are already satisfied, acmetool doesn’t do anything when
+invoked. Thus, acmetool is ideally suited for use on a cron job; it will
+do nothing until certificates are near expiry, and then obtain new ones.
+
+*Clear and minimal state.* acmetool is designed to minimise the use of
+state and be transparent in the state that it does use. All state,
+including certificates, is stored in a single directory, by default
+`/var/lib/acme`. The schema for this directory is simple, comprehensible
+and
+https://github.com/hlandau/acme/blob/master/_doc/SCHEMA.md[documented.]
+
+*Stable filenames.* The certificate for a given hostname `example.com`
+always lives at `/var/lib/acme/live/example.com/{cert,chain,privkey}`.
+This is a symlink to the real certificate directory and gets changed as
+certificates are renewed.
+
+*Fully automatic renewal.* acmetool can automatically reload your
+webserver when it changes the target of a `live` symlink. In conjunction
+with acmetool’s use of stable filenames and idempotent design, this
+means that renewal can be fully automatic.
+
+*Flexible validation methods.* acmetool supports six different
+validation methods:
+
+* *Webroot:* acmetool places challenge files in a given directory,
+allowing your normal web server to serve them. You must ensure the
+directory is served at `/.well-known/acme-challenge/`.
+* *Proxy:* When acmetool needs to validate for a domain, it temporarily
+spins up a built-in web server on port 402 or 4402 (if being used under
+the non-root validation mode). You configure your web server to proxy
+requests for `/.well-known/acme-challenge/` to this server at the same
+path.
+* *Stateless:* You configure your webserver to respond statelessly to
+challenges for a given account key without consulting acmetool. This
+requires nothing more than a one-time web server configuration change
+and no ``moving parts''.
+* *Redirector:* If the only thing you want to do with port 80 is
+redirect people to port 443, you can use acmetool’s built in redirector
+HTTP server. You must ensure that your existing web server does not
+listen on port 80. acmetool redirects requests to HTTPS, but its control
+of port 80 ensures it can complete validation.
+* *Listen:* Listen on port 80 or 443. This is only really useful for
+development purposes.
+* *Hook:* You can write custom shell scripts or binary executables which
+acmetool invokes to provision challenges at the desired location.
+
+*Non-root operation.* If you don’t want to trust acmetool, you can setup
+acmetool to operate without running as root. If you don’t have root
+access to a system, you may still be able to use acmetool by configuring
+it to use a local directory and webroot mode.
+
+*Designed for automation.* acmetool is designed to be fully automatable.
+Response files allow you to run the quickstart wizard automatically.
+
+[[installation]]
+== Installation
+
+You can install acmetool by building from source or by using a binary
+release. Both are easy.
+
+*Installing: using binary releases.*
+https://github.com/hlandau/acme/releases[Binary releases are found
+here.] Unpack, copy the binary to `/usr/local/bin/acmetool` (or wherever
+you like), and you’re done.
+
+`_cgo` releases are preferred over non-`_cgo` releases where available,
+but non-`_cgo` releases may be more compatible with older OSes. (The
+main drawback of non-`_cgo` releases is that they exhibit reduced
+functionality in relation to privilege dropping and daemonization
+functionality for the redirector daemon.)
+
+*Installing: Ubuntu users.* A binary release PPA, `ppa:hlandau/rhea`
+(package `acmetool`) is available.
+
+[source,sh]
+----
+$ sudo add-apt-repository ppa:hlandau/rhea
+$ sudo apt-get update
+$ sudo apt-get install acmetool
+----
+
+You can also
+https://launchpad.net/~hlandau/+archive/ubuntu/rhea/+packages[download
+.deb files manually.]
+
+(Note: There is no difference between the .deb files for different
+Ubuntu release codenames; they are interchangeable and completely
+equivalent.)
+
+*Installing: Debian users.* The Ubuntu binary release PPA also works
+with Debian:
+
+....
+# echo 'deb http://ppa.launchpad.net/hlandau/rhea/ubuntu xenial main' > /etc/apt/sources.list.d/rhea.list
+# apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 9862409EF124EC763B84972FF5AC9651EDB58DFA
+# apt-get update
+# apt-get install acmetool
+....
+
+You can also
+https://launchpad.net/~hlandau/+archive/ubuntu/rhea/+packages[download
+.deb files manually.]
+
+(Note: There is no difference between the .deb files for different
+Ubuntu release codenames; they are interchangeable and completely
+equivalent.)
+
+*Installing: RPM-based distros:*
+https://copr.fedorainfracloud.org/coprs/hlandau/acmetool/[A copr RPM
+repository is available.]
+
+If you have `dnf` installed:
+
+[source,bash]
+----
+$ sudo dnf copr enable hlandau/acmetool
+$ sudo dnf install acmetool
+----
+
+Otherwise use the `.repo` files on the
+https://copr.fedorainfracloud.org/coprs/hlandau/acmetool/[repository
+page] and use `yum`, or download RPMs and use `rpm` directly.
+
+*Installing: Arch Linux users.*
+https://aur.archlinux.org/packages/acmetool-git/[An AUR PKGBUILD for
+building from source is available.]
+
+[source,sh]
+----
+$ wget https://aur.archlinux.org/cgit/aur.git/snapshot/acmetool-git.tar.gz
+$ tar xvf acmetool-git.tar.gz
+$ cd acmetool-git
+$ makepkg -s
+$ sudo pacman -U ./acmetool*.pkg.tar.xz
+----
+
+*Installing: Alpine Linux users.*
+https://github.com/hlandau/acme/blob/master/_doc/APKBUILD[An APKBUILD
+for building from source is available.]
+
+*Installing: from source.* Clone, make, make install. You will need Go
+1.5.2 or later installed to build from source.
+
+If you are using Linux, you will need to make sure the development files
+for `libcap` are installed. This is probably a package for your distro
+called `libcap-dev` or `libcap-devel` or similar.
+
+[source,sh]
+----
+# This is necesary to work around a change in Git's default configuration
+# which hasn't yet been accounted for in some places.
+$ git config --global http.followRedirects true
+
+$ git clone https://github.com/hlandau/acme
+$ cd acme
+$ make && sudo make install
+----
+
+*Installing: from source (existing GOPATH).* The Makefile is intended to
+make things easy for users unfamiliar with Go packaging conventions. If
+you know what a GOPATH is and have one set up, you can and should
+instead simply do:
+
+[source,sh]
+----
+$ git config --global http.followRedirects true
+$ go get -u github.com/hlandau/acme/cmd/acmetool
+$ sudo cp $GOPATH/bin/acmetool /usr/local/bin/acmetool
+----
+
+(Note: Although use of cgo is recommended, building without cgo is
+supported.)
+
+[[after-installation]]
+== After installation
+
+*Initial configuration.* Having installed acmetool, run the quickstart
+wizard for a guided setup. You may wish to ensure you have `dialog` in
+your PATH, but acmetool will fallback to basic stdio prompts if it’s not
+available.
+
+[source,sh]
+----
+$ sudo acmetool quickstart
+----
+
+If you don’t want to run acmetool as root, see the
+link:#annex-root-configured-non-root-operation[non-root setup guide].
+
+Pass `--expert` to quickstart if you want to choose what key parameters
+to use (RSA or ECDSA, RSA key size, ECDSA curve). By default 2048-bit
+RSA is used.
+
+If you want to automate the quickstart process, see the section on
+response files below.
+
+It is safe to rerun quickstart at any time.
+
+*Configuring your web server.* Once you’ve completed the quickstart, you
+should configure your web server as necessary to enable validation. See
+the _Web server configuration_ section below.
+
+*Obtaining certificates.* Once everything’s ready, simply run:
+
+[source,sh]
+----
+$ sudo acmetool want example.com www.example.com
+----
+
+This adds a target desiring a certificate for hostnames `example.com`
+and `www.example.com`. You can specify as many hostnames (SANs) as you
+like. Whenever you run acmetool in the future, it’ll make sure that a
+certificate for these hostnames is available and not soon to expire.
+
+acmetool lumps hostnames together in the same certificate. If you want
+`example.com` and `www.example.com` to be separate certificates, use
+separate `want` commands to configure them as separate targets:
+
+[source,sh]
+----
+$ sudo acmetool want example.com
+$ sudo acmetool want www.example.com
+----
+
+If all went well, your certificate should be available at
+`/var/lib/acme/live/example.com`. This is a directory containing PEM
+files `cert`, `chain`, `fullchain` and `privkey`. The use of these files
+varies by application; typically you will use only a subset of these
+files.
+
+*Troubleshooting.* If all didn’t go well, you might find it helpful to
+run with debug logging:
+
+[source,sh]
+----
+$ sudo acmetool --xlog.severity=debug
+----
+
+(There’s no need to run ``want'' again; the targets are recorded even if
+reconciliation is not successful.)
+
+*Auto-renewal.* acmetool offers to install a cronjob during the
+quickstart process. This simply runs `acmetool --batch`, which will
+idempotently ensure that all configured targets are satisfied by
+certificates not soon to expire. (`--batch` here ensures that acmetool
+doesn’t try to ask any questions.)
+
+*Auto-renewal: reloading your webserver.* When acmetool refreshes a
+certificate, it changes the symlink in `live` and executes hook scripts
+to reload your web server or do whatever you want. Specifically, it
+executes any executable files in `/usr/lib/acme/hooks` (or
+`/usr/libexec/acme/hooks` if on a distro that uses libexec). You can
+drop your own executable files here, and acmetool will invoke them when
+it changes certificates. (For information on the calling convention, see
+https://github.com/hlandau/acme/blob/master/_doc/SCHEMA.md#notification-hooks[SCHEMA.md].)
+
+`acmetool quickstart` installs some default hooks applicable to common
+webservers. These hooks contain the string `#!acmetool-managed!#`.
+acmetool reserves the right to overwrite any file containing this string
+with a newer version of the script, in the event that the default
+scripts are updated in subsequent versions of acmetool. If you make
+changes to a default script and do not wish them to be overwritten, you
+should remove this line to ensure that your changes are not overwritten.
+However, note that the default hook scripts are designed to be
+configurable and it will be rare that you need to modify the scripts
+themselves. If you encounter a situation where you need to change the
+script itself, you may consider whether it would be appropriate to file
+an enhancement request. The string `#!acmetool-managed!#` must be
+present near the start of the file in order to be detected.
+
+If you want to disable a default hook entirely, you should replace it
+with an empty file rather than deleting it, as `acmetool quickstart`
+will automatically install absent default hooks.
+
+*Default hook scripts: the `reload` hook.* The reload hook is a default
+hook installed by `acmetool quickstart`. It reloads a list of services
+using commands specific to the distro. The correct command is detected
+automatically; `service $SERVICE reload`, `systemctl reload $SERVICE`,
+and `/etc/init.d/$SERVICE reload` are supported.
+
+A default list of services is provided which includes the most common
+webserver service names. This list can be customised using the `reload`
+hook configuration file.
+
+The `reload` hook configuration file is located at
+`/etc/conf.d/acme-reload` or `/etc/default/acme-reload`; the correct
+path depends on the conventions of your distro. It is a sourced shell
+file which can modify the default configuration variables of the
+`reload` script. Currently, the only variable is the `SERVICES`
+variable, a space-separated list of service names.
+
+You can overwrite the services list outright, or append to it like so:
+
+[source,sh]
+----
+# Example reload hook configuration file adding a service to the list of
+# services to be restarted.
+SERVICES="$SERVICES cherokee"
+----
+
+*Default hook scripts: the `haproxy` hook.* The haproxy hook is a
+default hook which `acmetool quickstart` can optionally install. It only
+offers to install this hook if HAProxy is detected as being installed on
+the system.
+
+HAProxy is rather bizarre in its TLS configuration requirements; it
+requires certificates and private key to be appended together in the
+same file. `acmetool` does not support this natively and is unlikely
+ever to as a default configuration for security reasons. Instead, the
+`haproxy` hook creates the necessary files for HAProxy from the
+certificate and private key files whenever they are updated. Thus,
+additional copies of the private key are only made when necessary to
+support HAProxy.
+
+*Inside the state directory.* acmetool aims to minimise the use of state
+and be transparent about the state it does keep. When you run
+`acmetool want`, acmetool does these things:
+
+* It configures a new target by writing a YAML file to
+`/var/lib/acme/desired/` describing the desired hostnames.
+* It runs the default command, `reconcile`, to ensure that all targets
+are met.
+
+To demonstrate, you can replicate the function of `acmetool want`:
+
+[source,sh]
+----
+$ sudo touch /var/lib/acme/desired/example.com
+$ sudo acmetool
+----
+
+Target files live in the `desired` directory. An empty target file
+defaults to its filename as the target hostname.
+
+https://github.com/hlandau/acme/blob/master/_doc/SCHEMA.md[More
+information on the format of the acmetool state directory and target
+files.]
+
+[[web-server-configuration-challenges]]
+== Web server configuration: challenges
+
+What web server configuration you need to do depends on the validation
+method you have selected.
+
+*Redirector mode.* No configuration required, but ensure that your web
+server is not listening on port 80 and that the redirector service
+(`acmetool redirector --service.daemon --service.uid=`__uid-to-drop-privileges-to__)
+is started.
+
+*Proxy mode: nginx/tengine.* You can configure nginx/tengine for use
+with acmetool in proxy mode as follows:
+
+[source,nginx]
+----
+http {
+  server {
+    ... your configuration ...
+
+    location /.well-known/acme-challenge/ {
+      proxy_pass http://acmetool;
+    }
+  }
+
+  upstream acmetool {
+    # (Change to port 4402 if using non-root mode.)
+    server 127.0.0.1:402;
+  }
+}
+----
+
+This configuration will need to be repeated for each vhost. You may wish
+to avoid duplication by placing the applicable configuration in a
+separate file and including it in each vhost.
+
+*Proxy mode: Apache httpd.*
+
+[source,apache]
+----
+# (Change to port 4402 if using non-root mode.)
+ProxyPass "/.well-known/acme-challenge" "http://127.0.0.1:402/.well-known/acme-challenge"
+----
+
+Ensure you load the modules `mod_proxy` and `mod_proxy_http`.
+
+*Proxy mode: Changing port.* If you need to change the ports on which
+acmetool listens, see the `request: challenge: http-ports` directive.
+See link:#the-state-storage-schema[State storage schema].
+
+*Webroot mode.* If you don’t have a particular webroot path in mind,
+consider using `/var/run/acme/acme-challenge` as a recommended standard.
+`acmetool` defaults to this as a webroot path if you don’t explicitly
+configure one. (See ``Challenge Completion Philosophy'' below.)
+
+*Webroot mode: nginx/tengine.*
+
+[source,nginx]
+----
+http {
+  server {
+    location /.well-known/acme-challenge/ {
+      alias /var/run/acme/acme-challenge/;
+    }
+  }
+}
+----
+
+Note that the configuration will need to be repeated for each vhost. You
+may wish to avoid duplication by placing the applicable configuration in
+a separate file and including it in each vhost.
+
+*Webroot mode: Apache httpd.*
+
+[source,apache]
+----
+Alias "/.well-known/acme-challenge/" "/var/run/acme/acme-challenge/"
+<Directory "/var/run/acme/acme-challenge">
+  AllowOverride None
+  Options None
+
+  # If using Apache 2.4+
+  Require all granted
+
+  # If using Apache 2.2 and lower
+  Order allow, deny
+  Allow from all
+</Directory>
+----
+
+*Hook mode.* See link:#challenge-hooks[Challenge Hooks].
+
+*Stateless mode.* In stateless mode, you configure your webserver to
+respond to challenge requests without consulting acmetool. A single
+account key is nominated. This is one of the most reliable and least
+error-prone methods for simple cases.
+
+*Stateless mode: nginx/Tengine.*
+
+Replace `ACCOUNT_THUMBPRINT` in the example below with your account
+thumbprint. You can retrieve your account thumbprint by running
+`acmetool account-thumbprint`. The first part of each line output is the
+account thumbprint.
+
+[source,nginx]
+----
+http {
+  server {
+    location ~ "^/\.well-known/acme-challenge/([-_a-zA-Z0-9]+)$" {
+      default_type text/plain;
+      return 200 "$1.ACCOUNT_THUMBPRINT";
+    }
+  }
+}
+----
+
+*Stateless mode: Apache.* It does not appear that the configuration
+system of Apache can currently express the needed behaviour.
+
+[[web-server-configuration-tls]]
+== Web server configuration: TLS
+
+Mozilla has a
+https://mozilla.github.io/server-side-tls/ssl-config-generator/[TLS
+configuration generator] that you can use to generate configurations for
+common web servers.
+
+[[challenge-completion-philosophy]]
+== Challenge completion philosophy
+
+acmetool’s philosophy to completing challenges is to try absolutely
+anything that might work. So long as _something_ works, acmetool doesn’t
+care what it was that worked. When `acmetool quickstart` asks you what
+method to use, this is asked purely to determine a) whether to ask you
+for a webroot path (if you selected webroot mode) and b) whether to ask
+you if you want to install the redirector service (if you selected
+redirector mode and are using systemd, for which automatic service
+installation is supported). It doesn’t determine what strategies
+acmetool does or doesn’t use, so it’s normal to see log output relating
+to a failure to use methods other than the one you chose.
+
+acmetool always tries to listen on port 402 and 4402 when completing
+challenges, in case something proxies to it. It always tries to listen
+on ports 80 and 443, in case you’re not running a webserver yet. And it
+always tries to place challenge files in any webroot paths you have
+configured. Finally, it always tries to place challenge files in
+`/var/run/acme/acme-challenge`; this serves as a standard location for
+challenge files, and the redirector daemon works by looking here.
+
+Failure to complete any of these efforts is non-fatal. Ultimately, all
+acmetool cares about is that a challenge completes successfully after
+having attempted all possible preparations. It doesn’t know or care
+_why_ a challenge succeeds, only that it succeeded.
+
+(For HTTP-based challenges, acmetool self-tests its ability to complete
+the challenge by issuing a request for the same URL which will be
+requested by the ACME server, and does not proceed if this does not
+validate. Thus, HTTP-based challenges will never work if you are running
+some sort of weird split-horizon configuration where challenge files are
+retrievable only from the internet but not the local machine.)
+
+[[the-state-storage-schema]]
+== The state storage schema
+
+https://github.com/hlandau/acme/blob/master/_doc/SCHEMA.md[The format of
+acmetool’s state directory is authoritatively documented here.] What
+follows is a summary of the more important parts.
+
+*`live` directory:* Contains symlinks from hostnames to certificate
+directories. Each certificate directory contains `cert`, `chain`,
+`fullchain` and `privkey` files. (If you are using HAProxy and have
+chosen to install the HAProxy hook script, a `haproxy` file will also be
+available containing key, certificate and chain all in one.)
+
+You should configure your web server in terms of paths like
+`/var/lib/acme/live/example.com/{cert,chain,fullchain,privkey}`.
+
+*`desired` directory:* Contains targetfiles. These determine the
+certificates which will be requested. Each target file is a YAML file,
+split into two principal sections: the `satisfy` section and the
+`request` section.
+
+The `satisfy` section dictates what conditions must be met in order for
+a certificate to meet a target (and thus be selected for symlinking
+under the `live` directory). The `request` section dictates the
+parameters for requesting new certificates, but nothing under it
+determines _whether_ a certificate is requested.
+
+Finally, the `priority` value determines which target is used for a
+hostname when there are multiple targets for the same hostname. Higher
+priorities take precedence. The default priority is 0.
+
+In most cases, you will set only `satisfy.names` in a target file, and
+will set all other settings in the _default target file_, which is
+located at `conf/target`. The quickstart wizard sets this file up for
+you. All settings in the default target file are inherited by targets,
+but can be overridden individually.
+
+[source,yaml]
+----
+satisfy:
+  names:
+    - example.com       # The names you want on the certificate.
+    - www.example.com
+
+request:
+  provider:               # ACME Directory URL. Normally set in conf/target only.
+  ocsp-must-staple: true  # Request OCSP Must Staple. Use with care.
+  challenge:
+    webroot-paths:        # You can specify custom webroot paths.
+      - /var/www
+    http-ports:           # You can specify different ports for proxying.
+      - 123               # Defaults to listening on localhost.
+      - 456
+      - 0.0.0.0:789       # Global listen.
+    http-self-test: false # Defaults to true. If false, will not perform self-test
+                          # but will assume challenge can be completed. Rarely needed.
+    env:                  # Optionally set environment variables to be passed to hooks.
+      FOO: BAR
+  key:                    # What sort of key will be used for this certificate?
+    type: rsa|ecdsa
+    rsa-size: 2048
+    ecdsa-curve: nistp256
+    id: krzh2akn...       # If specified, the key ID to use to generate new certificates.
+                          # If not specified, a new private key will always be generated.
+                          # Useful for key pinning.
+
+priority: 0
+----
+
+*HAProxy support:* If you have chosen to install the HAProxy hook
+script, each certificate directory will also have a coalesced `haproxy`
+file containing certificate chain and private key. There will also be a
+`haproxy` directory mapping from hostnames directly to these files.
+
+*`accounts` directory:* ACME account keys and state information. You
+don’t need to worry about this.
+
+*`certs` and `keys`*: Contains certificates and keys used to satisfy
+targets. However, you should never need to reference these directories
+directly.
+
+Please note that it is a requirement that the state directory not
+straddle filesystem boundaries. That is, all files under `/var/lib/acme`
+must lie on the same filesystem.
+
+[[response-files]]
+== Response files
+
+It is possible to automatically provide responses to any question
+acmetool can ask.
+
+To do this, you provide the `--response-file` flag, with the path to a
+YAML file containing response information.
+https://github.com/hlandau/acme/blob/master/_doc/response-file.yaml[An
+example of such a file is here.]
+
+If you don’t provide a `--response-file` flag, acmetool will try to look
+for one at `/var/lib/acme/conf/responses`. If using a response file,
+it’s recommended that you place it at this location.
+
+The file specifies key-value pairs. Each key is a prompt ID. (You can
+find these by grepping the source code for `UniqueID`.)
+
+(For messages which simply require acknowledgement, specify `true` to
+bypass them. Yes/no prompts should have a boolean value specified. The
+example response file is demonstrative.)
+
+You should specify `--batch` when using a response file to prevent
+acmetool from trying to prompt the user and fail instead, in case it
+tries to ask anything which you don’t have a response for in your
+response file.
+
+[[hooks]]
+== Hooks
+
+Hooks provide a means to extend acmetool with arbitrary behaviour. Hooks
+are executable files installed by default at `/usr/lib/acme/hooks` (or,
+on systems which use `/usr/libexec`, `/usr/libexec/acme/hooks`).
+
+The event type is always passed as the first argument. A hook must exit
+with exit code 42 for event types it doesn’t handle.
+
+There are currently two types of hook: notification hooks and challenge
+hooks.
+
+[[notification-hooks]]
+== Notification hooks
+
+The quickstart wizard installs default notification hooks to reload
+common webservers and other services after acmetool changes the
+preferred certificate for a hostname. These hooks are executable shell
+scripts and you can, if you wish, substitute your own. The default hooks
+are good bases from which to make your own customisations.
+
+You can use notification hooks to reload webservers, distribute
+certificates and private keys to other servers, or convert certificates
+and private keys into another format which is required by some daemon.
+For example, HAProxy support is implemented entirely via hook.
+
+The event type is ``live-updated''.
+
+[[challenge-hooks]]
+== Challenge hooks
+
+In some complex use cases, it may be necessary to install HTTP challenge
+files via some arbitrary programmatic means, rather than via one of the
+standard methods of webroot, proxy, redirector or listener.
+
+Challenge hooks are executed when challenge files need to be added or
+removed. Your hook must be synchronous; it must exit only when the
+challenge file is definitely in place and is globally accessible.
+
+https://github.com/hlandau/acme/blob/master/_doc/SCHEMA.md#hooks[See the
+specification for more information.]
+
+Challenge hooks are supported for HTTP, TLS-SNI and DNS challenges.
+https://hlandau.github.io/acme/userguide#annex-external-resources-and-third-party-extentions[A
+list of third party challenge hook scripts can be found here.]
+
+[[command-line-options]]
+== Command line options
+
+link:acmetool.8[See the acmetool(8) manual page.]
+
+[[troubleshooting]]
+== Troubleshooting
+
+Passing `--xlog.severity=debug` increases the logging verbosity of
+acmetool and should be your first troubleshooting strategy.
+
+[[faq]]
+== FAQ
+
+[[ive-selected-the-webrootproxyredirectorlistener-challenge-method-but-im-seeing-log-entries-for-other-methods-or-for-webroots-other-than-the-one-i-configured.]]
+=== I’ve selected the (webroot/proxy/redirector/listener) challenge method, but I’m seeing log entries for other methods, or for webroots other than the one I configured.
+
+This is normal. By design, acmetool always tries anything which might
+work, and these errors are nonfatal as long as _something_ works. The
+challenge method you select in the quickstart wizard determines only
+whether to ask you for a webroot path, and whether to install the
+redirector (if you are using system). The webroot path
+`/var/run/acme/acme-challenge`, as a standard location, will always be
+tried in addition to any webroot you specify, as will proxy and listener
+mode ports.
+
+Fore more information, see
+https://hlandau.github.io/acme/userguide#challenge-completion-philosophy[challenge
+completion philosophy].
+
+[[annex-root-configured-non-root-operation]]
+== Annex: Root-configured non-root operation
+
+The following steps describe how you can, as root, take a series of
+steps that allows you to invoke acmetool as a non-root user, thereby
+limiting your attack surface and the degree to which you trust acmetool.
+
+It is also possible to use acmetool without you having access to root at
+all. In this case, place acmetool in a location of your choice and pass
+the `--state` and `--hooks` flags with appropriate paths of your choice
+to all invocations of acmetool.
+
+[[rootless-setup-as-root]]
+== Rootless setup as root
+
+acmetool has experimental support for root-free operation.
+
+In order to run root-free, after installing acmetool in `/usr/local/bin`
+(or wherever you want it), before running acmetool, do the following:
+
+* Create a new user `acme` (or whatever you want).
+* Create the directory `/var/lib/acme` and change the owning user and
+group to `acme`. (You can use a different directory, but you must then
+make sure you pass `--state PATH` to all invocations of acmetool.)
+* Create the directory `/usr/lib/acme/hooks` (`/usr/libexec/acme/hooks`
+on distros which use libexec). Make it writable by `acme` for the time
+being by changing the group to `acme` and making the directory
+group-writable. (You can make this read-only after running the
+quickstart process, which places some shell scripts in here to reload
+servers. You can audit these scripts yourself or use your own if you
+wish.)
+* Change to the user `acme` and run `acmetool quickstart`.
++
+....
+$ sudo -u acme acmetool quickstart
+....
++
+A crontab will be installed automatically as the `acme` user; you may
+wish to examine it.
+** As root, make the `hooks` directory root-owned/not group writable
+once more. Ensure that the scripts are root-owned:
++
+[source,sh]
+----
+# chown -R root:root /usr/lib*/acme/hooks
+# chmod 755 /usr/lib*/acme/hooks
+----
++
+Inspect the hook scripts if you wish. Mark the hook scripts setuid:
++
+[source,sh]
+----
+# chmod u+s /usr/lib*/acme/hooks/*
+----
++
+UNIX systems don’t support setuid shell scripts, so this bit is ignored.
+Rather, acmetool takes it as a flag to tell it to run these scripts via
+`sudo`. This is necessary so that web servers, etc. can be reloaded.
++
+The conditions for running using `sudo` are that the files have the
+setuid bit set, that they be owned by root, that they be scripts and not
+binaries, and that acmetool is not being run as root.
+** Setup sudo. You will need to edit the sudoers file so that the hook
+scripts (which you have inspected and trust) can be executed by
+acmetool. It is essential that these have the `NOPASSWD` flag as the
+scripts must be executable noninteractively.
++
+`# visudo`
++
+Add the line:
++
+`acme ALL=(root) NOPASSWD: /usr/lib/acme/hooks/`
+** Setup your challenge method:
++
+*Webroot:* Make sure the `acme` user can write to the webroot directory
+you configured.
++
+*Redirector:* Make sure the directory `/var/run/acme/acme-challenge` is
+writable by the `acme` user. `acmetool` puts challenges here because the
+redirector looks here (internally it’s a glorified webroot mode).
++
+Note that `/var/run` will be a tmpfs on many modern OSes, so the
+directory ceases to exist on reboots. The redirector will try to create
+the directory (as user root, mode 0755) if it doesn’t exist. This
+happens before the redirector drops privileges from root. (It has to run
+as root initially to bind to port 80.)
++
+A configuration option has been added to make the redirector ensure that
+the directory is writable by a certain group when starting up. When this
+option is used, mode 0775 is used instead and the group owner is changed
+to a given GID.
++
+Pass `--challenge-gid=GID` to `acmetool redirector` (edit your service
+manager’s configuration, e.g. the systemd unit file), where GID is the
+numeric group ID of the group owner for the challenge directory
+(i.e. the GID of the `acme` group). (Group names rather than IDs may be
+supported on some platforms, but this is not guaranteed and will vary.
+Use of a GID is recommended.)
++
+*Proxy:* If you are using the proxy method, you won’t be able to listen
+on port 402 as a non-root user. Use port 4402 instead, which acmetool
+will try also try to use.
++
+*Listener:* This is not usable under non-root operation unless you can
+enable acmetool to bind to ports 80/443. On Linux you can do this by
+running `setcap 'cap_net_bind_service=+ep' /path/to/acmetool` as root.
+Other POSIX platforms may have sysctls to allow non-root processes to
+bind to low ports. However, this mode is not really useful for anything
+other than development anyway.
++
+*Hook:* See link:#challenge-hooks[Challenge Hooks].
+
+[[annex-external-resources-and-third-party-extentions]]
+== Annex: External resources and third party extentions
+
+The list of various tutorials, hook scripts and other integrations
+people have made for acmetool is now maintained
+https://github.com/hlandau/acme/wiki/ThirdPartyResources[in the wiki].
+
+* *https://github.com/hlandau/acme/wiki/ThirdPartyResources[List of
+third party resources]*
diff --git a/_doc/guide/style.css b/_doc/guide/style.css
new file mode 100644
index 0000000..49bd25b
--- /dev/null
+++ b/_doc/guide/style.css
@@ -0,0 +1,24 @@
+/* RESET */
+a img { border: none; }
+
+/* LOGO */
+#logo { text-align: center; margin-top: 1em; }
+html#index #logo { margin-top: 10em; }
+
+/* TOP-LEVEL HEADING */
+h1 { text-align: center; margin: 0 auto; }
+
+/* MID-LEVEL HEADING */
+h2 { margin-top: 2em; }
+h2::before { content: "█ "; color: #000; margin-left: 0; }
+
+/* NAV */
+nav#tnav > ul { list-style: none; text-align: center; }
+nav#tnav > ul > li { display: inline-block; padding: 0; margin: 0; }
+nav#tnav > ul > li:not(:first-child)::before { content: "·"; padding: 0.2em; }
+a:link { color: #00a; text-decoration: none; }
+
+/* TABLE OF CONTENTS */
+.toc { background-color: #e0e0e0; padding: 0.5em; margin: 0.5em; margin-bottom: 2em; }
+.toc > ul { list-style: none; margin: 0; padding: 0; }
+.toc-title { font-weight: bold; }
diff --git a/_doc/guide/to-xhtml.xsl b/_doc/guide/to-xhtml.xsl
new file mode 100644
index 0000000..d207ac0
--- /dev/null
+++ b/_doc/guide/to-xhtml.xsl
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="utf-8"?>
+<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns="http://www.w3.org/1999/xhtml" version="1.0">
+  <xsl:import href="docbook-xsl/xhtml5/docbook.xsl" />
+
+  <xsl:param name="generate.toc">
+    book toc
+  </xsl:param>
+
+  <xsl:param name="part.autolabel">0</xsl:param>
+  <xsl:param name="reference.autolabel">0</xsl:param>
+
+  <xsl:template name="user.head.content">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
+  </xsl:template>
+
+  <xsl:template name="user.header.content">
+    <div id="logo">
+      <h1><a href="."><img src="img/acmetool-logo-black.png" alt="acmetool - Let's Encrypt Client" /></a></h1>
+    </div>
+    <nav id="tnav">
+    <ul>
+      <li><a href=".">User's Guide</a></li>
+      <li><a href="https://git.devever.net/hlandau/acmetool/src/branch/master/README.md">README</a></li>
+      <li><a href="https://git.devever.net/hlandau/acmetool/releases">Download Binaries</a></li>
+      <li><a href="https://git.devever.net/hlandau/acmetool">Source Code</a></li>
+    </ul>
+    </nav>
+  </xsl:template>
+
+</xsl:stylesheet>
diff --git a/acmeapi/README.md b/acmeapi/README.md
deleted file mode 100644
index ded35ee..0000000
--- a/acmeapi/README.md
+++ /dev/null
@@ -1,16 +0,0 @@
-# ACME Client Library [![GoDoc](https://godoc.org/github.com/hlandau/acme/acmeapi?status.svg)](https://godoc.org/github.com/hlandau/acme/acmeapi) [![Build Status](https://travis-ci.org/hlandau/acme.svg?branch=master)](https://travis-ci.org/hlandau/acme) [![Issue Stats](http://issuestats.com/github/hlandau/acme/badge/issue?style=flat)](http://issuestats.com/github/hlandau/acme)
-
-Basic ACME client library. [See godoc for the
-API.](https://godoc.org/github.com/hlandau/acme/acmeapi)
-
-This is distinct from acmetool in that it simply calls the server as you
-request. It isn't smart and it doesn't manage certificate lifetimes. It can
-be used by Go code independently of acmetool.
-
-[For the acmetool command line tool, see
-here.](https://github.com/hlandau/acme)
-
-## Licence
-
-    © 2015 Hugo Landau <hlandau@devever.net>    MIT License
-
diff --git a/acmeapi/acmeendpoints/endpoint.go b/acmeapi/acmeendpoints/endpoint.go
deleted file mode 100644
index 03a2642..0000000
--- a/acmeapi/acmeendpoints/endpoint.go
+++ /dev/null
@@ -1,88 +0,0 @@
-// Package acmeendpoints provides information on known ACME servers.
-package acmeendpoints
-
-import (
-	"fmt"
-	"regexp"
-	"sync"
-	"text/template"
-)
-
-// Provides information on a known ACME endpoint.
-type Endpoint struct {
-	// Friendly name for the provider. Should be a short, single-line, title case
-	// human readable description of the endpoint.
-	Title string
-
-	// Short unique endpoint identifier. Must match ^[a-zA-Z][a-zA-Z0-9_]*$ and
-	// should use CamelCase.
-	Code string
-
-	// The ACME directory URL. Must be an HTTPS URL and typically ends in
-	// "/directory".
-	DirectoryURL string
-
-	// If this is not "", this is a regexp which must be matched iff an OCSP
-	// endpoint URL as found in a certificate implies that a certificate was
-	// issued by this endpoint.
-	OCSPURLRegexp string
-	ocspURLRegexp *regexp.Regexp
-
-	// If this is not "", this is a regexp which must be matched iff an URL
-	// appears to be an ACME certificate URL for this endpoint.
-	CertificateURLRegexp string
-	certificateURLRegexp *regexp.Regexp
-
-	// If this is not "", it is a Go template used to construct a certificate URL
-	// from an *x509.Certificate. The certificate is passed as variable
-	// "Certificate".
-	CertificateURLTemplate string
-	certificateURLTemplate *template.Template
-
-	initOnce sync.Once
-}
-
-func (e *Endpoint) String() string {
-	return fmt.Sprintf("Endpoint(%v)", e.DirectoryURL)
-}
-
-func (e *Endpoint) init() {
-	e.initOnce.Do(func() {
-		if e.OCSPURLRegexp != "" {
-			e.ocspURLRegexp = regexp.MustCompile(e.OCSPURLRegexp)
-		}
-
-		if e.CertificateURLRegexp != "" {
-			e.certificateURLRegexp = regexp.MustCompile(e.CertificateURLRegexp)
-		}
-
-		if e.CertificateURLTemplate != "" {
-			e.certificateURLTemplate = template.Must(template.New("certificate-url").Parse(e.CertificateURLTemplate))
-		}
-	})
-}
-
-var endpoints []*Endpoint
-
-// Visit all registered endpoints.
-func Visit(f func(p *Endpoint) error) error {
-	for _, p := range endpoints {
-		err := f(p)
-		if err != nil {
-			return err
-		}
-	}
-
-	return nil
-}
-
-// Register a new endpoint.
-func RegisterEndpoint(p *Endpoint) {
-	endpoints = append(endpoints, p)
-}
-
-func init() {
-	for _, p := range builtinEndpoints {
-		RegisterEndpoint(p)
-	}
-}
diff --git a/acmeapi/acmeendpoints/endpoint_test.go b/acmeapi/acmeendpoints/endpoint_test.go
deleted file mode 100644
index 0df14b7..0000000
--- a/acmeapi/acmeendpoints/endpoint_test.go
+++ /dev/null
@@ -1,47 +0,0 @@
-package acmeendpoints
-
-import (
-	"fmt"
-	"testing"
-)
-
-func TestVisit(t *testing.T) {
-	ep := map[*Endpoint]struct{}{}
-	err := Visit(func(e *Endpoint) error {
-		ep[e] = struct{}{}
-		return nil
-	})
-	if err != nil {
-		t.Fail()
-	}
-	_, ok := ep[&LetsEncryptLive]
-	if !ok {
-		t.Fail()
-	}
-	_, ok = ep[&LetsEncryptStaging]
-	if !ok {
-		t.Fail()
-	}
-
-	ep = map[*Endpoint]struct{}{}
-	e1 := fmt.Errorf("e1")
-	i := 0
-	err = Visit(func(e *Endpoint) error {
-		if i == 1 {
-			return e1
-		}
-		i++
-		ep[e] = struct{}{}
-		return nil
-	})
-	if err != e1 {
-		t.Fail()
-	}
-	if len(ep) != 1 {
-		t.Fail()
-	}
-	_, ok = ep[&LetsEncryptLive]
-	if !ok {
-		t.Fail()
-	}
-}
diff --git a/acmeapi/acmeendpoints/endpoints.go b/acmeapi/acmeendpoints/endpoints.go
deleted file mode 100644
index 839e1b6..0000000
--- a/acmeapi/acmeendpoints/endpoints.go
+++ /dev/null
@@ -1,31 +0,0 @@
-package acmeendpoints
-
-var (
-	// Let's Encrypt (Live)
-	LetsEncryptLive = Endpoint{
-		Code:                   "LetsEncryptLive",
-		Title:                  "Let's Encrypt (Live)",
-		DirectoryURL:           "https://acme-v01.api.letsencrypt.org/directory",
-		OCSPURLRegexp:          `^http://ocsp\.int-[^.]+\.letsencrypt\.org\.?(/.*)?$`,
-		CertificateURLRegexp:   `^https://acme-v01\.api\.letsencrypt\.org\.?/acme/cert/.*$`,
-		CertificateURLTemplate: `https://acme-v01.api.letsencrypt.org/acme/cert/{{.Certificate.SerialNumber|printf "%036x"}}`,
-	}
-
-	// Let's Encrypt (Staging)
-	LetsEncryptStaging = Endpoint{
-		Code:                   "LetsEncryptStaging",
-		Title:                  "Let's Encrypt (Staging)",
-		DirectoryURL:           "https://acme-staging.api.letsencrypt.org/directory",
-		OCSPURLRegexp:          `^http://ocsp\.(staging|stg-int)-[^.]+\.letsencrypt\.org\.?(/.*)?$`,
-		CertificateURLRegexp:   `^https://acme-staging\.api\.letsencrypt\.org\.?/acme/cert/.*$`,
-		CertificateURLTemplate: `https://acme-staging.api.letsencrypt.org/acme/cert/{{.Certificate.SerialNumber|printf "%036x"}}`,
-	}
-)
-
-// Suggested default endpoint.
-var DefaultEndpoint = &LetsEncryptLive
-
-var builtinEndpoints = []*Endpoint{
-	&LetsEncryptLive,
-	&LetsEncryptStaging,
-}
diff --git a/acmeapi/acmeendpoints/url.go b/acmeapi/acmeendpoints/url.go
deleted file mode 100644
index d806439..0000000
--- a/acmeapi/acmeendpoints/url.go
+++ /dev/null
@@ -1,176 +0,0 @@
-package acmeendpoints
-
-import (
-	"bytes"
-	"crypto/sha256"
-	"crypto/x509"
-	"errors"
-	"fmt"
-	"github.com/hlandau/acme/acmeapi"
-	"github.com/hlandau/xlog"
-	"golang.org/x/net/context"
-	"net/url"
-	"regexp"
-)
-
-var log, Log = xlog.New("acme.endpoints")
-
-// Returned when no matching endpoint can be found.
-var ErrNotFound = errors.New("no corresponding endpoint found")
-
-// Finds an endpoint with the given directory URL. If no such endpoint is
-// found, returns ErrNotFound.
-func ByDirectoryURL(directoryURL string) (*Endpoint, error) {
-	for _, e := range endpoints {
-		if directoryURL == e.DirectoryURL {
-			return e, nil
-		}
-	}
-
-	return nil, ErrNotFound
-}
-
-// If an endpoint exists with the given directory URL, returns it.
-//
-// Otherwise, tries to create a new endpoint for the directory URL.  Where
-// possible, endpoint parameters are guessed. Currently boulder is supported.
-// Non-boulder based endpoints will not have any parameters set other than the
-// directory URL, which means some operations on the endpoint will not succeed.
-//
-// It is acceptable to change the fields of the returned endpoint.
-// By default, the title of the endpoint is the directory URL.
-func CreateByDirectoryURL(directoryURL string) (*Endpoint, error) {
-	e, err := ByDirectoryURL(directoryURL)
-	if err == nil {
-		return e, nil
-	}
-
-	// Make a code for the endpoint by hashing the directory URL...
-	h := sha256.New()
-	h.Write([]byte(directoryURL))
-	code := fmt.Sprintf("Temp%08x", h.Sum(nil)[0:4])
-
-	e = &Endpoint{
-		Title:        directoryURL,
-		DirectoryURL: directoryURL,
-		Code:         code,
-	}
-
-	guessParameters(e)
-
-	return e, nil
-}
-
-func guessParameters(e *Endpoint) {
-	u, err := url.Parse(e.DirectoryURL)
-	if err != nil {
-		return
-	}
-
-	// not boulder
-	if u.Path != "/directory" {
-		return
-	}
-
-	if e.CertificateURLRegexp == "" {
-		e.CertificateURLRegexp = "^https://" + regexp.QuoteMeta(u.Host) + "/acme/cert/.*$"
-	}
-
-	if e.CertificateURLTemplate == "" {
-		e.CertificateURLTemplate = "https://" + u.Host + "/acme/cert/{{.Certificate.SerialNumber|printf \"%036x\"}}"
-	}
-}
-
-// Given an URL to a certificate, tries to determine the directory URL.
-func CertificateURLToDirectoryURL(certificateURL string) (string, error) {
-	for _, e := range endpoints {
-		e.init()
-
-		if e.certificateURLRegexp != nil && e.certificateURLRegexp.MatchString(certificateURL) {
-			return e.DirectoryURL, nil
-		}
-	}
-
-	return "", ErrNotFound
-}
-
-// Given a certificate in DER form, tries to determine the set of endpoints
-// which may have issued the certificate. certain is true if the returned
-// endpoint definitely issued the certificate, in which case len(endpoints) ==
-// 1 (but len(endpoints) == 1 does not necessarily imply certainty).
-func CertificateToEndpoints(cert *x509.Certificate) (endp []*Endpoint, certain bool, err error) {
-	var unknownEndpoints []*Endpoint
-
-	for _, e := range endpoints {
-		e.init()
-
-		if e.ocspURLRegexp == nil {
-			unknownEndpoints = append(unknownEndpoints, e)
-		}
-
-		log.Debugf("cert has OCSP %v", cert.OCSPServer)
-		for _, ocspServer := range cert.OCSPServer {
-			log.Debugf("%v %v", e, ocspServer)
-			if e.ocspURLRegexp != nil && e.ocspURLRegexp.MatchString(ocspServer) {
-				return []*Endpoint{e}, true, nil
-			}
-		}
-	}
-
-	if len(unknownEndpoints) > 0 {
-		return unknownEndpoints, false, nil
-	}
-
-	log.Debugf("cannot find any endpoints for certificate")
-	return nil, false, ErrNotFound
-}
-
-// Given a certificate, tries to determine the certificate URL and definite endpoint.
-func CertificateToEndpointURL(cl *acmeapi.Client, cert *x509.Certificate, ctx context.Context) (*Endpoint, string, error) {
-	es, certain, err := CertificateToEndpoints(cert)
-	if err != nil {
-		return nil, "", err
-	}
-
-	for _, e := range es {
-		if e.certificateURLTemplate == nil {
-			continue
-		}
-
-		var b bytes.Buffer
-		err = e.certificateURLTemplate.Execute(&b, map[string]interface{}{
-			"Certificate": cert,
-		})
-		if err != nil {
-			return nil, "", err
-		}
-
-		u := b.String()
-		if !certain {
-			// Check that this is the right endpoint via an HTTP request.
-			acrt := acmeapi.Certificate{
-				URI: u,
-			}
-
-			err := cl.LoadCertificate(&acrt, ctx)
-			if err != nil {
-				continue
-			}
-
-			// check that the certificate DER matches
-			if !bytes.Equal(acrt.Certificate, cert.Raw) {
-				continue
-			}
-		}
-
-		return e, u, nil
-	}
-
-	return nil, "", ErrNotFound
-}
-
-// Given a certificate, tries to determine the definite endpoint.
-func CertificateToEndpoint(cl *acmeapi.Client, cert *x509.Certificate, ctx context.Context) (*Endpoint, error) {
-	e, _, err := CertificateToEndpointURL(cl, cert, ctx)
-	return e, err
-}
diff --git a/acmeapi/acmeendpoints/url_test.go b/acmeapi/acmeendpoints/url_test.go
deleted file mode 100644
index 4443272..0000000
--- a/acmeapi/acmeendpoints/url_test.go
+++ /dev/null
@@ -1,259 +0,0 @@
-package acmeendpoints
-
-import (
-	"crypto/ecdsa"
-	"crypto/elliptic"
-	"crypto/rand"
-	"crypto/x509"
-	"github.com/hlandau/acme/acmeapi"
-	"github.com/hlandau/acme/acmeapi/acmeutils"
-	"github.com/hlandau/goutils/test"
-	"golang.org/x/net/context"
-	"math/big"
-	"net/http"
-	"testing"
-)
-
-const leStagingTestCert = `
------BEGIN CERTIFICATE-----
-MIIE6DCCA9CgAwIBAgITAPo8NeGtZ2xhrKoeMR+onLNgFzANBgkqhkiG9w0BAQsF
-ADAfMR0wGwYDVQQDDBRoYXBweSBoYWNrZXIgZmFrZSBDQTAeFw0xNjAxMTcxNjAz
-MDBaFw0xNjA0MTYxNjAzMDBaMB4xHDAaBgNVBAMTE2FxMS5saGguZGV2ZXZlci5u
-ZXQwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDTP6pFjvAzkVohGaGH
-hIJ746SGTdw2cjDfqZimiBc1Yrjl1AFlLfHHLZ7Uyt3b7EYlYao6P6Vx9wKigCI+
-vaeAudlZNerJa8fWNJXf4eqYoYH7vf+xnZP7TYUmiWLSGES9p8QBRCHwWPycP7mm
-X4kneqo/oF/asQnOmUy0hi2VyCCT/XQ93ApN5pHz8dg7A3OtOGlHXd38rJ3uBJ0N
-JXM6Dx5Oj833nDaa2ndkBxq5m0SLnOimE5GsqX7bWNfllMeZXqH5/3E25cgh2YTR
-6JBDLqpzO9ZvFOOWcOVk0QG+zfXhHVx++6I6fs36p3/+DN58WB/JP4CLV3JvC6cE
-NyuvAgMBAAGjggIcMIICGDAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYIKwYB
-BQUHAwEGCCsGAQUFBwMCMAwGA1UdEwEB/wQCMAAwHQYDVR0OBBYEFNB3WkfIcwYM
-bXABE4q5k3/o1vNHMB8GA1UdIwQYMBaAFPt4TxL5YBWDLJ8XfzQZsy426kGJMHgG
-CCsGAQUFBwEBBGwwajAzBggrBgEFBQcwAYYnaHR0cDovL29jc3Auc3RhZ2luZy14
-MS5sZXRzZW5jcnlwdC5vcmcvMDMGCCsGAQUFBzAChidodHRwOi8vY2VydC5zdGFn
-aW5nLXgxLmxldHNlbmNyeXB0Lm9yZy8wHgYDVR0RBBcwFYITYXExLmxoaC5kZXZl
-dmVyLm5ldDCB/gYDVR0gBIH2MIHzMAgGBmeBDAECATCB5gYLKwYBBAGC3xMBAQEw
-gdYwJgYIKwYBBQUHAgEWGmh0dHA6Ly9jcHMubGV0c2VuY3J5cHQub3JnMIGrBggr
-BgEFBQcCAjCBngyBm1RoaXMgQ2VydGlmaWNhdGUgbWF5IG9ubHkgYmUgcmVsaWVk
-IHVwb24gYnkgUmVseWluZyBQYXJ0aWVzIGFuZCBvbmx5IGluIGFjY29yZGFuY2Ug
-d2l0aCB0aGUgQ2VydGlmaWNhdGUgUG9saWN5IGZvdW5kIGF0IGh0dHBzOi8vbGV0
-c2VuY3J5cHQub3JnL3JlcG9zaXRvcnkvMA0GCSqGSIb3DQEBCwUAA4IBAQABcut7
-1jVicQnHvSkQgY1CRiGSmlHyOyEKimNtCuyaAVwm3cavV/wpGTDFnePyNds4cst/
-8BcL0QaKLmE1an/oeGmfs0U8maiKbL69Yun0qTNTKOaqJP/iitwAbliQ3TzO2kOZ
-+a2RkPKx0/zYlZb0GzhfIwHE4Qd7/P0qLphu2UaaEpzBnRlT1F9k+cGe4DZYb4XL
-BZHnOmXeZrhfPeeTw4VYAEtZ7fpwRhirBjshU8kRbO7KgZh4Id+v26FQpBE3eMQ2
-CWV8q8XThKcX3OaMOkLOIB2xZA7Fpj3JoDcsLPEKn5sxVgkxfjs03glTWd839qcE
-YAC6drs6Fev1cVa9
------END CERTIFICATE-----`
-
-const leLiveTestCert = `
------BEGIN CERTIFICATE-----
-MIIFCzCCA/OgAwIBAgISAaoIVMlVWnr9Vfrj+Ak2new4MA0GCSqGSIb3DQEBCwUA
-MEoxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1MZXQncyBFbmNyeXB0MSMwIQYDVQQD
-ExpMZXQncyBFbmNyeXB0IEF1dGhvcml0eSBYMTAeFw0xNjAxMTEwNDQ0MDBaFw0x
-NjA0MTAwNDQ0MDBaMBYxFDASBgNVBAMTC2RldmV2ZXIubmV0MIIBIjANBgkqhkiG
-9w0BAQEFAAOCAQ8AMIIBCgKCAQEArBzKQy0inr2oheVRuCDS2prucTF+8xQW66WP
-D5ZNzoypPFB9uvFSJN1QzMeq7fdLGWn3QIFj9HlntYxI7Sy47nFeciHG2lN7zfGL
-Lex0vREZ21ST3IfUuD/LogkAMqgjcymBiMdrO5hcPf0OIkboBe96BrBAKXTFVlme
-guwkdexNjedlFQ4egtzKZ2YrJXR4z9VOW0qaRNqk+9zvjLGG2mIay+NN0aTHomOk
-Ow+y8bFFJ9wrkMtn+/IwP1uIbyMEgF2qmKnB/G6H/Qdq52IBF1rCC5xlpWNB0w/3
-aJd512AqC5WFC/yFy8ksFS7EjIhQeyqBx1unyaz13C3yrRimbwIDAQABo4ICHTCC
-AhkwDgYDVR0PAQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcD
-AjAMBgNVHRMBAf8EAjAAMB0GA1UdDgQWBBQY0ADTmNDEDmrqY45CJCJdwvHp7DAf
-BgNVHSMEGDAWgBSoSmpjBH3duubRObemRWXv86jsoTBwBggrBgEFBQcBAQRkMGIw
-LwYIKwYBBQUHMAGGI2h0dHA6Ly9vY3NwLmludC14MS5sZXRzZW5jcnlwdC5vcmcv
-MC8GCCsGAQUFBzAChiNodHRwOi8vY2VydC5pbnQteDEubGV0c2VuY3J5cHQub3Jn
-LzAnBgNVHREEIDAeggtkZXZldmVyLm5ldIIPd3d3LmRldmV2ZXIubmV0MIH+BgNV
-HSAEgfYwgfMwCAYGZ4EMAQIBMIHmBgsrBgEEAYLfEwEBATCB1jAmBggrBgEFBQcC
-ARYaaHR0cDovL2Nwcy5sZXRzZW5jcnlwdC5vcmcwgasGCCsGAQUFBwICMIGeDIGb
-VGhpcyBDZXJ0aWZpY2F0ZSBtYXkgb25seSBiZSByZWxpZWQgdXBvbiBieSBSZWx5
-aW5nIFBhcnRpZXMgYW5kIG9ubHkgaW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBDZXJ0
-aWZpY2F0ZSBQb2xpY3kgZm91bmQgYXQgaHR0cHM6Ly9sZXRzZW5jcnlwdC5vcmcv
-cmVwb3NpdG9yeS8wDQYJKoZIhvcNAQELBQADggEBAHcD+3AjdbfZylPHFYyYSIWk
-no90p+rWZwh3sDnWC5KzZ8jm7uMynCvr7NK0BBxIzuqlWQ0vjKq41KFkTA+GllS/
-a4/1XnzrKIJ8udX698Ofsn6HEqxoT0/sAQhxGChrXDRl33QDowqquHWh8HGXx1ke
-jV1U4H69KjWYRNx7EN2kbik4GDznwOGpkAUPFCiW2g40zs8Lw4+RiTGPHNELzm7c
-TMAyWtPi4eJpMz87jYxv+jB6a4Zy5gAdEySejtGwerhGrrmntkliR8MKZQ6Lisd8
-h6xyLde4iNUiXtPOr9I87FBLC1U2AnP+GldAKYB3PO1qPHy6u/a15Xg34FrD8SM=
------END CERTIFICATE-----`
-
-type urlTestCase struct {
-	Cert     string
-	Endpoint *Endpoint
-}
-
-var urlTestCases = []*urlTestCase{
-	{
-		Cert:     leStagingTestCert,
-		Endpoint: &LetsEncryptStaging,
-	},
-	{
-		Cert:     leLiveTestCert,
-		Endpoint: &LetsEncryptLive,
-	},
-}
-
-func TestURL(t *testing.T) {
-	_, err := ByDirectoryURL("https://unknown/directory")
-	if err != ErrNotFound {
-		t.Fail()
-	}
-
-	for _, tc := range urlTestCases {
-		e, err := ByDirectoryURL(tc.Endpoint.DirectoryURL)
-		if err != nil {
-			t.Fatalf("cannot get by directory URL")
-		}
-
-		if e != tc.Endpoint {
-			t.Fatalf("got wrong endpoint: %v != %v", e, tc.Endpoint)
-		}
-
-		certs, err := acmeutils.LoadCertificates([]byte(tc.Cert))
-		if err != nil {
-			t.Fatalf("cannot load test certificate")
-		}
-
-		c0, err := x509.ParseCertificate(certs[0])
-		if err != nil {
-			t.Fatalf("cannot parse certificate")
-		}
-
-		cl := acmeapi.Client{}
-		e, certURL, err := CertificateToEndpointURL(&cl, c0, context.TODO())
-		if err != nil {
-			t.Fatalf("cannot map certificate to endpoint")
-		}
-
-		e2, err := CertificateToEndpoint(&cl, c0, context.TODO())
-		if e2 != e {
-			t.Fatalf("mismatch")
-		}
-
-		if e != tc.Endpoint {
-			t.Fatalf("certificate mapped to wrong endpoint: %v != %v", e, tc.Endpoint)
-		}
-
-		dURL, err := CertificateURLToDirectoryURL(certURL)
-		if err != nil {
-			t.Fatalf("cannot map certificate URL to directory URL: %v", err)
-		}
-
-		if dURL != e.DirectoryURL {
-			t.Fatalf("directory URL mismatch: %v != %v", dURL, e.DirectoryURL)
-		}
-	}
-}
-
-func TestGuess(t *testing.T) {
-	crt := &x509.Certificate{
-		OCSPServer: []string{
-			"https://example.com/",
-		},
-		SerialNumber: big.NewInt(0xdeadb33f),
-	}
-
-	endp, certain, err := CertificateToEndpoints(crt)
-	if err != ErrNotFound || endp != nil || certain {
-		t.Fail()
-	}
-
-	e, err := CreateByDirectoryURL("https://unknown-boulder.test/directory")
-	if err != nil {
-		t.Fail()
-	}
-
-	RegisterEndpoint(e)
-
-	e2, err := CreateByDirectoryURL("https://unknown-boulder.test/directory")
-	if e2 != e || err != nil {
-		t.Fatal()
-	}
-
-	e3, err := CreateByDirectoryURL("https://unknown-boulder3.test/")
-	if err != nil {
-		t.Fatal()
-	}
-
-	RegisterEndpoint(e3)
-
-	e4, err := CreateByDirectoryURL("https://unknown-boulder4.test/directory")
-	if err != nil {
-		t.Fatal()
-	}
-
-	RegisterEndpoint(e4)
-
-	du, err := CertificateURLToDirectoryURL("https://unknown-boulder.test/acme/cert/deadb33f")
-	if err != nil {
-		t.Fatal()
-	}
-	if du != e.DirectoryURL {
-		t.Fatal()
-	}
-
-	du, err = CertificateURLToDirectoryURL("https://other-boulder.test/acme/cert/deadb33f")
-	if err != ErrNotFound {
-		t.Fatal()
-	}
-
-	endp, certain, err = CertificateToEndpoints(crt)
-	if err != nil || certain || len(endp) != 3 {
-		t.Fatal()
-	}
-	if endp[0] != e || endp[1] != e3 {
-		t.Fail()
-	}
-
-	privKey, _ := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
-	crtb, err := x509.CreateCertificate(rand.Reader, crt, crt, &privKey.PublicKey, privKey)
-	if err != nil {
-		t.Fatalf("%v", err)
-	}
-
-	crtb2 := make([]byte, len(crtb))
-	copy(crtb2, crtb)
-	mt := test.HTTPMockTransport{}
-	mt.Add("unknown-boulder4.test/acme/cert/0000000000000000000000000000deadb33f", &http.Response{
-		StatusCode: 200,
-		Header: http.Header{
-			"Content-Type": []string{"application/pkix-cert"},
-		},
-	}, crtb2)
-	crt, _ = x509.ParseCertificate(crtb)
-	cl := &acmeapi.Client{
-		HTTPClient: &http.Client{
-			Transport: &mt,
-		},
-	}
-	_, cURL, err := CertificateToEndpointURL(cl, crt, context.TODO())
-	if err != nil {
-		t.Fatalf("%v", err)
-	}
-	if cURL != "https://unknown-boulder4.test/acme/cert/0000000000000000000000000000deadb33f" {
-		t.Fatalf("curl %v", cURL)
-	}
-	mt.Clear()
-	mt.Add("unknown-boulder.test/acme/cert/0000000000000000000000000000deadb33f", &http.Response{
-		StatusCode: 200,
-		Header: http.Header{
-			"Content-Type": []string{"application/pkix-cert"},
-		},
-	}, crtb2)
-	_, cURL, err = CertificateToEndpointURL(cl, crt, context.TODO())
-	if err != nil {
-		t.Fatalf("%v", err)
-	}
-	if cURL != "https://unknown-boulder.test/acme/cert/0000000000000000000000000000deadb33f" {
-		t.Fatalf("curl %v", cURL)
-	}
-	crtb2[5] ^= 1
-	_, cURL, err = CertificateToEndpointURL(cl, crt, context.TODO())
-	if err == nil {
-		t.Fatal()
-	}
-	mt.Clear()
-	_, cURL, err = CertificateToEndpointURL(cl, crt, context.TODO())
-	if err == nil {
-		t.Fatal()
-	}
-}
diff --git a/acmeapi/acmeutils/hostname.go b/acmeapi/acmeutils/hostname.go
deleted file mode 100644
index ad51d20..0000000
--- a/acmeapi/acmeutils/hostname.go
+++ /dev/null
@@ -1,33 +0,0 @@
-package acmeutils
-
-import (
-	"fmt"
-	"golang.org/x/net/idna"
-	"regexp"
-	"strings"
-)
-
-var reHostname = regexp.MustCompilePOSIX(`^([a-z0-9_-]+\.)*[a-z0-9_-]+$`)
-
-// Normalizes the hostname given. If the hostname is not valid, returns "" and
-// an error.
-func NormalizeHostname(name string) (string, error) {
-	name = strings.TrimSuffix(strings.ToLower(name), ".")
-
-	name, err := idna.ToASCII(name)
-	if err != nil {
-		return "", fmt.Errorf("IDN error: %#v: %v", name, err)
-	}
-
-	if !reHostname.MatchString(name) {
-		return "", fmt.Errorf("invalid hostname: %#v", name)
-	}
-
-	return name, nil
-}
-
-// Returns true iff the given string is a valid hostname.
-func ValidateHostname(name string) bool {
-	_, err := NormalizeHostname(name)
-	return err == nil
-}
diff --git a/acmeapi/acmeutils/keyauth.go b/acmeapi/acmeutils/keyauth.go
deleted file mode 100644
index 74b3e10..0000000
--- a/acmeapi/acmeutils/keyauth.go
+++ /dev/null
@@ -1,130 +0,0 @@
-package acmeutils
-
-import (
-	"crypto"
-	"crypto/ecdsa"
-	"crypto/elliptic"
-	"crypto/rand"
-	"crypto/sha256"
-	"crypto/x509"
-	"crypto/x509/pkix"
-	"encoding/base64"
-	"encoding/hex"
-	"encoding/json"
-	"gopkg.in/square/go-jose.v1"
-	"math/big"
-	"time"
-)
-
-// Calculates the base64 thumbprint of a public or private key. Returns an
-// error if the key is of an unknown type.
-func Base64Thumbprint(key interface{}) (string, error) {
-	k := jose.JsonWebKey{Key: key}
-	thumbprint, err := k.Thumbprint(crypto.SHA256)
-	if err != nil {
-		return "", err
-	}
-
-	return b64enc(thumbprint), nil
-}
-
-// Calculates a key authorization using the given account public or private key
-// and the token to prefix.
-func KeyAuthorization(accountKey interface{}, token string) (string, error) {
-	thumbprint, err := Base64Thumbprint(accountKey)
-	if err != nil {
-		return "", err
-	}
-
-	return token + "." + thumbprint, nil
-}
-
-// Calculates a key authorization which is then hashed and base64 encoded as is
-// required for the DNS challenge.
-func DNSKeyAuthorization(accountKey interface{}, token string) (string, error) {
-	ka, err := KeyAuthorization(accountKey, token)
-	if err != nil {
-		return "", err
-	}
-
-	return b64enc(sha256Bytes([]byte(ka))), nil
-}
-
-// Determines the hostname which must appear in a TLS-SNI challenge
-// certificate.
-func TLSSNIHostname(accountKey interface{}, token string) (string, error) {
-	ka, err := KeyAuthorization(accountKey, token)
-	if err != nil {
-		return "", err
-	}
-
-	kaHex := sha256BytesHex([]byte(ka))
-	return kaHex[0:32] + "." + kaHex[32:64] + ".acme.invalid", nil
-}
-
-// Creates a self-signed certificate and matching private key suitable for
-// responding to a TLS-SNI challenge. hostname should be a hostname returned by
-// TLSSNIHostname.
-func CreateTLSSNICertificate(hostname string) (certDER []byte, privateKey crypto.PrivateKey, err error) {
-	crt := x509.Certificate{
-		Subject: pkix.Name{
-			CommonName: hostname,
-		},
-		Issuer: pkix.Name{
-			CommonName: hostname,
-		},
-		SerialNumber:          big.NewInt(1),
-		NotBefore:             time.Now().Add(-24 * time.Hour),
-		NotAfter:              time.Now().Add(365 * 24 * time.Hour),
-		KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
-		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
-		BasicConstraintsValid: true,
-		DNSNames:              []string{hostname},
-	}
-
-	pk, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
-	if err != nil {
-		return
-	}
-
-	certDER, err = x509.CreateCertificate(rand.Reader, &crt, &crt, &pk.PublicKey, pk)
-	privateKey = pk
-	return
-}
-
-// Returns JSON suitable as a generic challenge initiation response to the ACME
-// server. You pass this to RespondToChallenge as a json.RawMessage. Suitable
-// for most, but not all, challenge types.
-func ChallengeResponseJSON(accountKey interface{}, token, challengeType string) ([]byte, error) {
-	ka, err := KeyAuthorization(accountKey, token)
-	if err != nil {
-		return nil, err
-	}
-
-	info := map[string]interface{}{
-		"resource":         "challenge",
-		"type":             challengeType,
-		"keyAuthorization": ka,
-	}
-
-	bb, err := json.Marshal(&info)
-	if err != nil {
-		return nil, err
-	}
-
-	return bb, nil
-}
-
-func sha256Bytes(b []byte) []byte {
-	h := sha256.New()
-	h.Write(b)
-	return h.Sum(nil)
-}
-
-func sha256BytesHex(b []byte) string {
-	return hex.EncodeToString(sha256Bytes(b))
-}
-
-func b64enc(b []byte) string {
-	return base64.RawURLEncoding.EncodeToString(b)
-}
diff --git a/acmeapi/acmeutils/keyauth_test.go b/acmeapi/acmeutils/keyauth_test.go
deleted file mode 100644
index 38145ac..0000000
--- a/acmeapi/acmeutils/keyauth_test.go
+++ /dev/null
@@ -1,56 +0,0 @@
-package acmeutils
-
-import "testing"
-
-func TestKeyAuthorization(t *testing.T) {
-	pk, err := LoadPrivateKey([]byte(testKey))
-	if err != nil {
-		t.Fatal()
-	}
-
-	ka, err := KeyAuthorization(pk, "foo")
-	if err != nil {
-		t.Fatal()
-	}
-
-	if ka != "foo.UOn6kBbQDrwoTc2BcjGS1_JeF5rDIVYrZmBhs5bgXWo" {
-		t.Fatal()
-	}
-
-	pk, err = LoadPrivateKey([]byte(testECKey))
-	if err != nil {
-		t.Fatal()
-	}
-
-	ka, err = KeyAuthorization(pk, "foo")
-	if err != nil {
-		t.Fatal()
-	}
-
-	if ka != "foo.S8MUz-12EEFgpVWWfDpvolnpTkuD9yVV6qHdzFuJyj8" {
-		t.Fatalf("%v", ka)
-	}
-
-	ka, err = DNSKeyAuthorization(pk, "foo")
-	if err != nil {
-		t.Fatal()
-	}
-
-	if ka != "efdLQjp7LK3TpMZ4b5UsX-vVaexjtxTNfn1M3Shfqjo" {
-		t.Fatalf("#v", ka)
-	}
-
-	hostname, err := TLSSNIHostname(pk, "foo")
-	if err != nil {
-		t.Fatal()
-	}
-
-	if hostname != "79f74b423a7b2cadd3a4c6786f952c5f.ebd569ec63b714cd7e7d4cdd285faa3a.acme.invalid" {
-		t.Fatalf("%#v", hostname)
-	}
-
-	_, _, err = CreateTLSSNICertificate(hostname)
-	if err != nil {
-		t.Fatal()
-	}
-}
diff --git a/acmeapi/acmeutils/load.go b/acmeapi/acmeutils/load.go
deleted file mode 100644
index deeec25..0000000
--- a/acmeapi/acmeutils/load.go
+++ /dev/null
@@ -1,145 +0,0 @@
-// Package acmeutils provides miscellaneous ACME-related utility functions.
-package acmeutils
-
-import (
-	"crypto"
-	"crypto/ecdsa"
-	"crypto/rsa"
-	"crypto/x509"
-	"encoding/pem"
-	"fmt"
-	"io"
-	"strings"
-)
-
-// Load one or more certificates from a sequence of PEM-encoded certificates.
-func LoadCertificates(pemBlock []byte) ([][]byte, error) {
-	var derBlock *pem.Block
-	var certs [][]byte
-	for {
-		derBlock, pemBlock = pem.Decode(pemBlock)
-		if derBlock == nil {
-			break
-		}
-		if derBlock.Type != "CERTIFICATE" {
-			return nil, fmt.Errorf("is not a certificate")
-		}
-
-		certs = append(certs, derBlock.Bytes)
-	}
-
-	if len(certs) == 0 {
-		return nil, fmt.Errorf("no certificates found")
-	}
-
-	return certs, nil
-}
-
-// Writes one or more DER-formatted certificates in PEM format.
-func SaveCertificates(w io.Writer, certificates ...[]byte) error {
-	for _, c := range certificates {
-		err := pem.Encode(w, &pem.Block{
-			Type:  "CERTIFICATE",
-			Bytes: c,
-		})
-		if err != nil {
-			return err
-		}
-	}
-
-	return nil
-}
-
-// Load a PEM private key from a stream.
-func LoadPrivateKey(keyPEMBlock []byte) (crypto.PrivateKey, error) {
-	var keyDERBlock *pem.Block
-	for {
-		keyDERBlock, keyPEMBlock = pem.Decode(keyPEMBlock)
-		if keyDERBlock == nil {
-			return nil, fmt.Errorf("failed to parse key PEM data")
-		}
-		if keyDERBlock.Type == "PRIVATE KEY" || strings.HasSuffix(keyDERBlock.Type, " PRIVATE KEY") {
-			break
-		}
-	}
-
-	pk, err := LoadPrivateKeyDER(keyDERBlock.Bytes)
-	if err != nil {
-		return nil, err
-	}
-
-	return pk, nil
-}
-
-// Parse a DER private key. The key can be RSA or ECDSA. PKCS8 containers are
-// supported.
-func LoadPrivateKeyDER(der []byte) (crypto.PrivateKey, error) {
-	pk, err := x509.ParsePKCS1PrivateKey(der)
-	if err == nil {
-		return pk, nil
-	}
-
-	pk2, err := x509.ParsePKCS8PrivateKey(der)
-	if err == nil {
-		switch pk2 := pk2.(type) {
-		case *rsa.PrivateKey, *ecdsa.PrivateKey:
-			return pk2, nil
-		default:
-			return nil, fmt.Errorf("unknown private key type")
-		}
-	}
-
-	epk, err := x509.ParseECPrivateKey(der)
-	if err == nil {
-		return epk, nil
-	}
-
-	return nil, fmt.Errorf("failed to parse private key")
-}
-
-// Write a private key in PEM form.
-func SavePrivateKey(w io.Writer, pk crypto.PrivateKey) error {
-	var kb []byte
-	var hdr string
-	var err error
-
-	switch v := pk.(type) {
-	case *rsa.PrivateKey:
-		kb = x509.MarshalPKCS1PrivateKey(v)
-		hdr = "RSA PRIVATE KEY"
-	case *ecdsa.PrivateKey:
-		kb, err = x509.MarshalECPrivateKey(v)
-		hdr = "EC PRIVATE KEY"
-	default:
-		return fmt.Errorf("unsupported private key type: %T", pk)
-	}
-	if err != nil {
-		return err
-	}
-
-	err = pem.Encode(w, &pem.Block{
-		Type:  hdr,
-		Bytes: kb,
-	})
-	if err != nil {
-		return err
-	}
-
-	return nil
-}
-
-// Load a PEM CSR from a stream and return it in DER form.
-func LoadCSR(pemBlock []byte) ([]byte, error) {
-	var derBlock *pem.Block
-	for {
-		derBlock, pemBlock = pem.Decode(pemBlock)
-		if derBlock == nil {
-			return nil, fmt.Errorf("failed to parse CSR PEM data")
-		}
-		if derBlock.Type == "CERTIFICATE REQUEST" {
-			break
-		}
-	}
-
-	return derBlock.Bytes, nil
-}
diff --git a/acmeapi/acmeutils/load_test.go b/acmeapi/acmeutils/load_test.go
deleted file mode 100644
index 2b31526..0000000
--- a/acmeapi/acmeutils/load_test.go
+++ /dev/null
@@ -1,540 +0,0 @@
-package acmeutils
-
-import (
-	"bytes"
-	"crypto/ecdsa"
-	"crypto/elliptic"
-	"crypto/rsa"
-	"math/big"
-	"reflect"
-	"testing"
-)
-
-const testCerts = `-----BEGIN CERTIFICATE-----
-MIIEmzCCA4OgAwIBAgITAP8qTldZTvtEDieNbQA7/6O6mDANBgkqhkiG9w0BAQsF
-ADAfMR0wGwYDVQQDExRoYXBweSBoYWNrZXIgZmFrZSBDQTAeFw0xNTExMjcxMTE1
-MDBaFw0xNjAyMjUxMTE1MDBaMCkxJzAlBgNVBAMTHmRvbTEuYWNtZXRvb2wtdGVz
-dC5kZXZldmVyLm5ldDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMKQ
-an2mcZAIWqu7J5/6n+KQ521+VlsJEe3189hLJfzTbxpDxag/DiJo2xcl4jZeEAkr
-FR4JZxs693lh92YnbSfWwZ0IvjEUNOYJGs9L59wADTu7wEoM2xAWWSUh85ziKwpb
-P/JE7i1D4+Mlll/xEcfbzpbYdlGKND76wAGyapJ4ozdXr2Bjtp4rEiMGjyOfgbur
-ex20Fyv1A40UwdaKdypnmtEyXIdP++/dj4yWGX3rszyO1erGzsCIng9EDhPreL3c
-7uZVnZJrrlUPS7mPJzPfjUZhCWK9BQniAoSHiZiB0lAB2TUNU4gaqGgj4TDv1KPa
-pqP1spdcIWGqA+40j70CAwEAAaOCAcQwggHAMA4GA1UdDwEB/wQEAwIFoDAdBgNV
-HSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwDAYDVR0TAQH/BAIwADAdBgNVHQ4E
-FgQUO1JtuzcEAU6kv0VQlEcL59SvNOQwHwYDVR0jBBgwFoAU+3hPEvlgFYMsnxd/
-NBmzLjbqQYkwagYIKwYBBQUHAQEEXjBcMCYGCCsGAQUFBzABhhpodHRwOi8vMTI3
-LjAuMC4xOjQwMDIvb2NzcDAyBggrBgEFBQcwAoYmaHR0cDovLzEyNy4wLjAuMTo0
-MDAwL2FjbWUvaXNzdWVyLWNlcnQwSQYDVR0RBEIwQIIeZG9tMS5hY21ldG9vbC10
-ZXN0LmRldmV2ZXIubmV0gh5kb20yLmFjbWV0b29sLXRlc3QuZGV2ZXZlci5uZXQw
-JwYDVR0fBCAwHjAcoBqgGIYWaHR0cDovL2V4YW1wbGUuY29tL2NybDBhBgNVHSAE
-WjBYMAgGBmeBDAECATBMBgMqAwQwRTAiBggrBgEFBQcCARYWaHR0cDovL2V4YW1w
-bGUuY29tL2NwczAfBggrBgEFBQcCAjATDBFEbyBXaGF0IFRob3UgV2lsdDANBgkq
-hkiG9w0BAQsFAAOCAQEAhpchBW1k++LrbyaCG0Y8dpJY01TDhKxNoMrEGTd7UH0F
-7Ar+kBPOcf0gglvX6gcZzcJkILQTbBct5Lvqta+j/JMkseAoAFr31GWP7SdeOsmi
-txzWmbL+Mm256jqXPYewUiK1k9HpmPT9CajS6T/f2Q0RvRQgRD4e2B61kTRMt3t4
-p7u0/wF5PDzsj8oC0D/yUSBU7icWHPkzuKhw+zjYZPoVdyEe0CoLMtTskPZooZby
-M+ngFyg3Boy1R4px/mmdV1fds5nHdZ+R6g2qe7FT7LB8KUVsUMEyCUiDIzeu1WLn
-vWa/xVfwBbKvgMjnHs31qODbsSzRRpNgX0NWE14jew==
------END CERTIFICATE-----
------BEGIN CERTIFICATE-----
-MIIEijCCA3KgAwIBAgICEk0wDQYJKoZIhvcNAQELBQAwKzEpMCcGA1UEAwwgY2Fj
-a2xpbmcgY3J5cHRvZ3JhcGhlciBmYWtlIFJPT1QwHhcNMTUxMDIxMjAxMTUyWhcN
-MjAxMDE5MjAxMTUyWjAfMR0wGwYDVQQDExRoYXBweSBoYWNrZXIgZmFrZSBDQTCC
-ASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMIKR3maBcUSsncXYzQT13D5
-Nr+Z3mLxMMh3TUdt6sACmqbJ0btRlgXfMtNLM2OU1I6a3Ju+tIZSdn2v21JBwvxU
-zpZQ4zy2cimIiMQDZCQHJwzC9GZn8HaW091iz9H0Go3A7WDXwYNmsdLNRi00o14U
-joaVqaPsYrZWvRKaIRqaU0hHmS0AWwQSvN/93iMIXuyiwywmkwKbWnnxCQ/gsctK
-FUtcNrwEx9Wgj6KlhwDTyI1QWSBbxVYNyUgPFzKxrSmwMO0yNff7ho+QT9x5+Y/7
-XE59S4Mc4ZXxcXKew/gSlN9U5mvT+D2BhDtkCupdfsZNCQWp27A+b/DmrFI9NqsC
-AwEAAaOCAcIwggG+MBIGA1UdEwEB/wQIMAYBAf8CAQAwQwYDVR0eBDwwOqE4MAaC
-BC5taWwwCocIAAAAAAAAAAAwIocgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
-AAAAAAAwDgYDVR0PAQH/BAQDAgGGMH8GCCsGAQUFBwEBBHMwcTAyBggrBgEFBQcw
-AYYmaHR0cDovL2lzcmcudHJ1c3RpZC5vY3NwLmlkZW50cnVzdC5jb20wOwYIKwYB
-BQUHMAKGL2h0dHA6Ly9hcHBzLmlkZW50cnVzdC5jb20vcm9vdHMvZHN0cm9vdGNh
-eDMucDdjMB8GA1UdIwQYMBaAFOmkP+6epeby1dd5YDyTpi4kjpeqMFQGA1UdIARN
-MEswCAYGZ4EMAQIBMD8GCysGAQQBgt8TAQEBMDAwLgYIKwYBBQUHAgEWImh0dHA6
-Ly9jcHMucm9vdC14MS5sZXRzZW5jcnlwdC5vcmcwPAYDVR0fBDUwMzAxoC+gLYYr
-aHR0cDovL2NybC5pZGVudHJ1c3QuY29tL0RTVFJPT1RDQVgzQ1JMLmNybDAdBgNV
-HQ4EFgQU+3hPEvlgFYMsnxd/NBmzLjbqQYkwDQYJKoZIhvcNAQELBQADggEBAA0Y
-AeLXOklx4hhCikUUl+BdnFfn1g0W5AiQLVNIOL6PnqXu0wjnhNyhqdwnfhYMnoy4
-idRh4lB6pz8Gf9pnlLd/DnWSV3gS+/I/mAl1dCkKby6H2V790e6IHmIK2KYm3jm+
-U++FIdGpBdsQTSdmiX/rAyuxMDM0adMkNBwTfQmZQCz6nGHw1QcSPZMvZpsC8Skv
-ekzxsjF1otOrMUPNPQvtTWrVx8GlR2qfx/4xbQa1v2frNvFBCmO59goz+jnWvfTt
-j2NjwDZ7vlMBsPm16dbKYC840uvRoZjxqsdc3ChCZjqimFqlNG/xoPA8+dTicZzC
-XE9ijPIcvW6y1aa3bGw=
------END CERTIFICATE-----`
-
-var testCertsDER = [][]byte{
-	{
-		0x30, 0x82, 0x04, 0x9b, 0x30, 0x82, 0x03, 0x83, 0xa0, 0x03, 0x02, 0x01,
-		0x02, 0x02, 0x13, 0x00, 0xff, 0x2a, 0x4e, 0x57, 0x59, 0x4e, 0xfb, 0x44,
-		0x0e, 0x27, 0x8d, 0x6d, 0x00, 0x3b, 0xff, 0xa3, 0xba, 0x98, 0x30, 0x0d,
-		0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05,
-		0x00, 0x30, 0x1f, 0x31, 0x1d, 0x30, 0x1b, 0x06, 0x03, 0x55, 0x04, 0x03,
-		0x13, 0x14, 0x68, 0x61, 0x70, 0x70, 0x79, 0x20, 0x68, 0x61, 0x63, 0x6b,
-		0x65, 0x72, 0x20, 0x66, 0x61, 0x6b, 0x65, 0x20, 0x43, 0x41, 0x30, 0x1e,
-		0x17, 0x0d, 0x31, 0x35, 0x31, 0x31, 0x32, 0x37, 0x31, 0x31, 0x31, 0x35,
-		0x30, 0x30, 0x5a, 0x17, 0x0d, 0x31, 0x36, 0x30, 0x32, 0x32, 0x35, 0x31,
-		0x31, 0x31, 0x35, 0x30, 0x30, 0x5a, 0x30, 0x29, 0x31, 0x27, 0x30, 0x25,
-		0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x1e, 0x64, 0x6f, 0x6d, 0x31, 0x2e,
-		0x61, 0x63, 0x6d, 0x65, 0x74, 0x6f, 0x6f, 0x6c, 0x2d, 0x74, 0x65, 0x73,
-		0x74, 0x2e, 0x64, 0x65, 0x76, 0x65, 0x76, 0x65, 0x72, 0x2e, 0x6e, 0x65,
-		0x74, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,
-		0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f,
-		0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xc2, 0x90,
-		0x6a, 0x7d, 0xa6, 0x71, 0x90, 0x08, 0x5a, 0xab, 0xbb, 0x27, 0x9f, 0xfa,
-		0x9f, 0xe2, 0x90, 0xe7, 0x6d, 0x7e, 0x56, 0x5b, 0x09, 0x11, 0xed, 0xf5,
-		0xf3, 0xd8, 0x4b, 0x25, 0xfc, 0xd3, 0x6f, 0x1a, 0x43, 0xc5, 0xa8, 0x3f,
-		0x0e, 0x22, 0x68, 0xdb, 0x17, 0x25, 0xe2, 0x36, 0x5e, 0x10, 0x09, 0x2b,
-		0x15, 0x1e, 0x09, 0x67, 0x1b, 0x3a, 0xf7, 0x79, 0x61, 0xf7, 0x66, 0x27,
-		0x6d, 0x27, 0xd6, 0xc1, 0x9d, 0x08, 0xbe, 0x31, 0x14, 0x34, 0xe6, 0x09,
-		0x1a, 0xcf, 0x4b, 0xe7, 0xdc, 0x00, 0x0d, 0x3b, 0xbb, 0xc0, 0x4a, 0x0c,
-		0xdb, 0x10, 0x16, 0x59, 0x25, 0x21, 0xf3, 0x9c, 0xe2, 0x2b, 0x0a, 0x5b,
-		0x3f, 0xf2, 0x44, 0xee, 0x2d, 0x43, 0xe3, 0xe3, 0x25, 0x96, 0x5f, 0xf1,
-		0x11, 0xc7, 0xdb, 0xce, 0x96, 0xd8, 0x76, 0x51, 0x8a, 0x34, 0x3e, 0xfa,
-		0xc0, 0x01, 0xb2, 0x6a, 0x92, 0x78, 0xa3, 0x37, 0x57, 0xaf, 0x60, 0x63,
-		0xb6, 0x9e, 0x2b, 0x12, 0x23, 0x06, 0x8f, 0x23, 0x9f, 0x81, 0xbb, 0xab,
-		0x7b, 0x1d, 0xb4, 0x17, 0x2b, 0xf5, 0x03, 0x8d, 0x14, 0xc1, 0xd6, 0x8a,
-		0x77, 0x2a, 0x67, 0x9a, 0xd1, 0x32, 0x5c, 0x87, 0x4f, 0xfb, 0xef, 0xdd,
-		0x8f, 0x8c, 0x96, 0x19, 0x7d, 0xeb, 0xb3, 0x3c, 0x8e, 0xd5, 0xea, 0xc6,
-		0xce, 0xc0, 0x88, 0x9e, 0x0f, 0x44, 0x0e, 0x13, 0xeb, 0x78, 0xbd, 0xdc,
-		0xee, 0xe6, 0x55, 0x9d, 0x92, 0x6b, 0xae, 0x55, 0x0f, 0x4b, 0xb9, 0x8f,
-		0x27, 0x33, 0xdf, 0x8d, 0x46, 0x61, 0x09, 0x62, 0xbd, 0x05, 0x09, 0xe2,
-		0x02, 0x84, 0x87, 0x89, 0x98, 0x81, 0xd2, 0x50, 0x01, 0xd9, 0x35, 0x0d,
-		0x53, 0x88, 0x1a, 0xa8, 0x68, 0x23, 0xe1, 0x30, 0xef, 0xd4, 0xa3, 0xda,
-		0xa6, 0xa3, 0xf5, 0xb2, 0x97, 0x5c, 0x21, 0x61, 0xaa, 0x03, 0xee, 0x34,
-		0x8f, 0xbd, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x82, 0x01, 0xc4, 0x30,
-		0x82, 0x01, 0xc0, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x1d, 0x0f, 0x01, 0x01,
-		0xff, 0x04, 0x04, 0x03, 0x02, 0x05, 0xa0, 0x30, 0x1d, 0x06, 0x03, 0x55,
-		0x1d, 0x25, 0x04, 0x16, 0x30, 0x14, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05,
-		0x05, 0x07, 0x03, 0x01, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07,
-		0x03, 0x02, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x01, 0x01, 0xff,
-		0x04, 0x02, 0x30, 0x00, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04,
-		0x16, 0x04, 0x14, 0x3b, 0x52, 0x6d, 0xbb, 0x37, 0x04, 0x01, 0x4e, 0xa4,
-		0xbf, 0x45, 0x50, 0x94, 0x47, 0x0b, 0xe7, 0xd4, 0xaf, 0x34, 0xe4, 0x30,
-		0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14,
-		0xfb, 0x78, 0x4f, 0x12, 0xf9, 0x60, 0x15, 0x83, 0x2c, 0x9f, 0x17, 0x7f,
-		0x34, 0x19, 0xb3, 0x2e, 0x36, 0xea, 0x41, 0x89, 0x30, 0x6a, 0x06, 0x08,
-		0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x5e, 0x30, 0x5c,
-		0x30, 0x26, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01,
-		0x86, 0x1a, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x31, 0x32, 0x37,
-		0x2e, 0x30, 0x2e, 0x30, 0x2e, 0x31, 0x3a, 0x34, 0x30, 0x30, 0x32, 0x2f,
-		0x6f, 0x63, 0x73, 0x70, 0x30, 0x32, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05,
-		0x05, 0x07, 0x30, 0x02, 0x86, 0x26, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f,
-		0x2f, 0x31, 0x32, 0x37, 0x2e, 0x30, 0x2e, 0x30, 0x2e, 0x31, 0x3a, 0x34,
-		0x30, 0x30, 0x30, 0x2f, 0x61, 0x63, 0x6d, 0x65, 0x2f, 0x69, 0x73, 0x73,
-		0x75, 0x65, 0x72, 0x2d, 0x63, 0x65, 0x72, 0x74, 0x30, 0x49, 0x06, 0x03,
-		0x55, 0x1d, 0x11, 0x04, 0x42, 0x30, 0x40, 0x82, 0x1e, 0x64, 0x6f, 0x6d,
-		0x31, 0x2e, 0x61, 0x63, 0x6d, 0x65, 0x74, 0x6f, 0x6f, 0x6c, 0x2d, 0x74,
-		0x65, 0x73, 0x74, 0x2e, 0x64, 0x65, 0x76, 0x65, 0x76, 0x65, 0x72, 0x2e,
-		0x6e, 0x65, 0x74, 0x82, 0x1e, 0x64, 0x6f, 0x6d, 0x32, 0x2e, 0x61, 0x63,
-		0x6d, 0x65, 0x74, 0x6f, 0x6f, 0x6c, 0x2d, 0x74, 0x65, 0x73, 0x74, 0x2e,
-		0x64, 0x65, 0x76, 0x65, 0x76, 0x65, 0x72, 0x2e, 0x6e, 0x65, 0x74, 0x30,
-		0x27, 0x06, 0x03, 0x55, 0x1d, 0x1f, 0x04, 0x20, 0x30, 0x1e, 0x30, 0x1c,
-		0xa0, 0x1a, 0xa0, 0x18, 0x86, 0x16, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f,
-		0x2f, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6d,
-		0x2f, 0x63, 0x72, 0x6c, 0x30, 0x61, 0x06, 0x03, 0x55, 0x1d, 0x20, 0x04,
-		0x5a, 0x30, 0x58, 0x30, 0x08, 0x06, 0x06, 0x67, 0x81, 0x0c, 0x01, 0x02,
-		0x01, 0x30, 0x4c, 0x06, 0x03, 0x2a, 0x03, 0x04, 0x30, 0x45, 0x30, 0x22,
-		0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x01, 0x16, 0x16,
-		0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x65, 0x78, 0x61, 0x6d, 0x70,
-		0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x70, 0x73, 0x30, 0x1f,
-		0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x02, 0x30, 0x13,
-		0x0c, 0x11, 0x44, 0x6f, 0x20, 0x57, 0x68, 0x61, 0x74, 0x20, 0x54, 0x68,
-		0x6f, 0x75, 0x20, 0x57, 0x69, 0x6c, 0x74, 0x30, 0x0d, 0x06, 0x09, 0x2a,
-		0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x03, 0x82,
-		0x01, 0x01, 0x00, 0x86, 0x97, 0x21, 0x05, 0x6d, 0x64, 0xfb, 0xe2, 0xeb,
-		0x6f, 0x26, 0x82, 0x1b, 0x46, 0x3c, 0x76, 0x92, 0x58, 0xd3, 0x54, 0xc3,
-		0x84, 0xac, 0x4d, 0xa0, 0xca, 0xc4, 0x19, 0x37, 0x7b, 0x50, 0x7d, 0x05,
-		0xec, 0x0a, 0xfe, 0x90, 0x13, 0xce, 0x71, 0xfd, 0x20, 0x82, 0x5b, 0xd7,
-		0xea, 0x07, 0x19, 0xcd, 0xc2, 0x64, 0x20, 0xb4, 0x13, 0x6c, 0x17, 0x2d,
-		0xe4, 0xbb, 0xea, 0xb5, 0xaf, 0xa3, 0xfc, 0x93, 0x24, 0xb1, 0xe0, 0x28,
-		0x00, 0x5a, 0xf7, 0xd4, 0x65, 0x8f, 0xed, 0x27, 0x5e, 0x3a, 0xc9, 0xa2,
-		0xb7, 0x1c, 0xd6, 0x99, 0xb2, 0xfe, 0x32, 0x6d, 0xb9, 0xea, 0x3a, 0x97,
-		0x3d, 0x87, 0xb0, 0x52, 0x22, 0xb5, 0x93, 0xd1, 0xe9, 0x98, 0xf4, 0xfd,
-		0x09, 0xa8, 0xd2, 0xe9, 0x3f, 0xdf, 0xd9, 0x0d, 0x11, 0xbd, 0x14, 0x20,
-		0x44, 0x3e, 0x1e, 0xd8, 0x1e, 0xb5, 0x91, 0x34, 0x4c, 0xb7, 0x7b, 0x78,
-		0xa7, 0xbb, 0xb4, 0xff, 0x01, 0x79, 0x3c, 0x3c, 0xec, 0x8f, 0xca, 0x02,
-		0xd0, 0x3f, 0xf2, 0x51, 0x20, 0x54, 0xee, 0x27, 0x16, 0x1c, 0xf9, 0x33,
-		0xb8, 0xa8, 0x70, 0xfb, 0x38, 0xd8, 0x64, 0xfa, 0x15, 0x77, 0x21, 0x1e,
-		0xd0, 0x2a, 0x0b, 0x32, 0xd4, 0xec, 0x90, 0xf6, 0x68, 0xa1, 0x96, 0xf2,
-		0x33, 0xe9, 0xe0, 0x17, 0x28, 0x37, 0x06, 0x8c, 0xb5, 0x47, 0x8a, 0x71,
-		0xfe, 0x69, 0x9d, 0x57, 0x57, 0xdd, 0xb3, 0x99, 0xc7, 0x75, 0x9f, 0x91,
-		0xea, 0x0d, 0xaa, 0x7b, 0xb1, 0x53, 0xec, 0xb0, 0x7c, 0x29, 0x45, 0x6c,
-		0x50, 0xc1, 0x32, 0x09, 0x48, 0x83, 0x23, 0x37, 0xae, 0xd5, 0x62, 0xe7,
-		0xbd, 0x66, 0xbf, 0xc5, 0x57, 0xf0, 0x05, 0xb2, 0xaf, 0x80, 0xc8, 0xe7,
-		0x1e, 0xcd, 0xf5, 0xa8, 0xe0, 0xdb, 0xb1, 0x2c, 0xd1, 0x46, 0x93, 0x60,
-		0x5f, 0x43, 0x56, 0x13, 0x5e, 0x23, 0x7b,
-	},
-	{
-		0x30, 0x82, 0x04, 0x8a, 0x30, 0x82, 0x03, 0x72, 0xa0, 0x03, 0x02, 0x01,
-		0x02, 0x02, 0x02, 0x12, 0x4d, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,
-		0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x30, 0x2b, 0x31, 0x29,
-		0x30, 0x27, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x20, 0x63, 0x61, 0x63,
-		0x6b, 0x6c, 0x69, 0x6e, 0x67, 0x20, 0x63, 0x72, 0x79, 0x70, 0x74, 0x6f,
-		0x67, 0x72, 0x61, 0x70, 0x68, 0x65, 0x72, 0x20, 0x66, 0x61, 0x6b, 0x65,
-		0x20, 0x52, 0x4f, 0x4f, 0x54, 0x30, 0x1e, 0x17, 0x0d, 0x31, 0x35, 0x31,
-		0x30, 0x32, 0x31, 0x32, 0x30, 0x31, 0x31, 0x35, 0x32, 0x5a, 0x17, 0x0d,
-		0x32, 0x30, 0x31, 0x30, 0x31, 0x39, 0x32, 0x30, 0x31, 0x31, 0x35, 0x32,
-		0x5a, 0x30, 0x1f, 0x31, 0x1d, 0x30, 0x1b, 0x06, 0x03, 0x55, 0x04, 0x03,
-		0x13, 0x14, 0x68, 0x61, 0x70, 0x70, 0x79, 0x20, 0x68, 0x61, 0x63, 0x6b,
-		0x65, 0x72, 0x20, 0x66, 0x61, 0x6b, 0x65, 0x20, 0x43, 0x41, 0x30, 0x82,
-		0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,
-		0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82,
-		0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xc2, 0x0a, 0x47, 0x79, 0x9a,
-		0x05, 0xc5, 0x12, 0xb2, 0x77, 0x17, 0x63, 0x34, 0x13, 0xd7, 0x70, 0xf9,
-		0x36, 0xbf, 0x99, 0xde, 0x62, 0xf1, 0x30, 0xc8, 0x77, 0x4d, 0x47, 0x6d,
-		0xea, 0xc0, 0x02, 0x9a, 0xa6, 0xc9, 0xd1, 0xbb, 0x51, 0x96, 0x05, 0xdf,
-		0x32, 0xd3, 0x4b, 0x33, 0x63, 0x94, 0xd4, 0x8e, 0x9a, 0xdc, 0x9b, 0xbe,
-		0xb4, 0x86, 0x52, 0x76, 0x7d, 0xaf, 0xdb, 0x52, 0x41, 0xc2, 0xfc, 0x54,
-		0xce, 0x96, 0x50, 0xe3, 0x3c, 0xb6, 0x72, 0x29, 0x88, 0x88, 0xc4, 0x03,
-		0x64, 0x24, 0x07, 0x27, 0x0c, 0xc2, 0xf4, 0x66, 0x67, 0xf0, 0x76, 0x96,
-		0xd3, 0xdd, 0x62, 0xcf, 0xd1, 0xf4, 0x1a, 0x8d, 0xc0, 0xed, 0x60, 0xd7,
-		0xc1, 0x83, 0x66, 0xb1, 0xd2, 0xcd, 0x46, 0x2d, 0x34, 0xa3, 0x5e, 0x14,
-		0x8e, 0x86, 0x95, 0xa9, 0xa3, 0xec, 0x62, 0xb6, 0x56, 0xbd, 0x12, 0x9a,
-		0x21, 0x1a, 0x9a, 0x53, 0x48, 0x47, 0x99, 0x2d, 0x00, 0x5b, 0x04, 0x12,
-		0xbc, 0xdf, 0xfd, 0xde, 0x23, 0x08, 0x5e, 0xec, 0xa2, 0xc3, 0x2c, 0x26,
-		0x93, 0x02, 0x9b, 0x5a, 0x79, 0xf1, 0x09, 0x0f, 0xe0, 0xb1, 0xcb, 0x4a,
-		0x15, 0x4b, 0x5c, 0x36, 0xbc, 0x04, 0xc7, 0xd5, 0xa0, 0x8f, 0xa2, 0xa5,
-		0x87, 0x00, 0xd3, 0xc8, 0x8d, 0x50, 0x59, 0x20, 0x5b, 0xc5, 0x56, 0x0d,
-		0xc9, 0x48, 0x0f, 0x17, 0x32, 0xb1, 0xad, 0x29, 0xb0, 0x30, 0xed, 0x32,
-		0x35, 0xf7, 0xfb, 0x86, 0x8f, 0x90, 0x4f, 0xdc, 0x79, 0xf9, 0x8f, 0xfb,
-		0x5c, 0x4e, 0x7d, 0x4b, 0x83, 0x1c, 0xe1, 0x95, 0xf1, 0x71, 0x72, 0x9e,
-		0xc3, 0xf8, 0x12, 0x94, 0xdf, 0x54, 0xe6, 0x6b, 0xd3, 0xf8, 0x3d, 0x81,
-		0x84, 0x3b, 0x64, 0x0a, 0xea, 0x5d, 0x7e, 0xc6, 0x4d, 0x09, 0x05, 0xa9,
-		0xdb, 0xb0, 0x3e, 0x6f, 0xf0, 0xe6, 0xac, 0x52, 0x3d, 0x36, 0xab, 0x02,
-		0x03, 0x01, 0x00, 0x01, 0xa3, 0x82, 0x01, 0xc2, 0x30, 0x82, 0x01, 0xbe,
-		0x30, 0x12, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x01, 0x01, 0xff, 0x04, 0x08,
-		0x30, 0x06, 0x01, 0x01, 0xff, 0x02, 0x01, 0x00, 0x30, 0x43, 0x06, 0x03,
-		0x55, 0x1d, 0x1e, 0x04, 0x3c, 0x30, 0x3a, 0xa1, 0x38, 0x30, 0x06, 0x82,
-		0x04, 0x2e, 0x6d, 0x69, 0x6c, 0x30, 0x0a, 0x87, 0x08, 0x00, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x22, 0x87, 0x20, 0x00, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x1d, 0x0f,
-		0x01, 0x01, 0xff, 0x04, 0x04, 0x03, 0x02, 0x01, 0x86, 0x30, 0x7f, 0x06,
-		0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x73, 0x30,
-		0x71, 0x30, 0x32, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30,
-		0x01, 0x86, 0x26, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x69, 0x73,
-		0x72, 0x67, 0x2e, 0x74, 0x72, 0x75, 0x73, 0x74, 0x69, 0x64, 0x2e, 0x6f,
-		0x63, 0x73, 0x70, 0x2e, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x72, 0x75, 0x73,
-		0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x3b, 0x06, 0x08, 0x2b, 0x06, 0x01,
-		0x05, 0x05, 0x07, 0x30, 0x02, 0x86, 0x2f, 0x68, 0x74, 0x74, 0x70, 0x3a,
-		0x2f, 0x2f, 0x61, 0x70, 0x70, 0x73, 0x2e, 0x69, 0x64, 0x65, 0x6e, 0x74,
-		0x72, 0x75, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x72, 0x6f, 0x6f,
-		0x74, 0x73, 0x2f, 0x64, 0x73, 0x74, 0x72, 0x6f, 0x6f, 0x74, 0x63, 0x61,
-		0x78, 0x33, 0x2e, 0x70, 0x37, 0x63, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d,
-		0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xe9, 0xa4, 0x3f, 0xee, 0x9e,
-		0xa5, 0xe6, 0xf2, 0xd5, 0xd7, 0x79, 0x60, 0x3c, 0x93, 0xa6, 0x2e, 0x24,
-		0x8e, 0x97, 0xaa, 0x30, 0x54, 0x06, 0x03, 0x55, 0x1d, 0x20, 0x04, 0x4d,
-		0x30, 0x4b, 0x30, 0x08, 0x06, 0x06, 0x67, 0x81, 0x0c, 0x01, 0x02, 0x01,
-		0x30, 0x3f, 0x06, 0x0b, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0xdf, 0x13,
-		0x01, 0x01, 0x01, 0x30, 0x30, 0x30, 0x2e, 0x06, 0x08, 0x2b, 0x06, 0x01,
-		0x05, 0x05, 0x07, 0x02, 0x01, 0x16, 0x22, 0x68, 0x74, 0x74, 0x70, 0x3a,
-		0x2f, 0x2f, 0x63, 0x70, 0x73, 0x2e, 0x72, 0x6f, 0x6f, 0x74, 0x2d, 0x78,
-		0x31, 0x2e, 0x6c, 0x65, 0x74, 0x73, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70,
-		0x74, 0x2e, 0x6f, 0x72, 0x67, 0x30, 0x3c, 0x06, 0x03, 0x55, 0x1d, 0x1f,
-		0x04, 0x35, 0x30, 0x33, 0x30, 0x31, 0xa0, 0x2f, 0xa0, 0x2d, 0x86, 0x2b,
-		0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x63, 0x72, 0x6c, 0x2e, 0x69,
-		0x64, 0x65, 0x6e, 0x74, 0x72, 0x75, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x6d,
-		0x2f, 0x44, 0x53, 0x54, 0x52, 0x4f, 0x4f, 0x54, 0x43, 0x41, 0x58, 0x33,
-		0x43, 0x52, 0x4c, 0x2e, 0x63, 0x72, 0x6c, 0x30, 0x1d, 0x06, 0x03, 0x55,
-		0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xfb, 0x78, 0x4f, 0x12, 0xf9, 0x60,
-		0x15, 0x83, 0x2c, 0x9f, 0x17, 0x7f, 0x34, 0x19, 0xb3, 0x2e, 0x36, 0xea,
-		0x41, 0x89, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,
-		0x01, 0x01, 0x0b, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x0d, 0x18,
-		0x01, 0xe2, 0xd7, 0x3a, 0x49, 0x71, 0xe2, 0x18, 0x42, 0x8a, 0x45, 0x14,
-		0x97, 0xe0, 0x5d, 0x9c, 0x57, 0xe7, 0xd6, 0x0d, 0x16, 0xe4, 0x08, 0x90,
-		0x2d, 0x53, 0x48, 0x38, 0xbe, 0x8f, 0x9e, 0xa5, 0xee, 0xd3, 0x08, 0xe7,
-		0x84, 0xdc, 0xa1, 0xa9, 0xdc, 0x27, 0x7e, 0x16, 0x0c, 0x9e, 0x8c, 0xb8,
-		0x89, 0xd4, 0x61, 0xe2, 0x50, 0x7a, 0xa7, 0x3f, 0x06, 0x7f, 0xda, 0x67,
-		0x94, 0xb7, 0x7f, 0x0e, 0x75, 0x92, 0x57, 0x78, 0x12, 0xfb, 0xf2, 0x3f,
-		0x98, 0x09, 0x75, 0x74, 0x29, 0x0a, 0x6f, 0x2e, 0x87, 0xd9, 0x5e, 0xfd,
-		0xd1, 0xee, 0x88, 0x1e, 0x62, 0x0a, 0xd8, 0xa6, 0x26, 0xde, 0x39, 0xbe,
-		0x53, 0xef, 0x85, 0x21, 0xd1, 0xa9, 0x05, 0xdb, 0x10, 0x4d, 0x27, 0x66,
-		0x89, 0x7f, 0xeb, 0x03, 0x2b, 0xb1, 0x30, 0x33, 0x34, 0x69, 0xd3, 0x24,
-		0x34, 0x1c, 0x13, 0x7d, 0x09, 0x99, 0x40, 0x2c, 0xfa, 0x9c, 0x61, 0xf0,
-		0xd5, 0x07, 0x12, 0x3d, 0x93, 0x2f, 0x66, 0x9b, 0x02, 0xf1, 0x29, 0x2f,
-		0x7a, 0x4c, 0xf1, 0xb2, 0x31, 0x75, 0xa2, 0xd3, 0xab, 0x31, 0x43, 0xcd,
-		0x3d, 0x0b, 0xed, 0x4d, 0x6a, 0xd5, 0xc7, 0xc1, 0xa5, 0x47, 0x6a, 0x9f,
-		0xc7, 0xfe, 0x31, 0x6d, 0x06, 0xb5, 0xbf, 0x67, 0xeb, 0x36, 0xf1, 0x41,
-		0x0a, 0x63, 0xb9, 0xf6, 0x0a, 0x33, 0xfa, 0x39, 0xd6, 0xbd, 0xf4, 0xed,
-		0x8f, 0x63, 0x63, 0xc0, 0x36, 0x7b, 0xbe, 0x53, 0x01, 0xb0, 0xf9, 0xb5,
-		0xe9, 0xd6, 0xca, 0x60, 0x2f, 0x38, 0xd2, 0xeb, 0xd1, 0xa1, 0x98, 0xf1,
-		0xaa, 0xc7, 0x5c, 0xdc, 0x28, 0x42, 0x66, 0x3a, 0xa2, 0x98, 0x5a, 0xa5,
-		0x34, 0x6f, 0xf1, 0xa0, 0xf0, 0x3c, 0xf9, 0xd4, 0xe2, 0x71, 0x9c, 0xc2,
-		0x5c, 0x4f, 0x62, 0x8c, 0xf2, 0x1c, 0xbd, 0x6e, 0xb2, 0xd5, 0xa6, 0xb7,
-		0x6c, 0x6c,
-	},
-}
-
-func TestLoadCertificates(t *testing.T) {
-	b, err := LoadCertificates([]byte(testCerts))
-	if err != nil {
-		t.Fatalf("cannot load certificates")
-	}
-
-	if !reflect.DeepEqual(b, testCertsDER) {
-		t.Fatalf("certificate load mismatch")
-	}
-}
-
-const testKey = `-----BEGIN RSA PRIVATE KEY-----
-MIIEowIBAAKCAQEAwpBqfaZxkAhaq7snn/qf4pDnbX5WWwkR7fXz2Esl/NNvGkPF
-qD8OImjbFyXiNl4QCSsVHglnGzr3eWH3ZidtJ9bBnQi+MRQ05gkaz0vn3AANO7vA
-SgzbEBZZJSHznOIrCls/8kTuLUPj4yWWX/ERx9vOlth2UYo0PvrAAbJqknijN1ev
-YGO2nisSIwaPI5+Bu6t7HbQXK/UDjRTB1op3Kmea0TJch0/7792PjJYZfeuzPI7V
-6sbOwIieD0QOE+t4vdzu5lWdkmuuVQ9LuY8nM9+NRmEJYr0FCeIChIeJmIHSUAHZ
-NQ1TiBqoaCPhMO/Uo9qmo/Wyl1whYaoD7jSPvQIDAQABAoIBAH69WlE9Ui6T8pR5
-lsdUmEAbSlX9/TzR/Lb5B332/ejixjXivefqI0fw6/75M5Fc1q9SPDBTybFoSPru
-AR2vQyC3eWnU3yfTVN4gQjGU7ZVXB0fI9uqF01F4bVuN8UZZ4dWeOVqU4l3kIpe9
-zWX0ADQjkECdAv38vCnmZ5rzYQ7FmPoZse8fC7TqJIqvMN2lkBQd/7ecfSGiDsxS
-jdV/a2gE+AuS1d06yfLiu8UuRYe7le1VEx84NHBAQv71IG1kc+9bKWqOlXPXvS7o
-WQi976wETxbqEbZLtQlHhX7ND/Svof+O/IwbfHcfz1qhMGZ8wP4CeuLQGXpVqSpc
-PWTR/bUCgYEAy6zdOmvpj/Ss6o2oHWqXek6PKWVmnE13NZ45GrWaBT8tG9znJRoG
-qA3Cj5BedJSzCEfrVZ4Yi29PrRl7HbHYEcIiJZ1rwdmPmlRK/VWgk8RpBAzT/ilS
-90jTXBPlA/WvzMgwtO0hJEbnpvH5EB2WviyNWgvRhwdzPWqJVEy/S3MCgYEA9IxW
-2VU1Rnx1mcudl0Y68pcLU25pXA7VsA5IsyCk1a5rwecgRDF3dVJ1lJGp8+Xf4/Wo
-eDhqk1tdTAp0Uy+GfJcTkrAJZO1jeYoJj6Hy4QT50xPNMQZHZ0uOkIbLfHHcXJHa
-9qcEIzKpcPiq5cD0PYqJQO3f3gw5V/aLKCTDTA8CgYAYQmi/UqcpLF2EOocxqcaN
-HNpUde145Ik0a7olgkfsJBA9Z1xowObWEX2BGBMIE8YXUGmpcwE9am61EXnmmY5A
-3zyt+kgheMZv/WZJMm/D6fsQLm75sPZe2d/C8eOvSw47eATFKBFwfrmM2vltf/i6
-ghf8B7hXOv3w7MWasuF+HQKBgEixQsu9uWVnb6m0zfZ+qN0dqv807dqwijKYPGIK
-zRS7kUqFQqEityjHxy3Pkt5uMXxYtKhv1LZSzUviO6vSj76PRgEvlMtMiWpCbw8k
-C8d5rC1jUHZHMIhy/EDX4LrwOZnGvXjeMqunzphHQr2i+rckbCJB02704ULVhY38
-R5VfAoGBAISqeTh28iF9SirK18xpsW6c6j+x6qfjs8Rr6pPAnO1vovUCH6vlxV4I
-RLeWOCS9ROFhbef4WqWpa82vGd0OxoUBirPRWRFyt0pgH9qAmwqD2YN8KFCyPztD
-xtiaTxLKSHYuEVxbJZJmDNkjDEtGk7hVzOQ0+GO+Tvknkp/kkHsn
------END RSA PRIVATE KEY-----`
-
-const testKeyPKCS8 = `-----BEGIN PRIVATE KEY-----
-MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDCkGp9pnGQCFqr
-uyef+p/ikOdtflZbCRHt9fPYSyX8028aQ8WoPw4iaNsXJeI2XhAJKxUeCWcbOvd5
-YfdmJ20n1sGdCL4xFDTmCRrPS+fcAA07u8BKDNsQFlklIfOc4isKWz/yRO4tQ+Pj
-JZZf8RHH286W2HZRijQ++sABsmqSeKM3V69gY7aeKxIjBo8jn4G7q3sdtBcr9QON
-FMHWincqZ5rRMlyHT/vv3Y+Mlhl967M8jtXqxs7AiJ4PRA4T63i93O7mVZ2Sa65V
-D0u5jycz341GYQlivQUJ4gKEh4mYgdJQAdk1DVOIGqhoI+Ew79Sj2qaj9bKXXCFh
-qgPuNI+9AgMBAAECggEAfr1aUT1SLpPylHmWx1SYQBtKVf39PNH8tvkHffb96OLG
-NeK95+ojR/Dr/vkzkVzWr1I8MFPJsWhI+u4BHa9DILd5adTfJ9NU3iBCMZTtlVcH
-R8j26oXTUXhtW43xRlnh1Z45WpTiXeQil73NZfQANCOQQJ0C/fy8KeZnmvNhDsWY
-+hmx7x8LtOokiq8w3aWQFB3/t5x9IaIOzFKN1X9raAT4C5LV3TrJ8uK7xS5Fh7uV
-7VUTHzg0cEBC/vUgbWRz71spao6Vc9e9LuhZCL3vrARPFuoRtku1CUeFfs0P9K+h
-/478jBt8dx/PWqEwZnzA/gJ64tAZelWpKlw9ZNH9tQKBgQDLrN06a+mP9Kzqjagd
-apd6To8pZWacTXc1njkatZoFPy0b3OclGgaoDcKPkF50lLMIR+tVnhiLb0+tGXsd
-sdgRwiIlnWvB2Y+aVEr9VaCTxGkEDNP+KVL3SNNcE+UD9a/MyDC07SEkRuem8fkQ
-HZa+LI1aC9GHB3M9aolUTL9LcwKBgQD0jFbZVTVGfHWZy52XRjrylwtTbmlcDtWw
-DkizIKTVrmvB5yBEMXd1UnWUkanz5d/j9ah4OGqTW11MCnRTL4Z8lxOSsAlk7WN5
-igmPofLhBPnTE80xBkdnS46Qhst8cdxckdr2pwQjMqlw+KrlwPQ9iolA7d/eDDlX
-9osoJMNMDwKBgBhCaL9SpyksXYQ6hzGpxo0c2lR17XjkiTRruiWCR+wkED1nXGjA
-5tYRfYEYEwgTxhdQaalzAT1qbrUReeaZjkDfPK36SCF4xm/9Zkkyb8Pp+xAubvmw
-9l7Z38Lx469LDjt4BMUoEXB+uYza+W1/+LqCF/wHuFc6/fDsxZqy4X4dAoGASLFC
-y725ZWdvqbTN9n6o3R2q/zTt2rCKMpg8YgrNFLuRSoVCoSK3KMfHLc+S3m4xfFi0
-qG/UtlLNS+I7q9KPvo9GAS+Uy0yJakJvDyQLx3msLWNQdkcwiHL8QNfguvA5mca9
-eN4yq6fOmEdCvaL6tyRsIkHTbvThQtWFjfxHlV8CgYEAhKp5OHbyIX1KKsrXzGmx
-bpzqP7Hqp+OzxGvqk8Cc7W+i9QIfq+XFXghEt5Y4JL1E4WFt5/hapalrza8Z3Q7G
-hQGKs9FZEXK3SmAf2oCbCoPZg3woULI/O0PG2JpPEspIdi4RXFslkmYM2SMMS0aT
-uFXM5DT4Y75O+SeSn+SQeyc=
------END PRIVATE KEY-----`
-
-var testKeyN, _ = big.NewInt(0).SetString("00c2906a7da67190085aabbb279ffa9fe290e76d7e565b0911edf5f3d84b25fcd36f1a43c5a83f0e2268db1725e2365e10092b151e09671b3af77961f766276d27d6c19d08be311434e6091acf4be7dc000d3bbbc04a0cdb1016592521f39ce22b0a5b3ff244ee2d43e3e325965ff111c7dbce96d876518a343efac001b26a9278a33757af6063b69e2b1223068f239f81bbab7b1db4172bf5038d14c1d68a772a679ad1325c874ffbefdd8f8c96197debb33c8ed5eac6cec0889e0f440e13eb78bddceee6559d926bae550f4bb98f2733df8d46610962bd0509e2028487899881d25001d9350d53881aa86823e130efd4a3daa6a3f5b2975c2161aa03ee348fbd", 16)
-
-var testKeyD, _ = big.NewInt(0).SetString("7ebd5a513d522e93f2947996c75498401b4a55fdfd3cd1fcb6f9077df6fde8e2c635e2bde7ea2347f0ebfef933915cd6af523c3053c9b16848faee011daf4320b77969d4df27d354de20423194ed95570747c8f6ea85d351786d5b8df14659e1d59e395a94e25de42297bdcd65f400342390409d02fdfcbc29e6679af3610ec598fa19b1ef1f0bb4ea248aaf30dda590141dffb79c7d21a20ecc528dd57f6b6804f80b92d5dd3ac9f2e2bbc52e4587bb95ed55131f3834704042fef5206d6473ef5b296a8e9573d7bd2ee85908bdefac044f16ea11b64bb50947857ecd0ff4afa1ff8efc8c1b7c771fcf5aa130667cc0fe027ae2d0197a55a92a5c3d64d1fdb5", 16)
-
-var testKeyPrime1, _ = big.NewInt(0).SetString("00cbacdd3a6be98ff4acea8da81d6a977a4e8f2965669c4d77359e391ab59a053f2d1bdce7251a06a80dc28f905e7494b30847eb559e188b6f4fad197b1db1d811c222259d6bc1d98f9a544afd55a093c469040cd3fe2952f748d35c13e503f5afccc830b4ed212446e7a6f1f9101d96be2c8d5a0bd18707733d6a89544cbf4b73", 16)
-
-var testKeyPrime2, _ = big.NewInt(0).
-	SetString("00f48c56d95535467c7599cb9d97463af2970b536e695c0ed5b00e48b320a4d5ae6bc1e7204431777552759491a9f3e5dfe3f5a878386a935b5d4c0a74532f867c971392b00964ed63798a098fa1f2e104f9d313cd310647674b8e9086cb7c71dc5c91daf6a7042332a970f8aae5c0f43d8a8940eddfde0c3957f68b2824c34c0f", 16)
-
-var testKeyDp, _ = big.NewInt(0).SetString("184268bf52a7292c5d843a8731a9c68d1cda5475ed78e489346bba258247ec24103d675c68c0e6d6117d8118130813c6175069a973013d6a6eb51179e6998e40df3cadfa482178c66ffd6649326fc3e9fb102e6ef9b0f65ed9dfc2f1e3af4b0e3b7804c52811707eb98cdaf96d7ff8ba8217fc07b8573afdf0ecc59ab2e17e1d", 16)
-
-var testKeyDq, _ = big.NewInt(0).SetString("48b142cbbdb965676fa9b4cdf67ea8dd1daaff34eddab08a32983c620acd14bb914a8542a122b728c7c72dcf92de6e317c58b4a86fd4b652cd4be23babd28fbe8f46012f94cb4c896a426f0f240bc779ac2d63507647308872fc40d7e0baf03999c6bd78de32aba7ce984742bda2fab7246c2241d36ef4e142d5858dfc47955f", 16)
-
-var testKeyQinv, _ = big.NewInt(0).SetString("0084aa793876f2217d4a2acad7cc69b16e9cea3fb1eaa7e3b3c46bea93c09ced6fa2f5021fabe5c55e0844b7963824bd44e1616de7f85aa5a96bcdaf19dd0ec685018ab3d1591172b74a601fda809b0a83d9837c2850b23f3b43c6d89a4f12ca48762e115c5b2592660cd9230c4b4693b855cce434f863be4ef927929fe4907b27", 16)
-
-var testKeyValue = &rsa.PrivateKey{
-	PublicKey: rsa.PublicKey{
-		N: testKeyN,
-		E: 0x10001,
-	},
-	D: testKeyD,
-	Primes: []*big.Int{
-		testKeyPrime1, testKeyPrime2,
-	},
-	Precomputed: rsa.PrecomputedValues{
-		Dp:        testKeyDp,
-		Dq:        testKeyDq,
-		Qinv:      testKeyQinv,
-		CRTValues: []rsa.CRTValue{},
-	},
-}
-
-const testECKey = `-----BEGIN EC PRIVATE KEY-----
-MHcCAQEEIABVf3JmY6Fs0MpQwXlUCw0T27BO+hjjr93v/nLT9PrZoAoGCCqGSM49
-AwEHoUQDQgAEkDk1q0XGYa6flpAaBVHEI5UStWvdewAHpIbN+PpOlKNgeK1Xu0nw
-Pv7jwLK+95tYBYbVu1gUnQ+OjWpxyuITaA==
------END EC PRIVATE KEY-----`
-
-const testECKeyPKCS8 = `-----BEGIN PRIVATE KEY-----
-MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgAFV/cmZjoWzQylDB
-eVQLDRPbsE76GOOv3e/+ctP0+tmhRANCAASQOTWrRcZhrp+WkBoFUcQjlRK1a917
-AAekhs34+k6Uo2B4rVe7SfA+/uPAsr73m1gFhtW7WBSdD46NanHK4hNo
------END PRIVATE KEY-----`
-
-var testECKeyX, _ = big.NewInt(0).SetString("903935ab45c661ae9f96901a0551c4239512b56bdd7b0007a486cdf8fa4e94a3", 16)
-var testECKeyY, _ = big.NewInt(0).SetString("6078ad57bb49f03efee3c0b2bef79b580586d5bb58149d0f8e8d6a71cae21368", 16)
-var testECKeyD, _ = big.NewInt(0).SetString("557f726663a16cd0ca50c179540b0d13dbb04efa18e3afddeffe72d3f4fad9", 16)
-
-var testECKeyValue = &ecdsa.PrivateKey{
-	PublicKey: ecdsa.PublicKey{
-		Curve: elliptic.P256(),
-		X:     testECKeyX,
-		Y:     testECKeyY,
-	},
-	D: testECKeyD,
-}
-
-func TestLoadKey(t *testing.T) {
-	pk, err := LoadPrivateKey([]byte(testKey))
-	if err != nil {
-		t.Fatalf("failed to load private key: %v", err)
-	}
-
-	if !reflect.DeepEqual(testKeyValue, pk) {
-		t.Fatalf("key mismatch: %#v %#v", testKeyValue, pk)
-	}
-
-	pk2, err := LoadPrivateKey([]byte(testKeyPKCS8))
-	if err != nil {
-		t.Fatalf("failed to load private key: %v", err)
-	}
-
-	if !reflect.DeepEqual(testKeyValue, pk2) {
-		t.Fatalf("key mismatch: %#v %#v", testKeyValue, pk2)
-	}
-
-	epk, err := LoadPrivateKey([]byte(testECKey))
-	if err != nil {
-		t.Fatalf("failed to load EC private key: %v", err)
-	}
-
-	if !reflect.DeepEqual(epk, testECKeyValue) {
-		t.Fatalf("EC key mismatch: %#v %#v", epk, testECKeyValue)
-	}
-
-	epk2, err := LoadPrivateKey([]byte(testECKeyPKCS8))
-	if err != nil {
-		t.Fatalf("failed to load EC private key: %v", err)
-	}
-
-	if !reflect.DeepEqual(epk2, testECKeyValue) {
-		t.Fatalf("EC key mismatch: %#v %#v", epk2, testECKeyValue)
-	}
-
-	b := bytes.Buffer{}
-	err = SavePrivateKey(&b, pk)
-	if err != nil {
-		t.Fatalf("%v", err)
-	}
-	pkc, err := LoadPrivateKey(b.Bytes())
-	if err != nil {
-		t.Fatalf("%v", err)
-	}
-	if !reflect.DeepEqual(pk, pkc) {
-		t.Fatalf("mismatch after save-load")
-	}
-
-	b = bytes.Buffer{}
-	err = SavePrivateKey(&b, epk)
-	if err != nil {
-		t.Fatalf("%v", err)
-	}
-	epkc, err := LoadPrivateKey(b.Bytes())
-	if err != nil {
-		t.Fatalf("%v", err)
-	}
-	if !reflect.DeepEqual(epk, epkc) {
-		t.Fatalf("mismatch after save-load")
-	}
-}
-
-const testCSR = `-----BEGIN CERTIFICATE REQUEST-----
-MIICWzCCAUMCAQAwFjEUMBIGA1UEAwwLZXhhbXBsZS5jb20wggEiMA0GCSqGSIb3
-DQEBAQUAA4IBDwAwggEKAoIBAQDCkGp9pnGQCFqruyef+p/ikOdtflZbCRHt9fPY
-SyX8028aQ8WoPw4iaNsXJeI2XhAJKxUeCWcbOvd5YfdmJ20n1sGdCL4xFDTmCRrP
-S+fcAA07u8BKDNsQFlklIfOc4isKWz/yRO4tQ+PjJZZf8RHH286W2HZRijQ++sAB
-smqSeKM3V69gY7aeKxIjBo8jn4G7q3sdtBcr9QONFMHWincqZ5rRMlyHT/vv3Y+M
-lhl967M8jtXqxs7AiJ4PRA4T63i93O7mVZ2Sa65VD0u5jycz341GYQlivQUJ4gKE
-h4mYgdJQAdk1DVOIGqhoI+Ew79Sj2qaj9bKXXCFhqgPuNI+9AgMBAAGgADANBgkq
-hkiG9w0BAQsFAAOCAQEAGwrSUMmte+rXVUVsYS7cqN0xJFOc18vuMDUezAsAw8Ye
-UDhivw2wsPTlPBl3zpVavlGSM5ZPWgv4osZtDeS/VeL+ow/7wVShlc2rbyuXTwoq
-Lh4+Oe4svEEfGwvia5Ui4XA2eFFLSaTVM+FWGZNUXoB++bS831ro2fffoI3jrjDz
-0edY1zhsjaV9Fej9k37O/1GhkRfTq0WMAnX/VP6L/2Gjs2ZwvAwCItUpCwPw1B3Q
-h+/TTT56DupPyRFI1ZmbpX6Rp/A0gL+ykqpjASJj1ai+jkBXiDz/I4LJ2oUhtOxJ
-vGQkX0wJF929X+IQlURO6rP5ET9tzmF4S9/F/RA1kw==
------END CERTIFICATE REQUEST-----`
-
-var testCSRDER = []byte{
-	0x30, 0x82, 0x02, 0x5b, 0x30, 0x82, 0x01, 0x43, 0x02, 0x01, 0x00, 0x30,
-	0x16, 0x31, 0x14, 0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x0b,
-	0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x30,
-	0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,
-	0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30,
-	0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xc2, 0x90, 0x6a, 0x7d,
-	0xa6, 0x71, 0x90, 0x08, 0x5a, 0xab, 0xbb, 0x27, 0x9f, 0xfa, 0x9f, 0xe2,
-	0x90, 0xe7, 0x6d, 0x7e, 0x56, 0x5b, 0x09, 0x11, 0xed, 0xf5, 0xf3, 0xd8,
-	0x4b, 0x25, 0xfc, 0xd3, 0x6f, 0x1a, 0x43, 0xc5, 0xa8, 0x3f, 0x0e, 0x22,
-	0x68, 0xdb, 0x17, 0x25, 0xe2, 0x36, 0x5e, 0x10, 0x09, 0x2b, 0x15, 0x1e,
-	0x09, 0x67, 0x1b, 0x3a, 0xf7, 0x79, 0x61, 0xf7, 0x66, 0x27, 0x6d, 0x27,
-	0xd6, 0xc1, 0x9d, 0x08, 0xbe, 0x31, 0x14, 0x34, 0xe6, 0x09, 0x1a, 0xcf,
-	0x4b, 0xe7, 0xdc, 0x00, 0x0d, 0x3b, 0xbb, 0xc0, 0x4a, 0x0c, 0xdb, 0x10,
-	0x16, 0x59, 0x25, 0x21, 0xf3, 0x9c, 0xe2, 0x2b, 0x0a, 0x5b, 0x3f, 0xf2,
-	0x44, 0xee, 0x2d, 0x43, 0xe3, 0xe3, 0x25, 0x96, 0x5f, 0xf1, 0x11, 0xc7,
-	0xdb, 0xce, 0x96, 0xd8, 0x76, 0x51, 0x8a, 0x34, 0x3e, 0xfa, 0xc0, 0x01,
-	0xb2, 0x6a, 0x92, 0x78, 0xa3, 0x37, 0x57, 0xaf, 0x60, 0x63, 0xb6, 0x9e,
-	0x2b, 0x12, 0x23, 0x06, 0x8f, 0x23, 0x9f, 0x81, 0xbb, 0xab, 0x7b, 0x1d,
-	0xb4, 0x17, 0x2b, 0xf5, 0x03, 0x8d, 0x14, 0xc1, 0xd6, 0x8a, 0x77, 0x2a,
-	0x67, 0x9a, 0xd1, 0x32, 0x5c, 0x87, 0x4f, 0xfb, 0xef, 0xdd, 0x8f, 0x8c,
-	0x96, 0x19, 0x7d, 0xeb, 0xb3, 0x3c, 0x8e, 0xd5, 0xea, 0xc6, 0xce, 0xc0,
-	0x88, 0x9e, 0x0f, 0x44, 0x0e, 0x13, 0xeb, 0x78, 0xbd, 0xdc, 0xee, 0xe6,
-	0x55, 0x9d, 0x92, 0x6b, 0xae, 0x55, 0x0f, 0x4b, 0xb9, 0x8f, 0x27, 0x33,
-	0xdf, 0x8d, 0x46, 0x61, 0x09, 0x62, 0xbd, 0x05, 0x09, 0xe2, 0x02, 0x84,
-	0x87, 0x89, 0x98, 0x81, 0xd2, 0x50, 0x01, 0xd9, 0x35, 0x0d, 0x53, 0x88,
-	0x1a, 0xa8, 0x68, 0x23, 0xe1, 0x30, 0xef, 0xd4, 0xa3, 0xda, 0xa6, 0xa3,
-	0xf5, 0xb2, 0x97, 0x5c, 0x21, 0x61, 0xaa, 0x03, 0xee, 0x34, 0x8f, 0xbd,
-	0x02, 0x03, 0x01, 0x00, 0x01, 0xa0, 0x00, 0x30, 0x0d, 0x06, 0x09, 0x2a,
-	0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x03, 0x82,
-	0x01, 0x01, 0x00, 0x1b, 0x0a, 0xd2, 0x50, 0xc9, 0xad, 0x7b, 0xea, 0xd7,
-	0x55, 0x45, 0x6c, 0x61, 0x2e, 0xdc, 0xa8, 0xdd, 0x31, 0x24, 0x53, 0x9c,
-	0xd7, 0xcb, 0xee, 0x30, 0x35, 0x1e, 0xcc, 0x0b, 0x00, 0xc3, 0xc6, 0x1e,
-	0x50, 0x38, 0x62, 0xbf, 0x0d, 0xb0, 0xb0, 0xf4, 0xe5, 0x3c, 0x19, 0x77,
-	0xce, 0x95, 0x5a, 0xbe, 0x51, 0x92, 0x33, 0x96, 0x4f, 0x5a, 0x0b, 0xf8,
-	0xa2, 0xc6, 0x6d, 0x0d, 0xe4, 0xbf, 0x55, 0xe2, 0xfe, 0xa3, 0x0f, 0xfb,
-	0xc1, 0x54, 0xa1, 0x95, 0xcd, 0xab, 0x6f, 0x2b, 0x97, 0x4f, 0x0a, 0x2a,
-	0x2e, 0x1e, 0x3e, 0x39, 0xee, 0x2c, 0xbc, 0x41, 0x1f, 0x1b, 0x0b, 0xe2,
-	0x6b, 0x95, 0x22, 0xe1, 0x70, 0x36, 0x78, 0x51, 0x4b, 0x49, 0xa4, 0xd5,
-	0x33, 0xe1, 0x56, 0x19, 0x93, 0x54, 0x5e, 0x80, 0x7e, 0xf9, 0xb4, 0xbc,
-	0xdf, 0x5a, 0xe8, 0xd9, 0xf7, 0xdf, 0xa0, 0x8d, 0xe3, 0xae, 0x30, 0xf3,
-	0xd1, 0xe7, 0x58, 0xd7, 0x38, 0x6c, 0x8d, 0xa5, 0x7d, 0x15, 0xe8, 0xfd,
-	0x93, 0x7e, 0xce, 0xff, 0x51, 0xa1, 0x91, 0x17, 0xd3, 0xab, 0x45, 0x8c,
-	0x02, 0x75, 0xff, 0x54, 0xfe, 0x8b, 0xff, 0x61, 0xa3, 0xb3, 0x66, 0x70,
-	0xbc, 0x0c, 0x02, 0x22, 0xd5, 0x29, 0x0b, 0x03, 0xf0, 0xd4, 0x1d, 0xd0,
-	0x87, 0xef, 0xd3, 0x4d, 0x3e, 0x7a, 0x0e, 0xea, 0x4f, 0xc9, 0x11, 0x48,
-	0xd5, 0x99, 0x9b, 0xa5, 0x7e, 0x91, 0xa7, 0xf0, 0x34, 0x80, 0xbf, 0xb2,
-	0x92, 0xaa, 0x63, 0x01, 0x22, 0x63, 0xd5, 0xa8, 0xbe, 0x8e, 0x40, 0x57,
-	0x88, 0x3c, 0xff, 0x23, 0x82, 0xc9, 0xda, 0x85, 0x21, 0xb4, 0xec, 0x49,
-	0xbc, 0x64, 0x24, 0x5f, 0x4c, 0x09, 0x17, 0xdd, 0xbd, 0x5f, 0xe2, 0x10,
-	0x95, 0x44, 0x4e, 0xea, 0xb3, 0xf9, 0x11, 0x3f, 0x6d, 0xce, 0x61, 0x78,
-	0x4b, 0xdf, 0xc5, 0xfd, 0x10, 0x35, 0x93,
-}
-
-func TestLoadCSR(t *testing.T) {
-	b, err := LoadCSR([]byte(testCSR))
-	if err != nil {
-		t.Fatalf("load csr")
-	}
-
-	if !reflect.DeepEqual(b, testCSRDER) {
-		t.Fatalf("bad csr")
-	}
-}
diff --git a/acmeapi/api.go b/acmeapi/api.go
deleted file mode 100644
index a6befd2..0000000
--- a/acmeapi/api.go
+++ /dev/null
@@ -1,679 +0,0 @@
-// Package acmeapi provides an API for accessing ACME servers.
-//
-// Some methods provided correspond exactly to ACME calls, such as
-// NewAuthorization, RespondToChallenge, RequestCertificate or Revoke. Others,
-// such as UpsertRegistration, LoadCertificate or WaitForCertificate,
-// automatically compose requests to provide a simplified interface.
-//
-// For example, LoadCertificate obtains the issuing certificate chain as well.
-// WaitForCertificate polls until a certificate is available.
-// UpsertRegistration determines automatically whether an account key is
-// already registered and registers it if it is not.
-//
-// All methods take Contexts so as to support cancellation and timeouts.
-//
-// If you have an URI for an authorization, challenge or certificate, you
-// can load it by constructing such an object and setting the URI field,
-// then calling the appropriate Load function. (The unexported fields in these
-// structures are used to track Retry-After times for the WaitLoad* functions and
-// are not a barrier to you constructing these objects.)
-//
-// The following additional packages are likely to be of interest:
-//
-//   https://godoc.org/github.com/hlandau/acme/acmeapi/acmeendpoints  Known providers
-//   https://godoc.org/github.com/hlandau/acme/acmeapi/acmeutils      Certificate loading utilities
-//
-package acmeapi
-
-import (
-	"crypto"
-	"crypto/ecdsa"
-	"crypto/rsa"
-	"gopkg.in/square/go-jose.v1"
-
-	denet "github.com/hlandau/goutils/net"
-	"github.com/peterhellberg/link"
-	"golang.org/x/net/context"
-	"golang.org/x/net/context/ctxhttp"
-	"io"
-	"io/ioutil"
-	"net/http"
-	"net/url"
-
-	"encoding/json"
-	"fmt"
-	"github.com/hlandau/xlog"
-	"runtime"
-	"strings"
-	"sync"
-	"time"
-)
-
-// Log site.
-var log, Log = xlog.NewQuiet("acme.api")
-
-type directoryInfo struct {
-	NewReg     string `json:"new-reg"`
-	RecoverReg string `json:"recover-reg"`
-	NewAuthz   string `json:"new-authz"`
-	NewCert    string `json:"new-cert"`
-	RevokeCert string `json:"revoke-cert"`
-}
-
-type revokeReq struct {
-	Resource    string         `json:"resource"` // "revoke-cert"
-	Certificate denet.Base64up `json:"certificate"`
-}
-
-// Returns true if the URL given is (potentially) a valid ACME resource URL.
-//
-// The URL must be an HTTPS URL.
-func ValidURL(u string) bool {
-	ur, err := url.Parse(u)
-	return err == nil && (ur.Scheme == "https" || (TestingAllowHTTP && ur.Scheme == "http"))
-}
-
-// Internal use only. All ACME URLs must use "https" and not "http". However,
-// for testing purposes, if this is set, "http" URLs will be allowed. This is
-// useful for testing when a test ACME server doesn't have SSL configured.
-var TestingAllowHTTP = false
-
-// Client for making ACME API calls.
-//
-// You must set at least AccountKey and DirectoryURL.
-type Client struct {
-	// Account private key. Required.
-	AccountKey crypto.PrivateKey
-
-	// The ACME server directory URL. Required. (However, you can omit this if
-	// you only use the client to load existing resources at known URLs.)
-	DirectoryURL string
-
-	// Uses http.DefaultClient if nil.
-	HTTPClient *http.Client
-
-	dir            *directoryInfo
-	nonceSource    nonceSource
-	nonceReentrant int
-	initOnce       sync.Once
-}
-
-// You should set this to a string identifying the code invoking this library.
-// Optional.
-var UserAgent string
-
-func (c *Client) doReq(method, url string, v, r interface{}, ctx context.Context) (*http.Response, error) {
-	return c.doReqEx(method, url, nil, v, r, ctx)
-}
-
-func algorithmFromKey(key crypto.PrivateKey) (jose.SignatureAlgorithm, error) {
-	switch v := key.(type) {
-	case *rsa.PrivateKey:
-		return jose.RS256, nil
-	case *ecdsa.PrivateKey:
-		name := v.Curve.Params().Name
-		switch name {
-		case "P-256":
-			return jose.ES256, nil
-		case "P-384":
-			return jose.ES384, nil
-		case "P-521":
-			return jose.ES512, nil
-		default:
-			return "", fmt.Errorf("unsupported ECDSA curve: %s", name)
-		}
-	default:
-		return "", fmt.Errorf("unsupported private key type: %T", key)
-	}
-}
-
-func (c *Client) obtainNewNonce(ctx context.Context) error {
-	if c.nonceReentrant > 0 {
-		panic("nonce reentrancy - this should never happen")
-	}
-	c.nonceReentrant++
-	defer func() { c.nonceReentrant-- }()
-
-	_, err := c.forceGetDirectory(ctx)
-	return err
-}
-
-func (c *Client) doReqEx(method, url string, key crypto.PrivateKey, v, r interface{}, ctx context.Context) (*http.Response, error) {
-	if !ValidURL(url) {
-		return nil, fmt.Errorf("invalid URL: %#v", url)
-	}
-
-	if key == nil {
-		key = c.AccountKey
-	}
-
-	c.nonceSource.GetNonceFunc = c.obtainNewNonce
-
-	var rdr io.Reader
-	if v != nil {
-		b, err := json.Marshal(v)
-		if err != nil {
-			return nil, err
-		}
-
-		if key == nil {
-			return nil, fmt.Errorf("account key must be specified")
-		}
-
-		kalg, err := algorithmFromKey(key)
-		if err != nil {
-			return nil, err
-		}
-
-		signer, err := jose.NewSigner(kalg, key)
-		if err != nil {
-			return nil, err
-		}
-
-		signer.SetNonceSource(c.nonceSource.WithContext(ctx))
-
-		sig, err := signer.Sign(b)
-		if err != nil {
-			return nil, err
-		}
-
-		s := sig.FullSerialize()
-		if err != nil {
-			return nil, err
-		}
-
-		rdr = strings.NewReader(s)
-	}
-
-	req, err := http.NewRequest(method, url, rdr)
-	if err != nil {
-		return nil, err
-	}
-
-	req.Header.Set("Accept", "application/json")
-	if method == "POST" {
-		req.Header.Set("Content-Type", "application/json")
-	}
-
-	log.Debugf("request: %s", url)
-	res, err := c.doReqActual(req, ctx)
-	log.Debugf("response: %v %v", res, err)
-	if err != nil {
-		return nil, err
-	}
-
-	if n := res.Header.Get("Replay-Nonce"); n != "" {
-		c.nonceSource.AddNonce(n)
-	}
-
-	if res.StatusCode >= 400 && res.StatusCode < 600 {
-		defer res.Body.Close()
-		return res, newHTTPError(res)
-	}
-
-	if r != nil {
-		defer res.Body.Close()
-		if ct := res.Header.Get("Content-Type"); ct != "application/json" {
-			return res, fmt.Errorf("unexpected content type: %#v", ct)
-		}
-
-		err = json.NewDecoder(res.Body).Decode(r)
-		if err != nil {
-			return nil, err
-		}
-	}
-
-	return res, nil
-}
-
-func (c *Client) doReqActual(req *http.Request, ctx context.Context) (*http.Response, error) {
-	req.Header.Set("User-Agent", userAgent(UserAgent))
-	return ctxhttp.Do(ctx, c.HTTPClient, req)
-}
-
-func (c *Client) forceGetDirectory(ctx context.Context) (*directoryInfo, error) {
-	if c.DirectoryURL == "" {
-		return nil, fmt.Errorf("must specify a directory URL")
-	}
-
-	_, err := c.doReq("GET", c.DirectoryURL, nil, &c.dir, ctx)
-	if err != nil {
-		return nil, err
-	}
-
-	if !ValidURL(c.dir.NewReg) || !ValidURL(c.dir.NewAuthz) || !ValidURL(c.dir.NewCert) {
-		c.dir = nil
-		return nil, fmt.Errorf("directory does not provide required endpoints")
-	}
-
-	return c.dir, nil
-}
-
-func (c *Client) getDirectory(ctx context.Context) (*directoryInfo, error) {
-	if c.dir != nil {
-		return c.dir, nil
-	}
-
-	return c.forceGetDirectory(ctx)
-}
-
-// API Methods
-
-var newRegCodes = []int{201, 409}
-var updateRegCodes = []int{200, 202}
-
-func isStatusCode(res *http.Response, codes []int) bool {
-	for _, c := range codes {
-		if c == res.StatusCode {
-			return true
-		}
-	}
-	return false
-}
-
-// Loads an existing registration. If reg.URI is set, then that registration is
-// updated, and the operation fails if the registration does not exist.
-// Otherwise, the registration is created if it does not exist or updated if it
-// does and the URI is returned.
-//
-// Note that this operation requires an account key, since the registration is
-// private data requiring authentication to access.
-func (c *Client) UpsertRegistration(reg *Registration, ctx context.Context) error {
-	di, err := c.getDirectory(ctx)
-	if err != nil {
-		return err
-	}
-
-	// Determine whether we need to get the registration URI.
-	endp := reg.URI
-	resource := "reg"
-	expectCode := updateRegCodes
-	if endp == "" {
-		endp = di.NewReg
-		resource = "new-reg"
-		expectCode = newRegCodes
-	}
-
-	// Make request.
-	reg.Resource = resource
-	res, err := c.doReq("POST", endp, reg, reg, ctx)
-	if res == nil {
-		return err
-	}
-
-	// Get TOS URI.
-	lg := link.ParseResponse(res)
-	if tosLink, ok := lg["terms-of-service"]; ok {
-		reg.LatestAgreementURI = tosLink.URI
-	}
-
-	// Ensure status code is an expected value.
-	if !isStatusCode(res, expectCode) {
-		if err != nil {
-			return err
-		}
-
-		return fmt.Errorf("unexpected status code: %d: %v", res.StatusCode, endp)
-	}
-
-	// Process registration URI.
-	loc := res.Header.Get("Location")
-	switch {
-	case resource == "reg":
-		// Updating existing registration, so we already have the URL and
-		// shouldn't be redirected anywhere.
-		if loc != "" {
-			return fmt.Errorf("unexpected Location header: %q", loc)
-		}
-	case !ValidURL(loc):
-		return fmt.Errorf("invalid URL: %q", loc)
-	default:
-		// Save the registration URL.
-		reg.URI = loc
-	}
-
-	// If conflict occurred, need to issue the request again to update fields.
-	if res.StatusCode == 409 {
-		return c.UpsertRegistration(reg, ctx)
-	}
-
-	return nil
-}
-
-// This is a higher-level account registration method built on
-// UpsertRegistration. If a new agreement is required and its URI
-// is set in agreementURIs, it will be agreed to automatically. Otherwise
-// AgreementError will be returned.
-func (c *Client) AgreeRegistration(reg *Registration, agreementURIs map[string]struct{}, ctx context.Context) error {
-	err := c.UpsertRegistration(reg, ctx)
-	if err != nil {
-		return err
-	}
-
-	if reg.LatestAgreementURI != reg.AgreementURI {
-		_, ok := agreementURIs[reg.LatestAgreementURI]
-		if !ok {
-			return &AgreementError{reg.LatestAgreementURI}
-		}
-
-		reg.AgreementURI = reg.LatestAgreementURI
-		err = c.UpsertRegistration(reg, ctx)
-		if err != nil {
-			return err
-		}
-	}
-
-	return nil
-}
-
-// Load or reload the details of an authorization via the URI.
-//
-// You can load an authorization from only the URI by creating an Authorization
-// with the URI set and then calling this.
-func (c *Client) LoadAuthorization(az *Authorization, ctx context.Context) error {
-	az.Combinations = nil
-
-	res, err := c.doReq("GET", az.URI, nil, az, ctx)
-	if err != nil {
-		return err
-	}
-
-	err = az.validate()
-	if err != nil {
-		return err
-	}
-
-	az.retryAt = retryAtDefault(res.Header, 10*time.Second)
-	return nil
-}
-
-// Like LoadAuthorization, but waits the retry time if this is not the first
-// attempt to load this authoization. To be used when polling.
-func (c *Client) WaitLoadAuthorization(az *Authorization, ctx context.Context) error {
-	err := waitUntil(az.retryAt, ctx)
-	if err != nil {
-		return err
-	}
-
-	return c.LoadAuthorization(az, ctx)
-}
-
-func (az *Authorization) validate() error {
-	if len(az.Challenges) == 0 {
-		return fmt.Errorf("no challenges offered")
-	}
-
-	if az.Combinations == nil {
-		var is []int
-		for i := 0; i < len(az.Challenges); i++ {
-			is = append(is, i)
-		}
-		az.Combinations = append(az.Combinations, is)
-	}
-
-	for _, c := range az.Combinations {
-		for _, i := range c {
-			if i >= len(az.Challenges) {
-				return fmt.Errorf("one or more combinations are malformed")
-			}
-		}
-	}
-
-	return nil
-}
-
-// Load or reload the details of a challenge via the URI.
-//
-// You can load a challenge from only the URI by creating a Challenge with the
-// URI set and then calling this.
-func (c *Client) LoadChallenge(ch *Challenge, ctx context.Context) error {
-	res, err := c.doReq("GET", ch.URI, nil, ch, ctx)
-	if err != nil {
-		return err
-	}
-
-	ch.retryAt = retryAtDefault(res.Header, 10*time.Second)
-	return nil
-}
-
-// Like LoadChallenge, but waits the retry time if this is not the first
-// attempt to load this challenge. To be used when polling.
-func (c *Client) WaitLoadChallenge(ch *Challenge, ctx context.Context) error {
-	err := waitUntil(ch.retryAt, ctx)
-	if err != nil {
-		return err
-	}
-
-	return c.LoadChallenge(ch, ctx)
-}
-
-// Create a new authorization for the given hostname.
-func (c *Client) NewAuthorization(hostname string, ctx context.Context) (*Authorization, error) {
-	di, err := c.getDirectory(ctx)
-	if err != nil {
-		return nil, err
-	}
-
-	az := &Authorization{
-		Resource: "new-authz",
-		Identifier: Identifier{
-			Type:  "dns",
-			Value: hostname,
-		},
-	}
-
-	res, err := c.doReq("POST", di.NewAuthz, az, az, ctx)
-	if err != nil {
-		return nil, err
-	}
-
-	loc := res.Header.Get("Location")
-	if res.StatusCode != 201 || !ValidURL(loc) {
-		return nil, fmt.Errorf("expected status code 201 and valid Location header: %#v", res)
-	}
-
-	az.URI = loc
-
-	err = az.validate()
-	if err != nil {
-		return nil, err
-	}
-
-	return az, nil
-}
-
-// Submit a challenge response. Only the challenge URI is required.
-//
-// The response message is signed with the given key.
-//
-// If responseKey is nil, the account key is used.
-func (c *Client) RespondToChallenge(ch *Challenge, response json.RawMessage, responseKey crypto.PrivateKey, ctx context.Context) error {
-	_, err := c.doReqEx("POST", ch.URI, responseKey, &response, c, ctx)
-	if err != nil {
-		return err
-	}
-
-	return nil
-}
-
-// Request a certificate using a CSR in DER form.
-func (c *Client) RequestCertificate(csrDER []byte, ctx context.Context) (*Certificate, error) {
-	di, err := c.getDirectory(ctx)
-	if err != nil {
-		return nil, err
-	}
-
-	crt := &Certificate{
-		Resource: "new-cert",
-		CSR:      csrDER,
-	}
-
-	res, err := c.doReq("POST", di.NewCert, crt, nil, ctx)
-	if err != nil {
-		return nil, err
-	}
-
-	defer res.Body.Close()
-	if res.StatusCode != 201 {
-		return nil, fmt.Errorf("unexpected status code: %v", res.StatusCode)
-	}
-
-	loc := res.Header.Get("Location")
-	if !ValidURL(loc) {
-		return nil, fmt.Errorf("invalid URI: %#v", loc)
-	}
-
-	crt.URI = loc
-
-	err = c.loadCertificate(crt, res, ctx)
-	if err != nil {
-		return nil, err
-	}
-
-	return crt, nil
-}
-
-// Load or reload a certificate.
-//
-// You can load a certificate from its URI by creating a Certificate with the
-// URI set and then calling this.
-//
-// Returns nil if the certificate is not yet ready, but the Certificate field
-// will remain nil.
-func (c *Client) LoadCertificate(crt *Certificate, ctx context.Context) error {
-	res, err := c.doReq("GET", crt.URI, nil, nil, ctx)
-	if err != nil {
-		return err
-	}
-
-	return c.loadCertificate(crt, res, ctx)
-}
-
-func (c *Client) loadCertificate(crt *Certificate, res *http.Response, ctx context.Context) error {
-	defer res.Body.Close()
-	ct := res.Header.Get("Content-Type")
-	if ct == "application/pkix-cert" {
-		der, err := ioutil.ReadAll(denet.LimitReader(res.Body, 1*1024*1024))
-		if err != nil {
-			return err
-		}
-
-		crt.Certificate = der
-		err = c.loadExtraCertificates(crt, res, ctx)
-		if err != nil {
-			return err
-		}
-
-	} else if res.StatusCode == 200 {
-		return fmt.Errorf("Certificate returned with unexpected type: %v", ct)
-	}
-
-	crt.retryAt = retryAtDefault(res.Header, 10*time.Second)
-	return nil
-}
-
-func (c *Client) loadExtraCertificates(crt *Certificate, res *http.Response, ctx context.Context) error {
-	crt.ExtraCertificates = nil
-
-	for {
-		var err error
-
-		lg := link.ParseResponse(res)
-		up, ok := lg["up"]
-		if !ok {
-			return nil
-		}
-
-		crtURI, _ := url.Parse(crt.URI)
-		upURI, _ := url.Parse(up.URI)
-		if crtURI == nil || upURI == nil {
-			return fmt.Errorf("invalid URI")
-		}
-		upURI = crtURI.ResolveReference(upURI)
-
-		res, err = c.doReq("GET", upURI.String(), nil, nil, ctx)
-		if err != nil {
-			return err
-		}
-
-		defer res.Body.Close()
-		ct := res.Header.Get("Content-Type")
-		if ct != "application/pkix-cert" {
-			return fmt.Errorf("unexpected certificate type: %v", ct)
-		}
-
-		der, err := ioutil.ReadAll(denet.LimitReader(res.Body, 1*1024*1024))
-		if err != nil {
-			return err
-		}
-
-		res.Body.Close()
-		crt.ExtraCertificates = append(crt.ExtraCertificates, der)
-	}
-}
-
-// Like LoadCertificate, but waits the retry time if this is not the first
-// attempt to load this certificate. To be used when polling.
-//
-// You will almost certainly want WaitForCertificate instead of this.
-func (c *Client) WaitLoadCertificate(crt *Certificate, ctx context.Context) error {
-	err := waitUntil(crt.retryAt, ctx)
-	if err != nil {
-		return err
-	}
-
-	return c.LoadCertificate(crt, ctx)
-}
-
-// Wait for a pending certificate to be issued. If the certificate has already
-// been issued, this is a no-op. Only the URI is required. May be cancelled
-// using the context.
-func (c *Client) WaitForCertificate(crt *Certificate, ctx context.Context) error {
-	for {
-		if len(crt.Certificate) > 0 {
-			return nil
-		}
-
-		err := c.WaitLoadCertificate(crt, ctx)
-		if err != nil {
-			return err
-		}
-	}
-}
-
-// Revoke the given certificate.
-//
-// The revocation key may be the key corresponding to the certificate. If it is
-// nil, the account key is used; in this case, the account must be authorized
-// for all identifiers in the certificate.
-func (c *Client) Revoke(certificateDER []byte, revocationKey crypto.PrivateKey, ctx context.Context) error {
-	di, err := c.getDirectory(ctx)
-	if err != nil {
-		return err
-	}
-
-	if di.RevokeCert == "" {
-		return fmt.Errorf("endpoint does not support revocation")
-	}
-
-	req := &revokeReq{
-		Resource:    "revoke-cert",
-		Certificate: certificateDER,
-	}
-
-	res, err := c.doReqEx("POST", di.RevokeCert, revocationKey, req, nil, ctx)
-	if err != nil {
-		return err
-	}
-	defer res.Body.Close()
-
-	return nil
-}
-
-func userAgent(ua string) string {
-	if ua != "" {
-		ua += " "
-	}
-
-	return fmt.Sprintf("%sacmeapi Go-http-client/1.1 %s/%s", ua, runtime.GOOS, runtime.GOARCH)
-}
diff --git a/acmeapi/api_ig_test.go b/acmeapi/api_ig_test.go
deleted file mode 100644
index 487a45d..0000000
--- a/acmeapi/api_ig_test.go
+++ /dev/null
@@ -1,70 +0,0 @@
-// +build integration
-
-package acmeapi
-
-import (
-	"crypto"
-	"crypto/ecdsa"
-	"crypto/elliptic"
-	"crypto/rand"
-	"crypto/rsa"
-	"golang.org/x/net/context"
-	"testing"
-)
-
-func testAPIWithKey(t *testing.T, pk crypto.PrivateKey) {
-	cl := Client{
-		DirectoryURL: "http://127.0.0.1:4000/directory",
-	}
-	cl.AccountKey = pk
-	agreementURIs := map[string]struct{}{
-		"http://boulder:4000/terms/v1": {},
-	}
-	reg := &Registration{
-		ContactURIs: []string{
-			"mailto:nobody@localhost",
-		},
-	}
-
-	err := cl.AgreeRegistration(reg, agreementURIs, context.TODO())
-	if err != nil {
-		t.Fatalf("couldn't upsert registration: %v", err)
-	}
-
-	auth, err := cl.NewAuthorization("dom1.acmetool-test.devever.net", context.TODO())
-	if err != nil {
-		t.Fatalf("couldn't create authorization: %v", err)
-	}
-
-	err = cl.WaitLoadAuthorization(auth, context.TODO())
-	if err != nil {
-		t.Fatalf("couldn't load authorization")
-	}
-
-	err = cl.WaitLoadChallenge(auth.Challenges[0], context.TODO())
-	if err != nil {
-		t.Fatalf("couldn't load challenge")
-	}
-
-	// TODO
-	//cl.RespondToChallenge
-	//cl.RequestCertificate
-}
-
-func TestAPIIntegration(t *testing.T) {
-	TestingAllowHTTP = true
-
-	rsaPK, err := rsa.GenerateKey(rand.Reader, 2048)
-	if err != nil {
-		t.Fatalf("couldn't generate RSA key: %v", err)
-	}
-
-	testAPIWithKey(t, rsaPK)
-
-	ecdsaPK, err := ecdsa.GenerateKey(elliptic.P384(), rand.Reader)
-	if err != nil {
-		t.Fatalf("couldn't generate ECDSA key: %v", err)
-	}
-
-	testAPIWithKey(t, ecdsaPK)
-}
diff --git a/acmeapi/api_test.go b/acmeapi/api_test.go
deleted file mode 100644
index b09f97d..0000000
--- a/acmeapi/api_test.go
+++ /dev/null
@@ -1,360 +0,0 @@
-package acmeapi
-
-import (
-	"crypto/ecdsa"
-	"crypto/elliptic"
-	"crypto/rand"
-	"encoding/hex"
-	"encoding/json"
-	"fmt"
-	"github.com/hlandau/goutils/test"
-	"github.com/hlandau/xlog"
-	"gopkg.in/square/go-jose.v1"
-	"golang.org/x/net/context"
-	"io/ioutil"
-	"net/http"
-	"reflect"
-	"testing"
-	"time"
-)
-
-func TestAPI(t *testing.T) {
-	Log.SetSeverity(xlog.SevDebug)
-
-	mt := test.HTTPMockTransport{}
-
-	cl := &Client{
-		HTTPClient: &http.Client{
-			Transport: &mt,
-		},
-	}
-
-	issuedNonces := map[string]struct{}{}
-	issueNonce := func() string {
-		var b [8]byte
-		_, err := rand.Read(b[:])
-		if err != nil {
-			panic(err)
-		}
-
-		s := fmt.Sprintf("nonce-%s", hex.EncodeToString(b[:]))
-		issuedNonces[s] = struct{}{}
-		return s
-	}
-
-	checkNonce := func(rw http.ResponseWriter, req *http.Request) bool {
-		b, err := ioutil.ReadAll(req.Body)
-		if err != nil {
-			log.Fatalf("cannot read body: %v", err)
-		}
-
-		jws, err := jose.ParseSigned(string(b))
-		if err != nil {
-			log.Fatalf("malformed request body: %v", err)
-		}
-
-		if len(jws.Signatures) != 1 {
-			log.Fatalf("wrong number of signatures: %v", err)
-		}
-
-		n := jws.Signatures[0].Header.Nonce
-
-		_, ok := issuedNonces[n]
-		if !ok {
-			rw.Header().Set("Content-Type", "application/json")
-			rw.WriteHeader(400)
-			rw.Write([]byte(`{"type":"bad-nonce","message":"Bad nonce."}`))
-			t.Logf("invalid nonce: %#v", n)
-			t.Fail()
-			return false
-		}
-		delete(issuedNonces, n)
-		return true
-	}
-
-	// Load Certificate
-
-	mt.Add("boulder.test/acme/cert/some-certificate", &http.Response{
-		StatusCode: 200,
-		Header: http.Header{
-			"Content-Type": []string{"application/pkix-cert"},
-			"Link":         []string{"</acme/issuer-cert>; rel=\"up\""},
-		},
-	}, []byte("cert-data"))
-
-	mt.Add("boulder.test/acme/issuer-cert", &http.Response{
-		StatusCode: 200,
-		Header: http.Header{
-			"Content-Type": []string{"application/pkix-cert"},
-			"Link":         []string{"</acme/root-cert>; rel=\"up\""},
-		},
-	}, []byte("issuer-cert-data"))
-
-	mt.Add("boulder.test/acme/root-cert", &http.Response{
-		StatusCode: 200,
-		Header: http.Header{
-			"Content-Type": []string{"application/pkix-cert"},
-			//"Replay-Nonce": []string{"some-nonce-root"},
-		},
-	}, []byte("root-cert-data"))
-
-	crt := &Certificate{
-		URI: "https://boulder.test/acme/cert/some-certificate",
-	}
-
-	correctCrt := *crt
-	err := cl.WaitForCertificate(crt, context.TODO())
-	if err != nil {
-		t.Fatalf("%v", err)
-	}
-
-	someCrt := *crt
-	correctCrt.Certificate = []byte("cert-data")
-	correctCrt.ExtraCertificates = [][]byte{
-		[]byte("issuer-cert-data"),
-		[]byte("root-cert-data"),
-	}
-
-	crt.retryAt = time.Time{}
-	if !reflect.DeepEqual(&correctCrt, crt) {
-		t.Fatalf("%v != %v", &correctCrt, crt)
-	}
-
-	// Load Authorization
-
-	mt.Add("boulder.test/acme/authz/some-authz", &http.Response{
-		StatusCode: 200,
-		Header: http.Header{
-			"Content-Type": []string{"application/json"},
-		},
-	}, []byte(`{"challenges":[
-    {
-      "type": "http-01",
-      "uri": "https://boulder.test/acme/challenge/some-challenge"
-    }
-  ],
-  "identifier": {
-    "type": "dns",
-    "value": "example.com"
-  },
-  "status": "pending",
-  "expires": "2015-01-01T18:26:57Z"
-  }`))
-
-	az := &Authorization{
-		URI: "https://boulder.test/acme/authz/some-authz",
-	}
-
-	correctAZ := *az
-	correctAZ.Combinations = [][]int{[]int{0}}
-	correctAZ.Identifier.Type = "dns"
-	correctAZ.Identifier.Value = "example.com"
-	correctAZ.Status = "pending"
-	correctAZ.Expires = time.Date(2015, 1, 1, 18, 26, 57, 0, time.UTC)
-	correctAZ.Challenges = []*Challenge{
-		{
-			Type: "http-01",
-			URI:  "https://boulder.test/acme/challenge/some-challenge",
-		},
-	}
-
-	err = cl.WaitLoadAuthorization(az, context.TODO())
-	if err != nil {
-		t.Fatalf("%v", err)
-	}
-
-	az.retryAt = time.Time{}
-	if !reflect.DeepEqual(&correctAZ, az) {
-		t.Fatal("%v != %v", &correctAZ, az)
-	}
-
-	// Load Challenge
-
-	mt.Add("boulder.test/acme/challenge/some-challenge", &http.Response{
-		StatusCode: 200,
-		Header: http.Header{
-			"Content-Type": []string{"application/json"},
-		},
-	}, []byte(`{
-    "type": "http-01"
-  }`))
-
-	ch := &Challenge{
-		URI: "https://boulder.test/acme/challenge/some-challenge",
-	}
-	err = cl.WaitLoadChallenge(ch, context.TODO())
-	if err != nil {
-		t.Fatalf("%v", err)
-	}
-
-	// Request Certificate
-
-	mt.AddHandlerFunc("boulder.test/directory", func(rw http.ResponseWriter, req *http.Request) {
-		rw.Header().Set("Content-Type", "application/json")
-		rw.Header().Set("Replay-Nonce", issueNonce())
-		rw.WriteHeader(200)
-		rw.Write([]byte(`{
-      "new-reg": "https://boulder.test/acme/new-reg",
-      "new-cert": "https://boulder.test/acme/new-cert",
-      "new-authz": "https://boulder.test/acme/new-authz",
-      "revoke-cert": "https://boulder.test/acme/revoke-cert"
-    }`))
-	})
-
-	mt.AddHandlerFunc("boulder.test/acme/new-cert", func(rw http.ResponseWriter, req *http.Request) {
-		rw.Header().Set("Location", "https://boulder.test/acme/cert/some-certificate")
-		rw.WriteHeader(201)
-	})
-
-	epk, _ := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
-	cl.AccountKey = epk
-
-	cl.DirectoryURL = "https://boulder.test/directory"
-	crt, err = cl.RequestCertificate([]byte("csr"), context.TODO())
-	if err != nil {
-		t.Fatalf("%v", err)
-	}
-
-	err = cl.LoadCertificate(crt, context.TODO())
-	if err != nil {
-		t.Fatalf("%v", err)
-	}
-
-	crt.CSR = nil
-	crt.Resource = ""
-	crt.retryAt = someCrt.retryAt
-	if !reflect.DeepEqual(&someCrt, crt) {
-		t.Fatalf("mismatch %#v\n\n%#v", &someCrt, crt)
-	}
-
-	t.Logf("%v", crt)
-
-	// Upsert Registration
-
-	mt.AddHandlerFunc("boulder.test/acme/new-reg", func(rw http.ResponseWriter, req *http.Request) {
-		if req.Method != "POST" {
-			t.Fatal()
-		}
-		if !checkNonce(rw, req) {
-			return
-		}
-
-		rw.Header().Set("Location", "https://boulder.test/acme/reg/1")
-		rw.Header().Set("Replay-Nonce", issueNonce())
-		rw.WriteHeader(409)
-	})
-
-	mt.AddHandlerFunc("boulder.test/acme/reg/1", func(rw http.ResponseWriter, req *http.Request) {
-		if req.Method != "POST" {
-			t.Fatal()
-		}
-		if !checkNonce(rw, req) {
-			return
-		}
-
-		rw.Header().Set("Replay-Nonce", issueNonce())
-		rw.Header().Set("Content-Type", "application/json")
-		rw.Header().Set("Link", "<urn:some:boulder:terms/of/service>; rel=\"terms-of-service\"")
-		rw.WriteHeader(200)
-		rw.Write([]byte(`{}`))
-	})
-
-	reg := &Registration{}
-	err = cl.AgreeRegistration(reg, nil, context.TODO())
-	ae, ok := err.(*AgreementError)
-	if !ok || ae.URI != "urn:some:boulder:terms/of/service" {
-		t.Fatalf("expected agreement error")
-	}
-
-	agreementURIs := map[string]struct{}{
-		"urn:some:boulder:terms/of/service": struct{}{},
-	}
-	err = cl.AgreeRegistration(reg, agreementURIs, context.TODO())
-	if err != nil {
-		t.Fatalf("%v", err)
-	}
-
-	// New Authorization
-	e503Count := 0
-	total503 := 3
-
-	mt.AddHandlerFunc("boulder.test/acme/new-authz", func(rw http.ResponseWriter, req *http.Request) {
-		if req.Method != "POST" {
-			t.Fatal()
-		}
-		if !checkNonce(rw, req) {
-			return
-		}
-
-		rw.Header().Set("Content-Type", "application/json")
-
-		if e503Count < total503 {
-			rw.WriteHeader(503)
-			rw.Write([]byte(`{"type":"urn:acme:error:serverInternal","detail":"Down"}`))
-			e503Count++
-			return
-		}
-
-		rw.Header().Set("Location", "https://boulder.test/acme/authz/1")
-		rw.Header().Set("Replay-Nonce", issueNonce())
-		rw.WriteHeader(201)
-		rw.Write([]byte(`{
-  "challenges": [
-    {
-      "type": "http-01",
-      "uri": "https://boulder.test/acme/challenge/some-challenge2"
-    }
-  ],
-  "identifier": {
-    "type": "dns",
-    "value": "example.com"
-  },
-  "status": "pending",
-  "expires": "2015-01-01T18:26:57Z"
-}`))
-
-	})
-
-	mt.AddHandlerFunc("boulder.test/acme/challenge/some-challenge2", func(rw http.ResponseWriter, req *http.Request) {
-		rw.Header().Set("Replay-Nonce", issueNonce())
-		rw.Header().Set("Content-Type", "application/json")
-		rw.WriteHeader(200)
-		rw.Write([]byte(`{}`))
-	})
-
-	for i := 0; i < total503; i++ {
-		az, err = cl.NewAuthorization("example.com", context.TODO())
-		if err == nil {
-			t.Fatalf("no error when expected")
-		}
-	}
-
-	az, err = cl.NewAuthorization("example.com", context.TODO())
-	if err != nil {
-		t.Fatalf("%v", err)
-	}
-
-	err = cl.RespondToChallenge(az.Challenges[0], json.RawMessage(`{}`), nil, context.TODO())
-	if err != nil {
-		t.Fatalf("%v", err)
-	}
-
-	mt.AddHandlerFunc("boulder.test/acme/revoke-cert", func(rw http.ResponseWriter, req *http.Request) {
-		if req.Method != "POST" {
-			t.Fatal()
-		}
-		if !checkNonce(rw, req) {
-			return
-		}
-
-		rw.Header().Set("Replay-Nonce", issueNonce())
-		rw.Header().Set("Content-Type", "application/json")
-		rw.WriteHeader(200)
-		rw.Write([]byte(`{}`))
-	})
-
-	err = cl.Revoke([]byte("revoke-der"), nil, context.TODO())
-	if err != nil {
-		t.Fatalf("%v", err)
-	}
-}
diff --git a/acmeapi/nonce.go b/acmeapi/nonce.go
deleted file mode 100644
index fdb3d37..0000000
--- a/acmeapi/nonce.go
+++ /dev/null
@@ -1,69 +0,0 @@
-package acmeapi
-
-import (
-	"errors"
-	"golang.org/x/net/context"
-)
-
-type nonceSource struct {
-	pool         map[string]struct{}
-	GetNonceFunc func(ctx context.Context) error
-}
-
-func (ns *nonceSource) init() {
-	if ns.pool != nil {
-		return
-	}
-
-	ns.pool = map[string]struct{}{}
-}
-
-func (ns *nonceSource) Nonce(ctx context.Context) (string, error) {
-	ns.init()
-
-	var k string
-	for k = range ns.pool {
-		break
-	}
-	if k == "" {
-		err := ns.obtainNonce(ctx)
-		if err != nil {
-			return "", err
-		}
-		for k = range ns.pool {
-			break
-		}
-		if k == "" {
-			return "", errors.New("failed to retrieve additional nonce")
-		}
-	}
-
-	delete(ns.pool, k)
-	return k, nil
-}
-
-func (ns *nonceSource) obtainNonce(ctx context.Context) error {
-	if ns.GetNonceFunc == nil {
-		return errors.New("out of nonces - this should never happen")
-	}
-
-	return ns.GetNonceFunc(ctx)
-}
-
-func (ns *nonceSource) AddNonce(nonce string) {
-	ns.init()
-	ns.pool[nonce] = struct{}{}
-}
-
-func (ns *nonceSource) WithContext(ctx context.Context) *nonceSourceWithCtx {
-	return &nonceSourceWithCtx{ns, ctx}
-}
-
-type nonceSourceWithCtx struct {
-	nonceSource *nonceSource
-	ctx         context.Context
-}
-
-func (nc *nonceSourceWithCtx) Nonce() (string, error) {
-	return nc.nonceSource.Nonce(nc.ctx)
-}
diff --git a/acmeapi/nonce_test.go b/acmeapi/nonce_test.go
deleted file mode 100644
index 9a9e497..0000000
--- a/acmeapi/nonce_test.go
+++ /dev/null
@@ -1,37 +0,0 @@
-package acmeapi
-
-import (
-	"golang.org/x/net/context"
-	"testing"
-)
-
-func TestNonce(t *testing.T) {
-	ns := nonceSource{}
-	ns.AddNonce("my-nonce")
-	nsc := ns.WithContext(context.TODO())
-	n, err := nsc.Nonce()
-	if err != nil {
-		t.Fatal()
-	}
-	if n != "my-nonce" {
-		t.Fatal()
-	}
-
-	n, err = nsc.Nonce()
-	if err == nil {
-		t.Fatal()
-	}
-
-	ns.GetNonceFunc = func(ctx context.Context) error {
-		ns.AddNonce("nonce2")
-		return nil
-	}
-
-	n, err = nsc.Nonce()
-	if err != nil {
-		t.Fatal()
-	}
-	if n != "nonce2" {
-		t.Fatal()
-	}
-}
diff --git a/acmeapi/ocsp.go b/acmeapi/ocsp.go
deleted file mode 100644
index c125a35..0000000
--- a/acmeapi/ocsp.go
+++ /dev/null
@@ -1,71 +0,0 @@
-package acmeapi
-
-import (
-	"crypto/x509"
-	"encoding/base64"
-	"fmt"
-	denet "github.com/hlandau/goutils/net"
-	"golang.org/x/crypto/ocsp"
-	"golang.org/x/net/context"
-	"io/ioutil"
-	"net/http"
-)
-
-// This is equivalent to calling CheckOCSPRaw, but the raw response is not
-// returned. Preserved for compatibility; use CheckOCSPRaw instead.
-func (c *Client) CheckOCSP(crt, issuer *x509.Certificate, ctx context.Context) (*ocsp.Response, error) {
-	res, _, err := c.CheckOCSPRaw(crt, issuer, ctx)
-	return res, err
-}
-
-// Checks OCSP for a certificate. The immediate issuer must be specified. If
-// the certificate does not support OCSP, (nil, nil) is returned.  Uses HTTP
-// GET rather than POST. The response is verified. The caller must check the
-// response status. The raw OCSP response is also returned, even if parsing
-// failed and err is non-nil.
-func (c *Client) CheckOCSPRaw(crt, issuer *x509.Certificate, ctx context.Context) (parsedResponse *ocsp.Response, rawResponse []byte, err error) {
-	if len(crt.OCSPServer) == 0 {
-		return
-	}
-
-	b, err := ocsp.CreateRequest(crt, issuer, nil)
-	if err != nil {
-		return
-	}
-
-	b64 := base64.StdEncoding.EncodeToString(b)
-	path := crt.OCSPServer[0] + "/" + b64
-
-	req, err := http.NewRequest("GET", path, nil)
-	if err != nil {
-		return
-	}
-
-	req.Header.Set("Accept", "application/ocsp-response")
-
-	res, err := c.doReqActual(req, ctx)
-	if err != nil {
-		return
-	}
-
-	defer res.Body.Close()
-
-	if res.StatusCode != 200 {
-		err = fmt.Errorf("OCSP response has status %#v", res.Status)
-		return
-	}
-
-	if res.Header.Get("Content-Type") != "application/ocsp-response" {
-		err = fmt.Errorf("response to OCSP request had unexpected content type")
-		return
-	}
-
-	// Read response, limiting response to 1MiB.
-	rawResponse, err = ioutil.ReadAll(denet.LimitReader(res.Body, 1*1024*1024))
-	if err != nil {
-		return
-	}
-
-	parsedResponse, err = ocsp.ParseResponse(rawResponse, issuer)
-	return
-}
diff --git a/acmeapi/ocsp_test.go b/acmeapi/ocsp_test.go
deleted file mode 100644
index e0e788f..0000000
--- a/acmeapi/ocsp_test.go
+++ /dev/null
@@ -1,86 +0,0 @@
-package acmeapi
-
-import (
-	"crypto/x509"
-	"github.com/hlandau/acme/acmeapi/acmeutils"
-	"golang.org/x/crypto/ocsp"
-	"golang.org/x/net/context"
-	"testing"
-)
-
-const testOCSPCerts = `-----BEGIN CERTIFICATE-----
-MIIE6DCCA9CgAwIBAgITAPr3OLUNFF72kSERFC+leb00HDANBgkqhkiG9w0BAQsF
-ADAfMR0wGwYDVQQDDBRoYXBweSBoYWNrZXIgZmFrZSBDQTAeFw0xNjAxMTcxNjAx
-MDBaFw0xNjA0MTYxNjAxMDBaMB4xHDAaBgNVBAMTE2FxMS5saGguZGV2ZXZlci5u
-ZXQwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDVQT8bs4n6+3QLyehW
-GseFUI+xMMlAM0Mrkol0rB2ZbC4rWanxfqG9TE6i/ToEe+9dL7NxpBKXrRnD/4jK
-cpDxHbGy+hqx/XZefmpdLK2E7FtO53sE0rDcQVGZ2r4YweumfS6jNoNeNZsMzJ6/
-aAeXoz+j+rPJG73NjgWz2BIWwum7AMquq2YeERp3eu5hXQDsZxk6dlNwJ3XVaho7
-EZZojQENm2/BRkpr1oLzq5fMKVc+zRGzuoCJqeYH6yYzWG7oUypW+H477pKDfKLE
-RGwEoTAAx4SS4HwXYrCftFgfmWw6fFV9L8aqON8ypW9CZ5HCprymypcy+6/n/S7k
-ruH3AgMBAAGjggIcMIICGDAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYIKwYB
-BQUHAwEGCCsGAQUFBwMCMAwGA1UdEwEB/wQCMAAwHQYDVR0OBBYEFN/DSOGyPtfc
-1X8rffIJtSocqMzbMB8GA1UdIwQYMBaAFPt4TxL5YBWDLJ8XfzQZsy426kGJMHgG
-CCsGAQUFBwEBBGwwajAzBggrBgEFBQcwAYYnaHR0cDovL29jc3Auc3RhZ2luZy14
-MS5sZXRzZW5jcnlwdC5vcmcvMDMGCCsGAQUFBzAChidodHRwOi8vY2VydC5zdGFn
-aW5nLXgxLmxldHNlbmNyeXB0Lm9yZy8wHgYDVR0RBBcwFYITYXExLmxoaC5kZXZl
-dmVyLm5ldDCB/gYDVR0gBIH2MIHzMAgGBmeBDAECATCB5gYLKwYBBAGC3xMBAQEw
-gdYwJgYIKwYBBQUHAgEWGmh0dHA6Ly9jcHMubGV0c2VuY3J5cHQub3JnMIGrBggr
-BgEFBQcCAjCBngyBm1RoaXMgQ2VydGlmaWNhdGUgbWF5IG9ubHkgYmUgcmVsaWVk
-IHVwb24gYnkgUmVseWluZyBQYXJ0aWVzIGFuZCBvbmx5IGluIGFjY29yZGFuY2Ug
-d2l0aCB0aGUgQ2VydGlmaWNhdGUgUG9saWN5IGZvdW5kIGF0IGh0dHBzOi8vbGV0
-c2VuY3J5cHQub3JnL3JlcG9zaXRvcnkvMA0GCSqGSIb3DQEBCwUAA4IBAQAVkT8U
-oD2AJVjtHogCyt7BkPQ+j6zN1zaN9Bd9nI6a7tpAT6B+j6IqB4o2vCFYawiKaDwR
-ri06Yi9Ohf1QY50D7P21wzfsRoizHbsmHDPPnlDfFe/R1MzB7jYI1JV4LkjWLpuC
-OjTQZs3hIoEbTEBA/TIcwAfS9oMFgk+LgL5B4zQUZgqVp0+A4NNy3J1nBhYC2k2T
-6qiE0CeU8bCfR2V2MZ6Az2X8nwWkWwovosDQR0oOWDcACDbDnS6OPMuHtZi7Wtqn
-UeMJ3YfZ7VBWzJTmDRPoDdbP92YI8FqRGbA6GO/XzyJvkOKSnc3CDfJ9Od0IeVeV
-aC0Q8qLjOhazFhj0
------END CERTIFICATE-----
------BEGIN CERTIFICATE-----
-MIIDETCCAfmgAwIBAgIJAJzxkS6o1QkIMA0GCSqGSIb3DQEBCwUAMB8xHTAbBgNV
-BAMMFGhhcHB5IGhhY2tlciBmYWtlIENBMB4XDTE1MDQwNzIzNTAzOFoXDTI1MDQw
-NDIzNTAzOFowHzEdMBsGA1UEAwwUaGFwcHkgaGFja2VyIGZha2UgQ0EwggEiMA0G
-CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDCCkd5mgXFErJ3F2M0E9dw+Ta/md5i
-8TDId01HberAApqmydG7UZYF3zLTSzNjlNSOmtybvrSGUnZ9r9tSQcL8VM6WUOM8
-tnIpiIjEA2QkBycMwvRmZ/B2ltPdYs/R9BqNwO1g18GDZrHSzUYtNKNeFI6Glamj
-7GK2Vr0SmiEamlNIR5ktAFsEErzf/d4jCF7sosMsJpMCm1p58QkP4LHLShVLXDa8
-BMfVoI+ipYcA08iNUFkgW8VWDclIDxcysa0psDDtMjX3+4aPkE/cefmP+1xOfUuD
-HOGV8XFynsP4EpTfVOZr0/g9gYQ7ZArqXX7GTQkFqduwPm/w5qxSPTarAgMBAAGj
-UDBOMB0GA1UdDgQWBBT7eE8S+WAVgyyfF380GbMuNupBiTAfBgNVHSMEGDAWgBT7
-eE8S+WAVgyyfF380GbMuNupBiTAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBCwUA
-A4IBAQAd9Da+Zv+TjMv7NTAmliqnWHY6d3UxEZN3hFEJ58IQVHbBZVZdW7zhRktB
-vR05Kweac0HJeK91TKmzvXl21IXLvh0gcNLU/uweD3no/snfdB4OoFompljThmgl
-zBqiqWoKBJQrLCA8w5UB+ReomRYd/EYXF/6TAfzm6hr//Xt5mPiUHPdvYt75lMAo
-vRxLSbF8TSQ6b7BYxISWjPgFASNNqJNHEItWsmQMtAjjwzb9cs01XH9pChVAWn9L
-oeMKa+SlHSYrWG93+EcrIH/dGU76uNOiaDzBSKvaehG53h25MHuO1anNICJvZovW
-rFo4Uv1EnkKJm3vJFe50eJGhEKlx
------END CERTIFICATE-----`
-
-func TestOCSP(t *testing.T) {
-	b, err := acmeutils.LoadCertificates([]byte(testOCSPCerts))
-	if err != nil {
-		t.Fatalf("cannot load certificates")
-	}
-
-	c0, err := x509.ParseCertificate(b[0])
-	if err != nil {
-		t.Fatalf("cannot parse certificate")
-	}
-
-	c1, err := x509.ParseCertificate(b[1])
-	if err != nil {
-		t.Fatalf("cannot parse certificate")
-	}
-
-	cl := Client{}
-
-	res, err := cl.CheckOCSP(c0, c1, context.TODO())
-	if err != nil {
-		t.Fatalf("ocsp error: %v", err)
-	}
-
-	if res.Status != ocsp.Revoked {
-		t.Fatalf("ocsp status should be revoked (1) but is %v", res.Status)
-	}
-}
diff --git a/acmeapi/types.go b/acmeapi/types.go
deleted file mode 100644
index 5b8fade..0000000
--- a/acmeapi/types.go
+++ /dev/null
@@ -1,157 +0,0 @@
-package acmeapi
-
-import (
-	"encoding/json"
-	"fmt"
-	"net"
-	"time"
-
-	denet "github.com/hlandau/goutils/net"
-	jose "gopkg.in/square/go-jose.v1"
-)
-
-// Represents an account registration.
-type Registration struct {
-	URI      string `json:"-"`        // The URI of the registration.
-	Resource string `json:"resource"` // must be "new-reg" or "reg"
-
-	Key *jose.JsonWebKey `json:"key,omitempty"` // Account Key
-
-	ContactURIs  []string `json:"contact,omitempty"`   // Contact URIs
-	AgreementURI string   `json:"agreement,omitempty"` // ToS URI
-
-	AuthorizationsURL string `json:"authorizations,omitempty"`
-	CertificatesURL   string `json:"certificates,omitempty"`
-
-	// This is not actually part of the registration, but it
-	// is provided when loading a registration for convenience
-	// as it is returned in the HTTP headers. It is the URI
-	// of the current agreement required.
-	LatestAgreementURI string `json:"-"`
-}
-
-// Represents an error that may have happened.
-// https://tools.ietf.org/html/draft-ietf-appsawg-http-problem-00
-type ProblemDetails struct {
-	Type       string `json:"type,omitempty"`
-	Detail     string `json:"detail,omitempty"`
-	HTTPStatus int    `json:"status,omitempty"`
-}
-
-// Represents a single validation attempt.
-type ValidationRecord struct {
-	Authorities       []string `json:",omitempty"`
-	URL               string   `json:"url,omitempty"`
-	Hostname          string   `json:"hostname"`
-	Port              string   `json:"port"`
-	AddressesResolved []net.IP `json:"addressesResolved"`
-	AddressUsed       net.IP   `json:"addressUsed"`
-	AddressesTried    []net.IP `json:"addressesTried"`
-}
-
-// Represents a Challenge which is part of an Authorization.
-type Challenge struct {
-	URI      string `json:"uri"`      // The URI of the challenge.
-	Resource string `json:"resource"` // "challenge"
-
-	Type      string    `json:"type"`
-	Status    Status    `json:"status,omitempty"`
-	Validated time.Time `json:"validated,omitempty"` // RFC 3339
-	Token     string    `json:"token"`
-
-	// proofOfPossession
-	Certs []denet.Base64up `json:"certs,omitempty"`
-
-	Error                    *ProblemDetails    `json:"error,omitempty"`
-	ProvidedKeyAuthorization string             `json:"keyAuthorization,omitempty"`
-	ValidationRecord         []ValidationRecord `json:"validationRecord,omitempty"`
-
-	retryAt time.Time
-}
-
-// Represents an authorization. You can construct an authorization from only
-// the URI; the authorization information will be fetched automatically.
-type Authorization struct {
-	URI      string `json:"-"`        // The URI of the authorization.
-	Resource string `json:"resource"` // must be "new-authz" or "authz"
-
-	Identifier   Identifier   `json:"identifier"`
-	Status       Status       `json:"status,omitempty"`
-	Expires      time.Time    `json:"expires,omitempty"` // RFC 3339 (ISO 8601)
-	Challenges   []*Challenge `json:"challenges,omitempty"`
-	Combinations [][]int      `json:"combinations,omitempty"`
-
-	retryAt time.Time
-}
-
-// Represents a certificate which has been, or is about to be, issued.
-type Certificate struct {
-	URI      string `json:"-"`        // The URI of the certificate.
-	Resource string `json:"resource"` // "new-cert"
-
-	// The certificate data. DER.
-	Certificate []byte `json:"-"`
-
-	// Any required extra certificates, in DER form in the correct order.
-	ExtraCertificates [][]byte `json:"-"`
-
-	// DER. Consumers of this API will find that this is always nil; it is
-	// used internally when submitting certificate requests.
-	CSR denet.Base64up `json:"csr"`
-
-	retryAt time.Time
-}
-
-// Represents an identifier for which an authorization is desired.
-type Identifier struct {
-	Type  string `json:"type"`  // must be "dns"
-	Value string `json:"value"` // dns: a hostname.
-}
-
-// Represents the status of an authorization or challenge.
-type Status string
-
-const (
-	StatusUnknown    Status = "unknown"    // Non-final state...
-	StatusPending           = "pending"    // Non-final state.
-	StatusProcessing        = "processing" // Non-final state.
-	StatusValid             = "valid"      // Final state.
-	StatusInvalid           = "invalid"    // Final state.
-	StatusRevoked           = "revoked"    // Final state.
-)
-
-// Returns true iff the status is a valid status.
-func (s Status) Valid() bool {
-	switch s {
-	case "unknown", "pending", "processing", "valid", "invalid", "revoked":
-		return true
-	default:
-		return false
-	}
-}
-
-// Returns true iff the status is a final status.
-func (s Status) Final() bool {
-	switch s {
-	case "valid", "invalid", "revoked":
-		return true
-	default:
-		return false
-	}
-}
-
-// Implements encoding/json.Unmarshaler.
-func (s *Status) UnmarshalJSON(data []byte) error {
-	var ss string
-	err := json.Unmarshal(data, &ss)
-	if err != nil {
-		return err
-	}
-
-	if !Status(ss).Valid() {
-		return fmt.Errorf("not a valid status: %#v", ss)
-	}
-
-	*s = Status(ss)
-	return nil
-}
diff --git a/acmeapi/types_test.go b/acmeapi/types_test.go
deleted file mode 100644
index df34be8..0000000
--- a/acmeapi/types_test.go
+++ /dev/null
@@ -1,63 +0,0 @@
-package acmeapi
-
-import (
-	"bytes"
-	"encoding/json"
-	"net"
-	"testing"
-)
-
-func TestStatus(t *testing.T) {
-	var s Status
-	err := json.Unmarshal([]byte(`"pending"`), &s)
-	if err != nil {
-		t.Fatalf("%v", err)
-	}
-	if s != "pending" || !s.Valid() || s.Final() {
-		t.Fatal()
-	}
-	err = json.Unmarshal([]byte(`"f9S0"`), &s)
-	if err == nil {
-		t.Fatal()
-	}
-}
-
-func TestChallenge(t *testing.T) {
-	const cJSON = `{
-  "type": "http-01",
-  "status": "invalid",
-  "error": {
-    "type": "urn:acme:error:caa",
-    "detail": "CAA record for mymonash2021.conference.monash.edu prevents issuance",
-    "status": 403
-  },
-  "uri": "https://acme-v01.api.letsencrypt.org/acme/challenge/wL4hNlUUJtGoMp6QeavoaAZjbqmBgJk2FMpOSC1aoIU/2676511905",
-  "token": "GMgoj5xYX7qSIfN9GdmyqhdAHYrCco_Md9kKrT8v0jE",
-  "keyAuthorization": "GMgoj5xYX7qSIfN9GdmyqhdAHYrCco_Md9kKrT8v0jE.QRRvz3cNxWGJObT4gl6G9ZNx-4cXE2eK81kX5lpYzmo",
-  "validationRecord": [
-    {
-      "url": "http://mysite.foo.com/.well-known/acme-challenge/GMgoj5xYX7qSIfN9GdmyqHdAHYrCco_Md9kKrT8v0jE",
-      "hostname": "mysite.foo.com",
-      "port": "80",
-      "addressesResolved": [
-        "54.85.70.226",
-        "52.21.26.68",
-        "54.210.179.160",
-        "52.1.9.49"
-      ],
-      "addressUsed": "54.85.70.226",
-      "addressesTried": []
-    }
-  ]
-}`
-	var c Challenge
-	if err := json.Unmarshal([]byte(cJSON), &c); err != nil {
-		t.Fatalf("%v", err)
-	}
-	if g, e := c.Error.Type, "urn:acme:error:caa"; g != e {
-		t.Fatalf("%v != %v", g, e)
-	}
-	if g, e := c.ValidationRecord[0].AddressesResolved[1], net.IPv4(52, 21, 26, 68); !bytes.Equal(g, e) {
-		t.Fatalf("%v != %v", g, e)
-	}
-}
diff --git a/acmeapi/util-errors.go b/acmeapi/util-errors.go
deleted file mode 100644
index aad67e1..0000000
--- a/acmeapi/util-errors.go
+++ /dev/null
@@ -1,50 +0,0 @@
-package acmeapi
-
-import (
-	"fmt"
-	denet "github.com/hlandau/goutils/net"
-	"io/ioutil"
-	"net/http"
-)
-
-// Error returned when the account agreement URI does not match the currently required
-// agreement URI.
-type AgreementError struct {
-	URI string // The required agreement URI.
-}
-
-func (e *AgreementError) Error() string {
-	return fmt.Sprintf("Registration requires agreement with the following agreement: %#v", e.URI)
-}
-
-// Error returned when an HTTP request results in a valid response, but which
-// has an unexpected failure status code. Used so that the response can still
-// be examined if desired.
-type HTTPError struct {
-	// The HTTP response.
-	Res *http.Response
-
-	// If the response had an application/problem+json response body, this is
-	// that JSON data.
-	ProblemBody string
-}
-
-// Summarises the response status, headers, and the JSON problem body if
-// available.
-func (he *HTTPError) Error() string {
-	return fmt.Sprintf("HTTP error: %v\n%v\n%v", he.Res.Status, he.Res.Header, he.ProblemBody)
-}
-
-func newHTTPError(res *http.Response) error {
-	he := &HTTPError{
-		Res: res,
-	}
-	if res.Header.Get("Content-Type") == "application/problem+json" {
-		defer res.Body.Close()
-		b, err := ioutil.ReadAll(denet.LimitReader(res.Body, 1*1024*1024))
-		if err == nil {
-			he.ProblemBody = string(b)
-		}
-	}
-	return he
-}
diff --git a/acmeapi/util-retry.go b/acmeapi/util-retry.go
deleted file mode 100644
index 1f9b5f5..0000000
--- a/acmeapi/util-retry.go
+++ /dev/null
@@ -1,72 +0,0 @@
-package acmeapi
-
-import (
-	"github.com/hlandau/goutils/clock"
-	"golang.org/x/net/context"
-	"net/http"
-	"strconv"
-	"time"
-)
-
-var defaultClock = clock.Real
-
-func parseRetryAfter(h http.Header) (t time.Time, ok bool) {
-	v := h.Get("Retry-After")
-	if v == "" {
-		return time.Time{}, false
-	}
-
-	n, err := strconv.ParseUint(v, 10, 31)
-	if err != nil {
-		t, err = time.Parse(time.RFC1123, v)
-		if err != nil {
-			return time.Time{}, false
-		}
-
-		return t, true
-	}
-
-	return defaultClock.Now().Add(time.Duration(n) * time.Second), true
-}
-
-func retryAtDefault(h http.Header, d time.Duration) time.Time {
-	t, ok := parseRetryAfter(h)
-	if ok {
-		return t
-	}
-
-	return defaultClock.Now().Add(d)
-}
-
-// Wait until time t. If t is before the current time, returns immediately.
-// Cancellable via ctx, in which case err is passed through. Otherwise returns
-// nil.
-func waitUntil(t time.Time, ctx context.Context) error {
-	var ch <-chan time.Time
-	ch = closedChannel
-	now := defaultClock.Now()
-	if t.After(now) {
-		ch = defaultClock.After(t.Sub(now))
-	}
-
-	// make sure ctx.Done() is checked here even when we are using closedChannel,
-	// as select doesn't guarantee any particular priority.
-	select {
-	case <-ctx.Done():
-		return ctx.Err()
-	default:
-		select {
-		case <-ctx.Done():
-			return ctx.Err()
-		case <-ch:
-		}
-	}
-
-	return nil
-}
-
-var closedChannel = make(chan time.Time)
-
-func init() {
-	close(closedChannel)
-}
diff --git a/acmeapi/util-retry_test.go b/acmeapi/util-retry_test.go
deleted file mode 100644
index 04f0fef..0000000
--- a/acmeapi/util-retry_test.go
+++ /dev/null
@@ -1,111 +0,0 @@
-package acmeapi
-
-import (
-	"github.com/hlandau/goutils/clock"
-	"golang.org/x/net/context"
-	"net/http"
-	"testing"
-	"time"
-)
-
-func withClock(cl clock.Clock, f func()) {
-	origClock := defaultClock
-	defer func() {
-		defaultClock = origClock
-	}()
-
-	defaultClock = cl
-	f()
-}
-
-var clk clock.Fake
-var slowClk clock.Fake
-
-func init() {
-	refTime, _ := time.Parse(time.RFC3339, "2009-10-11T11:09:06Z")
-	clk = clock.NewFastAt(refTime)
-	slowClk = clock.NewSlowAt(refTime)
-}
-
-func TestRetryAfter(t *testing.T) {
-	withClock(clk, func() {
-		h := http.Header{}
-		t1, ok := parseRetryAfter(h)
-		if ok {
-			t.Fatal()
-		}
-
-		h.Set("Retry-After", "Mon, 02 Jan 2006 15:04:05 UTC")
-		t1 = retryAtDefault(h, 1*time.Second)
-		tref, _ := time.Parse("Mon, 02 Jan 2006 15:04:05 UTC", "Mon, 02 Jan 2006 15:04:05 UTC")
-		if t1 != tref || tref.IsZero() {
-			t.Fatal()
-		}
-
-		t2, _ := time.Parse(time.RFC3339, "2006-01-02T15:04:05Z")
-		if t1 != t2 {
-			t.Fatalf("%v %v", t1, t2)
-		}
-
-		h.Set("Retry-After", "20")
-		t1, ok = parseRetryAfter(h)
-		now := defaultClock.Now()
-		if !ok {
-			t.Fatal()
-		}
-		d := now.Add(20 * time.Second).Sub(t1)
-		if d != 0 {
-			t.Fatalf("%v", d)
-		}
-
-		h.Set("Retry-After", "Mon 02 Jan 2006 15:04:05 UTC")
-		t1, ok = parseRetryAfter(h)
-		if ok || !t1.IsZero() {
-			t.Fatal()
-		}
-	})
-}
-
-func TestRetryAfterDefault(t *testing.T) {
-	withClock(clk, func() {
-		h := http.Header{}
-		t1 := retryAtDefault(h, 42*time.Second)
-		now := defaultClock.Now()
-		d := now.Add(42 * time.Second).Sub(t1)
-		if d != 0 {
-			t.Fatalf("%v", d)
-		}
-	})
-}
-
-func TestWaitUntil(t *testing.T) {
-	withClock(clk, func() {
-		tgt := defaultClock.Now().Add(49828 * time.Millisecond)
-		waitUntil(tgt, context.TODO())
-		if defaultClock.Now().Sub(tgt) != 0 {
-			t.Fatalf("%v", defaultClock.Now().Sub(tgt))
-		}
-	})
-
-	withClock(slowClk, func() {
-		tgt := defaultClock.Now().Add(49828 * time.Millisecond)
-		ctx, _ := context.WithTimeout(context.TODO(), 10*time.Millisecond)
-		err := waitUntil(tgt, ctx)
-		if err == nil {
-			t.Fatal()
-		}
-
-		ctx, cancel := context.WithCancel(context.TODO())
-		cancel()
-		err = waitUntil(tgt, ctx)
-		if err == nil {
-			t.Fatal()
-		}
-
-		slowClk.Advance(49829 * time.Millisecond)
-		err = waitUntil(tgt, context.TODO())
-		if err != nil {
-			t.Fatal()
-		}
-	})
-}
diff --git a/cmd/acmetool/doc.go b/cli/doc.go
similarity index 95%
rename from cmd/acmetool/doc.go
rename to cli/doc.go
index 573abf0..d06775d 100644
--- a/cmd/acmetool/doc.go
+++ b/cli/doc.go
@@ -1,8 +1,8 @@
-package main
+package cli
 
 import (
 	"fmt"
-	"github.com/hlandau/acme/storage"
+	"git.devever.net/hlandau/acmetool/storage"
 	"gopkg.in/alecthomas/kingpin.v2"
 )
 
@@ -52,7 +52,7 @@ const manPageTemplate = `{{define "FormatFlags"}}\
 .SH "SEE ALSO"
 Documentation: <https://github.com/hlandau/acme>
 
-Report bugs at: <https://github.com/hlandau/acme/issues>
+Report bugs at: <https://git.devever.net/hlandau/acmetool/issues>
 `
 
 var helpText = fmt.Sprintf(`acmetool is a utility for the automated retrieval, management and renewal of
diff --git a/cli/main.go b/cli/main.go
new file mode 100644
index 0000000..dc1a3ba
--- /dev/null
+++ b/cli/main.go
@@ -0,0 +1,522 @@
+// Package cli is the command-line interface driver for acmetool. Everything begins here.
+package cli
+
+import (
+	"bytes"
+	"fmt"
+	"io/ioutil"
+	"os"
+	"path/filepath"
+	"strings"
+	"syscall"
+
+	"git.devever.net/hlandau/acmeapi"
+	"git.devever.net/hlandau/acmeapi/acmeutils"
+	"git.devever.net/hlandau/acmetool/hooks"
+	"git.devever.net/hlandau/acmetool/interaction"
+	"git.devever.net/hlandau/acmetool/redirector"
+	"git.devever.net/hlandau/acmetool/responder"
+	"git.devever.net/hlandau/acmetool/storage"
+	"git.devever.net/hlandau/acmetool/storageops"
+	"github.com/hlandau/dexlogconfig"
+	"github.com/hlandau/xlog"
+	"gopkg.in/alecthomas/kingpin.v2"
+	"gopkg.in/hlandau/easyconfig.v1/adaptflag"
+	"gopkg.in/hlandau/service.v2"
+	"gopkg.in/square/go-jose.v1"
+	"gopkg.in/yaml.v2"
+)
+
+var log, Log = xlog.New("acmetool")
+
+var (
+	stateFlag = kingpin.Flag("state", "Path to the state directory (env: ACME_STATE_DIR)").
+			Default(storage.RecommendedPath).
+			Envar("ACME_STATE_DIR").
+			PlaceHolder(storage.RecommendedPath).
+			String()
+
+	hooksFlag = kingpin.Flag("hooks", "Path to the notification hooks directory (env: ACME_HOOKS_DIR)").
+			Default(hooks.RecommendedPaths...).
+			PlaceHolder(hooks.RecommendedPaths[0]).
+			Envar("ACME_HOOKS_DIR").
+			Strings()
+
+	batchFlag = kingpin.Flag("batch", "Do not attempt interaction; useful for cron jobs. (acmetool can still obtain responses from a response file, if one was provided.)").
+			Bool()
+
+	stdioFlag = kingpin.Flag("stdio", "Don't attempt to use console dialogs; fall back to stdio prompts").Bool()
+
+	responseFileFlag = kingpin.Flag("response-file", "Read dialog responses from the given file (default: $ACME_STATE_DIR/conf/responses)").ExistingFile()
+
+	reconcileCmd     = kingpin.Command("reconcile", reconcileHelp).Default()
+	reconcileSpecArg = reconcileCmd.Arg("target-filenames", "optionally, specify one or more target file paths or filenames to reconcile only those targets").Strings()
+
+	cullCmd          = kingpin.Command("cull", "Delete expired, unused certificates")
+	cullSimulateFlag = cullCmd.Flag("simulate", "Show which certificates would be deleted without deleting any").Short('n').Bool()
+
+	statusCmd = kingpin.Command("status", "Show active configuration")
+
+	wantCmd       = kingpin.Command("want", "Add a target with one or more hostnames")
+	wantReconcile = wantCmd.Flag("reconcile", "Specify --no-reconcile to skip reconcile after adding target").Default("1").Bool()
+	wantArg       = wantCmd.Arg("hostname", "hostnames for which a certificate should be obtained").Required().Strings()
+
+	unwantCmd = kingpin.Command("unwant", "Modify targets to remove any mentions of the given hostnames")
+	unwantArg = unwantCmd.Arg("hostname", "hostnames which should be removed from all target files").Required().Strings()
+
+	quickstartCmd = kingpin.Command("quickstart", "Interactively ask some getting started questions (recommended)")
+	expertFlag    = quickstartCmd.Flag("expert", "Ask more questions in quickstart wizard").Bool()
+
+	redirectorCmd            = kingpin.Command("redirector", "HTTP to HTTPS redirector with challenge response support")
+	redirectorPathFlag       = redirectorCmd.Flag("path", "Path to serve challenge files from").String()
+	redirectorGIDFlag        = redirectorCmd.Flag("challenge-gid", "GID to chgrp the challenge path to (optional)").String()
+	redirectorReadTimeout    = redirectorCmd.Flag("read-timeout", "Maximum duration before timing out read of the request (default: '10s')").Default("10s").Duration()
+	redirectorWriteTimeout   = redirectorCmd.Flag("write-timeout", "Maximum duration before timing out write of the request (default: '20s')").Default("20s").Duration()
+	redirectorStatusCodeFlag = redirectorCmd.Flag("status-code", "HTTP status code to use when redirecting (default '308')").Default("308").Int()
+	redirectorBindFlag       = redirectorCmd.Flag("bind", "Bind address for redirectory (default ':80')").Default(":80").String()
+
+	testNotifyCmd = kingpin.Command("test-notify", "Test-execute notification hooks as though given hostnames were updated")
+	testNotifyArg = testNotifyCmd.Arg("hostname", "hostnames which have been updated").Strings()
+
+	importJWKAccountCmd = kingpin.Command("import-jwk-account", "Import a JWK account key")
+	importJWKURLArg     = importJWKAccountCmd.Arg("provider-url", "Provider URL (e.g. https://acme-v01.api.letsencrypt.org/directory)").Required().String()
+	importJWKPathArg    = importJWKAccountCmd.Arg("private-key-file", "Path to private_key.json").Required().ExistingFile()
+
+	importPEMAccountCmd = kingpin.Command("import-pem-account", "Import a PEM account key")
+	importPEMURLArg     = importPEMAccountCmd.Arg("provider-url", "Provider URL (e.g. https://acme-v01.api.letsencrypt.org/directory)").Required().String()
+	importPEMPathArg    = importPEMAccountCmd.Arg("private-key-file", "Path to private key PEM file").Required().ExistingFile()
+
+	importKeyCmd = kingpin.Command("import-key", "Import a certificate private key")
+	importKeyArg = importKeyCmd.Arg("private-key-file", "Path to PEM-encoded private key").Required().ExistingFile()
+
+	importLECmd = kingpin.Command("import-le", "Import a Let's Encrypt client state directory")
+	importLEArg = importLECmd.Arg("le-state-path", "Path to Let's Encrypt state directory").Default("/etc/letsencrypt").ExistingDir()
+
+	// Arguments we should probably support for revocation:
+	//   A certificate ID
+	//   A key ID
+	//   A path to a PEM-encoded certificate - TODO
+	//   A path to a PEM-encoded private key (revoke all known certificates with that key) - TODO
+	//   A path to a certificate directory - TODO
+	//   A path to a key directory - TODO
+	//   A certificate URL - TODO
+	revokeCmd = kingpin.Command("revoke", "Revoke a certificate")
+	revokeArg = revokeCmd.Arg("certificate-id-or-path", "Certificate ID to revoke").String()
+
+	accountThumbprintCmd = kingpin.Command("account-thumbprint", "Prints account thumbprints")
+)
+
+const reconcileHelp = `Reconcile ACME state, idempotently requesting and renewing certificates to satisfy configured targets.
+
+This is the default command.`
+
+// Main entrypoint for the command line tool.
+func Main() {
+	syscall.Umask(0) // make sure webroot files can be world-readable
+
+	adaptflag.Adapt()
+	cmd := kingpin.Parse()
+
+	var err error
+	*stateFlag, err = filepath.Abs(*stateFlag)
+	log.Fatale(err, "state directory path")
+
+	hooksSlice := *hooksFlag
+	for i := range hooksSlice {
+		hooksSlice[i], err = filepath.Abs(hooksSlice[i])
+		log.Fatale(err, "hooks directory path")
+	}
+
+	hooks.DefaultPaths = hooksSlice
+	acmeapi.UserAgent = "acmetool"
+	dexlogconfig.Init()
+
+	if *batchFlag {
+		interaction.NonInteractive = true
+	}
+
+	if *stdioFlag {
+		interaction.NoDialog = true
+	}
+
+	if *responseFileFlag == "" {
+		p := filepath.Join(*stateFlag, "conf/responses")
+		if _, err := os.Stat(p); err == nil {
+			*responseFileFlag = p
+		}
+	}
+
+	if *responseFileFlag != "" {
+		err := loadResponseFile(*responseFileFlag)
+		log.Errore(err, "cannot load response file, continuing anyway")
+	}
+
+	switch cmd {
+	case "reconcile":
+		cmdReconcile()
+	case "cull":
+		cmdCull()
+	case "status":
+		cmdStatus()
+	case "account-thumbprint":
+		cmdAccountThumbprint()
+	case "want":
+		cmdWant()
+		if *wantReconcile {
+			cmdReconcile()
+		}
+	case "unwant":
+		cmdUnwant()
+	case "quickstart":
+		cmdQuickstart()
+	case "redirector":
+		cmdRunRedirector()
+	case "test-notify":
+		cmdRunTestNotify()
+	case "import-key":
+		cmdImportKey()
+	case "import-jwk-account":
+		cmdImportJWKAccount()
+	case "import-pem-account":
+		cmdImportPEMAccount()
+	case "revoke":
+		cmdRevoke()
+	}
+}
+
+func cmdImportJWKAccount() {
+	s, err := storage.NewFDB(*stateFlag)
+	log.Fatale(err, "storage")
+
+	f, err := os.Open(*importJWKPathArg)
+	log.Fatale(err, "cannot open private key file")
+	defer f.Close()
+
+	b, err := ioutil.ReadAll(f)
+	log.Fatale(err, "cannot read file")
+
+	k := jose.JsonWebKey{}
+	err = k.UnmarshalJSON(b)
+	log.Fatale(err, "cannot unmarshal key")
+
+	_, err = s.ImportAccount(*importJWKURLArg, k.Key)
+	log.Fatale(err, "cannot import account key")
+}
+
+func cmdImportPEMAccount() {
+	s, err := storage.NewFDB(*stateFlag)
+	log.Fatale(err, "storage")
+
+	f, err := os.Open(*importPEMPathArg)
+	log.Fatale(err, "cannot open private key file")
+	defer f.Close()
+
+	b, err := ioutil.ReadAll(f)
+	log.Fatale(err, "cannot read file")
+
+	pk, err := acmeutils.LoadPrivateKey(b)
+	log.Fatale(err, "cannot parse private key")
+
+	_, err = s.ImportAccount(*importPEMURLArg, pk)
+	log.Fatale(err, "cannot import account key")
+}
+
+func cmdImportKey() {
+	s, err := storage.NewFDB(*stateFlag)
+	log.Fatale(err, "storage")
+
+	err = importKey(s, *importKeyArg)
+	log.Fatale(err, "import key")
+}
+
+func cmdReconcile() {
+	s, err := storage.NewFDB(*stateFlag)
+	log.Fatale(err, "storage")
+
+	err = storageops.Reconcile(s, storageops.ReconcileConfig{
+		Targets: *reconcileSpecArg,
+	})
+	log.Fatale(err, "reconcile")
+}
+
+func cmdCull() {
+	s, err := storage.NewFDB(*stateFlag)
+	log.Fatale(err, "storage")
+
+	err = storageops.Cull(s, *cullSimulateFlag)
+	log.Fatale(err, "cull")
+}
+
+func cmdStatus() {
+	s, err := storage.NewFDB(*stateFlag)
+	log.Fatale(err, "storage")
+
+	info := StatusString(s)
+	log.Fatale(err, "status")
+
+	fmt.Print(info)
+}
+
+func importKey(s storage.Store, filename string) error {
+	b, err := ioutil.ReadFile(filename)
+	if err != nil {
+		return err
+	}
+
+	pk, err := acmeutils.LoadPrivateKey(b)
+	if err != nil {
+		return err
+	}
+
+	_, err = s.ImportKey(pk)
+	return err
+}
+
+func StatusString(s storage.Store) string {
+	var buf bytes.Buffer
+	fmt.Fprintf(&buf, "Settings:\n")
+	fmt.Fprintf(&buf, "  ACME_STATE_DIR: %s\n", s.Path())
+	fmt.Fprintf(&buf, "  ACME_HOOKS_DIR: %s\n", strings.Join(hooks.DefaultPaths, "; "))
+	fmt.Fprintf(&buf, "  Default directory URL: %s\n", s.DefaultTarget().Request.Provider)
+	fmt.Fprintf(&buf, "  Preferred key type: %v\n", &s.DefaultTarget().Request.Key)
+	fmt.Fprintf(&buf, "  Additional webroots:\n")
+	for _, wr := range s.DefaultTarget().Request.Challenge.WebrootPaths {
+		fmt.Fprintf(&buf, "    %s\n", wr)
+	}
+
+	fmt.Fprintf(&buf, "\nAvailable accounts:\n")
+	s.VisitAccounts(func(a *storage.Account) error {
+		fmt.Fprintf(&buf, "  %v\n", a)
+		thumbprint, _ := acmeutils.Base64Thumbprint(a.PrivateKey)
+		fmt.Fprintf(&buf, "    thumbprint: %s\n", thumbprint)
+		return nil
+	})
+
+	fmt.Fprintf(&buf, "\n")
+	s.VisitTargets(func(t *storage.Target) error {
+		fmt.Fprintf(&buf, "%v\n", t)
+
+		c, err := storageops.FindBestCertificateSatisfying(s, t)
+		if err != nil {
+			fmt.Fprintf(&buf, "  error: %v\n", err)
+			return nil // continue
+		}
+
+		renewStr := ""
+		if storageops.CertificateNeedsRenewing(c, t) {
+			renewStr = " needs-renewing"
+		}
+
+		fmt.Fprintf(&buf, "  best: %v%s\n", c, renewStr)
+		return nil
+	})
+
+	if storageops.HaveUncachedCertificates(s) {
+		fmt.Fprintf(&buf, "\nThere are uncached certificates.\n")
+	}
+
+	return buf.String()
+}
+
+func cmdAccountThumbprint() {
+	s, err := storage.NewFDB(*stateFlag)
+	log.Fatale(err, "storage")
+
+	s.VisitAccounts(func(a *storage.Account) error {
+		thumbprint, _ := acmeutils.Base64Thumbprint(a.PrivateKey)
+		fmt.Printf("%s\t%s\n", thumbprint, a.ID())
+		return nil
+	})
+}
+
+func cmdWant() {
+	hostnames := *wantArg
+
+	// Ensure all hostnames provided are valid.
+	for idx := range hostnames {
+		norm, err := acmeutils.NormalizeHostname(hostnames[idx])
+		if err != nil {
+			log.Fatalf("invalid hostname: %#v: %v", hostnames[idx], err)
+			return
+		}
+		hostnames[idx] = norm
+	}
+
+	// Determine whether there already exists a target satisfying all given
+	// hostnames or a superset thereof.
+	s, err := storage.NewFDB(*stateFlag)
+	log.Fatale(err, "storage")
+
+	alreadyExists := false
+	s.VisitTargets(func(t *storage.Target) error {
+		nm := map[string]struct{}{}
+		for _, n := range t.Satisfy.Names {
+			nm[n] = struct{}{}
+		}
+
+		for _, w := range hostnames {
+			if _, ok := nm[w]; !ok {
+				return nil
+			}
+		}
+
+		alreadyExists = true
+		return nil
+	})
+
+	if alreadyExists {
+		return
+	}
+
+	// Add the target.
+	tgt := storage.Target{
+		Satisfy: storage.TargetSatisfy{
+			Names: hostnames,
+		},
+	}
+
+	err = s.SaveTarget(&tgt)
+	log.Fatale(err, "add target")
+}
+
+func cmdUnwant() {
+	s, err := storage.NewFDB(*stateFlag)
+	log.Fatale(err, "storage")
+
+	for _, hn := range *unwantArg {
+		err = storageops.RemoveTargetHostname(s, hn)
+		log.Fatale(err, "remove target hostname ", hn)
+	}
+}
+
+func cmdRunRedirector() {
+	// redirector process is internet-facing and must never touch private keys
+	storage.Neuter()
+
+	rpath := *redirectorPathFlag
+	if rpath == "" {
+		rpath = determineWebroot()
+	}
+
+	service.Main(&service.Info{
+		Name:          "acmetool",
+		Description:   "acmetool HTTP redirector",
+		DefaultChroot: rpath,
+		NewFunc: func() (service.Runnable, error) {
+			return redirector.New(redirector.Config{
+				Bind:          *redirectorBindFlag,
+				ChallengePath: rpath,
+				ChallengeGID:  *redirectorGIDFlag,
+				ReadTimeout:   *redirectorReadTimeout,
+				WriteTimeout:  *redirectorWriteTimeout,
+				StatusCode:    *redirectorStatusCodeFlag,
+			})
+		},
+	})
+}
+
+func determineWebroot() string {
+	s, err := storage.NewFDB(*stateFlag)
+	log.Fatale(err, "storage")
+
+	webrootPaths := s.DefaultTarget().Request.Challenge.WebrootPaths
+	if len(webrootPaths) > 0 {
+		return webrootPaths[0]
+	}
+
+	return responder.StandardWebrootPath
+}
+
+func cmdRunTestNotify() {
+	ctx := &hooks.Context{
+		HookDirs: *hooksFlag,
+		StateDir: *stateFlag,
+	}
+	err := hooks.NotifyLiveUpdated(ctx, *testNotifyArg)
+	log.Errore(err, "notify")
+}
+
+// YAML response file loading.
+
+func loadResponseFile(path string) error {
+	b, err := ioutil.ReadFile(path)
+	if err != nil {
+		return err
+	}
+
+	m := map[string]interface{}{}
+	err = yaml.Unmarshal(b, &m)
+	if err != nil {
+		return err
+	}
+
+	for k, v := range m {
+		r, err := parseResponse(v)
+		if err != nil {
+			log.Errore(err, "response for ", k, " invalid")
+			continue
+		}
+		interaction.SetResponse(k, r)
+	}
+
+	return nil
+}
+
+func parseResponse(v interface{}) (*interaction.Response, error) {
+	switch x := v.(type) {
+	case string:
+		return &interaction.Response{
+			Value: x,
+		}, nil
+	case int:
+		return &interaction.Response{
+			Value: fmt.Sprintf("%d", x),
+		}, nil
+	case bool:
+		return &interaction.Response{
+			Cancelled: !x,
+		}, nil
+	default:
+		return nil, fmt.Errorf("unknown response value")
+	}
+}
+
+func cmdRevoke() {
+	certSpec := *revokeArg
+	f, _ := os.Open(certSpec)
+	//var fi os.FileInfo
+	if f != nil {
+		defer f.Close()
+		//var err error
+		//fi, err = f.Stat()
+		//log.Panice(err)
+	}
+	//u, _ := url.Parse(certSpec)
+
+	switch {
+	//case f != nil && !fi.IsDir(): // is a file path
+
+	//case f != nil && fi.IsDir(): // is a directory path
+	//  f, _ = os.Open(filepath.Join(certSpec, "cert"))
+
+	//case u != nil && u.IsAbs() && acmeapi.ValidURL(certSpec): // is an URL
+
+	case storage.IsWellFormattedCertificateOrKeyID(certSpec):
+		// key or certificate ID
+		revokeByCertificateID(certSpec)
+
+	default:
+		log.Fatalf("don't understand argument, must be a certificate or key ID: %q", certSpec)
+	}
+}
+
+func revokeByCertificateID(certID string) {
+	s, err := storage.NewFDB(*stateFlag)
+	log.Fatale(err, "storage")
+
+	err = storageops.RevokeByCertificateOrKeyID(s, certID)
+	log.Fatale(err, "revoke")
+
+	err = storageops.Reconcile(s, storageops.ReconcileConfig{})
+	log.Fatale(err, "reconcile")
+}
diff --git a/cmd/acmetool/main_ig_test.go b/cli/main_ig_test.go
similarity index 78%
rename from cmd/acmetool/main_ig_test.go
rename to cli/main_ig_test.go
index b12d1d8..fea7a2f 100644
--- a/cmd/acmetool/main_ig_test.go
+++ b/cli/main_ig_test.go
@@ -1,12 +1,14 @@
 // +build integration
 
-package main
+package cli
 
 import (
 	"fmt"
-	"github.com/hlandau/acme/acmeapi"
-	"github.com/hlandau/acme/interaction"
-	"github.com/hlandau/acme/responder"
+	//"git.devever.net/hlandau/acmeapi"
+	"git.devever.net/hlandau/acmeapi/pebbletest"
+	"git.devever.net/hlandau/acmetool/interaction"
+	"git.devever.net/hlandau/acmetool/responder"
+	"git.devever.net/hlandau/acmetool/storageops"
 	"io/ioutil"
 	"path/filepath"
 	"strings"
@@ -21,7 +23,7 @@ func (i *interceptor) Prompt(c *interaction.Challenge) (*interaction.Response, e
 	case "acmetool-quickstart-choose-server":
 		return &interaction.Response{Value: "url"}, nil
 	case "acmetool-quickstart-enter-directory-url":
-		return &interaction.Response{Value: "http://127.0.0.1:4000/directory"}, nil
+		return &interaction.Response{Value: "https://127.0.0.1:14000/dir"}, nil
 	case "acmetool-quickstart-choose-method":
 		return &interaction.Response{Value: "redirector"}, nil
 	case "acme-enter-email":
@@ -46,7 +48,8 @@ func (i *interceptor) Status(info *interaction.StatusInfo) (interaction.StatusSi
 func TestCLI(t *testing.T) {
 	log.Warnf("This test requires a configured Boulder instance listening at http://127.0.0.1:4000/ and the ability to successfully complete challenges. You must change the Boulder configuration to use ports 80 and 5001. Also change the rate limits per certificate name. Consider ensuring that the user you run these tests as can write to %s and that that directory is served on port 80 /.well-known/acme-challenge/", responder.StandardWebrootPath)
 
-	acmeapi.TestingAllowHTTP = true
+	//acmeapi.TestingAllowHTTP = true
+	storageops.InternalHTTPClient = pebbletest.HTTPClient
 
 	interaction.Interceptor = &interceptor{}
 
@@ -56,9 +59,10 @@ func TestCLI(t *testing.T) {
 	}
 
 	*stateFlag = filepath.Join(tmpDir, "state")
-	*hooksFlag = filepath.Join(tmpDir, "hooks")
+	*hooksFlag = []string{filepath.Join(tmpDir, "hooks")}
 
-	responder.InternalTLSSNIPort = 5001
+	responder.InternalHTTPPort = 5002
+	//responder.InternalTLSSNIPort = 5001
 	cmdQuickstart()
 
 	*wantArg = []string{"dom1.acmetool-test.devever.net", "dom2.acmetool-test.devever.net"}
diff --git a/cmd/acmetool/quickstart-linux.go b/cli/quickstart-linux.go
similarity index 98%
rename from cmd/acmetool/quickstart-linux.go
rename to cli/quickstart-linux.go
index 0ab1554..d14ca7f 100644
--- a/cmd/acmetool/quickstart-linux.go
+++ b/cli/quickstart-linux.go
@@ -1,12 +1,12 @@
 // +build linux
 
-package main
+package cli
 
 import (
 	"fmt"
+	"git.devever.net/hlandau/acmetool/interaction"
 	sddbus "github.com/coreos/go-systemd/dbus"
 	sdunit "github.com/coreos/go-systemd/unit"
-	"github.com/hlandau/acme/interaction"
 	"gopkg.in/hlandau/svcutils.v1/exepath"
 	"gopkg.in/hlandau/svcutils.v1/systemd" // coreos/go-systemd/util requires cgo
 	"io"
diff --git a/cmd/acmetool/quickstart-nlinux.go b/cli/quickstart-nlinux.go
similarity index 77%
rename from cmd/acmetool/quickstart-nlinux.go
rename to cli/quickstart-nlinux.go
index 11af503..1726720 100644
--- a/cmd/acmetool/quickstart-nlinux.go
+++ b/cli/quickstart-nlinux.go
@@ -1,6 +1,6 @@
 // +build !linux
 
-package main
+package cli
 
 func promptSystemd() {
 }
diff --git a/cmd/acmetool/quickstart.go b/cli/quickstart.go
similarity index 95%
rename from cmd/acmetool/quickstart.go
rename to cli/quickstart.go
index 3688e2a..776c81a 100644
--- a/cmd/acmetool/quickstart.go
+++ b/cli/quickstart.go
@@ -1,21 +1,22 @@
-package main
+package cli
 
 import (
 	"bytes"
 	"crypto/rand"
 	"fmt"
-	"github.com/hlandau/acme/acmeapi"
-	"github.com/hlandau/acme/acmeapi/acmeendpoints"
-	"github.com/hlandau/acme/hooks"
-	"github.com/hlandau/acme/interaction"
-	"github.com/hlandau/acme/storage"
-	"github.com/hlandau/acme/storageops"
+	"git.devever.net/hlandau/acmeapi"
+	"git.devever.net/hlandau/acmeapi/acmeendpoints"
+	"git.devever.net/hlandau/acmetool/hooks"
+	"git.devever.net/hlandau/acmetool/interaction"
+	"git.devever.net/hlandau/acmetool/storage"
+	"git.devever.net/hlandau/acmetool/storageops"
 	"gopkg.in/hlandau/svcutils.v1/exepath"
 	"gopkg.in/hlandau/svcutils.v1/passwd"
 	"io/ioutil"
 	"os"
 	"os/exec"
 	"path/filepath"
+	"reflect"
 	"strconv"
 	"strings"
 )
@@ -116,7 +117,7 @@ set -e
 EVENT_NAME="$1"
 [ "$EVENT_NAME" = "live-updated" ] || exit 42
 
-SERVICES="httpd apache2 apache nginx tengine lighttpd postfix dovecot exim exim4 haproxy hitch quassel quasselcore"
+SERVICES="httpd apache2 apache nginx tengine lighttpd postfix dovecot exim exim4 haproxy hitch quassel quasselcore freeswitch"
 [ -e "/etc/default/acme-reload" ] && . /etc/default/acme-reload
 [ -e "/etc/conf.d/acme-reload" ] && . /etc/conf.d/acme-reload
 [ -z "$ACME_STATE_DIR" ] && ACME_STATE_DIR="@@ACME_STATE_DIR@@"
@@ -215,7 +216,7 @@ EVENT_NAME="$1"
 
 # List of services. If any of these are in PATH (or HAPROXY_ALWAYS_GENERATE is
 # set), assume we need to generate combined files.
-HAPROXY_DAEMONS="haproxy hitch quasselcore quassel lighttpd"
+HAPROXY_DAEMONS="haproxy hitch quasselcore quassel lighttpd freeswitch"
 HAPROXY_UMASK="0077"
 
 [ -e "/etc/default/acme-reload" ] && . /etc/default/acme-reload
@@ -330,8 +331,10 @@ func formulateCron(root bool) string {
 	if *stateFlag != storage.RecommendedPath {
 		s += fmt.Sprintf(`--state="%s" `, *stateFlag)
 	}
-	if *hooksFlag != hooks.RecommendedPath {
-		s += fmt.Sprintf(`--hooks="%s" `, *hooksFlag)
+	if !reflect.DeepEqual(*hooksFlag, hooks.RecommendedPaths) {
+		for _, hookDir := range *hooksFlag {
+			s += fmt.Sprintf(`--hooks="%s" `, hookDir)
+		}
 	}
 
 	s += "reconcile\n"
@@ -433,12 +436,12 @@ func setUserCron(b []byte) error {
 
 func promptInstallCombinedHooks() bool {
 	// Always install if the hook is already installed.
-	hooksPath := *hooksFlag
-	if hooksPath == "" {
-		hooksPath = hooks.DefaultPath
+	hooksPaths := *hooksFlag
+	if len(hooksPaths) == 0 {
+		hooksPaths = hooks.DefaultPaths
 	}
 
-	if _, err := os.Stat(filepath.Join(hooksPath, "haproxy")); err == nil {
+	if hooks.Exists(hooksPaths, "haproxy") {
 		return true
 	}
 
@@ -454,7 +457,7 @@ These files will also be accessible in a directory of their own, "%s/haproxy/HOS
 If you place a PEM-encoded DH parameter file at "%s/conf/dhparams", those will also be included in each
 "haproxy" file. This is optional.
 
-Examples of daemons requiring combined files include HAProxy, Hitch and Quassel. The hook script will not generate the files unless one of these daemons is detected, or you configure it to always generate combined files. (See the hook script for configuration documentation.) Therefore, installing the script is a no-op on systems without these daemons installed, and it is always safe to say yes here.
+Examples of daemons requiring combined files include HAProxy, Hitch, Quassel, Freeswitch. The hook script will not generate the files unless one of these daemons is detected, or you configure it to always generate combined files. (See the hook script for configuration documentation.) Therefore, installing the script is a no-op on systems without these daemons installed, and it is always safe to say yes here.
 
 Do you want to install the combined file generation hook? If in doubt, say yes.`,
 			*stateFlag, *stateFlag, *stateFlag),
@@ -654,7 +657,7 @@ func promptGettingStarted() {
 		"Quickstart Complete",
 		fmt.Sprintf(`The quickstart process is complete.
 
-Ensure your chosen challenge conveyance method is configured properly before attempting to request certificates. You can find more information about how to configure your system for each method in the acmetool documentation: https://github.com/hlandau/acme/blob/master/_doc/WSCONFIG.md
+Ensure your chosen challenge conveyance method is configured properly before attempting to request certificates. You can find more information about how to configure your system for each method in the acmetool documentation: https://git.devever.net/hlandau/acmetool/blob/master/_doc/WSCONFIG.md
 
 To request a certificate, run:
     
diff --git a/cmd/acmetool/le-import.go b/cmd/acmetool/le-import.go
deleted file mode 100644
index ca776a7..0000000
--- a/cmd/acmetool/le-import.go
+++ /dev/null
@@ -1,191 +0,0 @@
-package main
-
-import (
-	"crypto/x509"
-	"fmt"
-	"github.com/hlandau/acme/acmeapi"
-	"github.com/hlandau/acme/acmeapi/acmeendpoints"
-	"github.com/hlandau/acme/acmeapi/acmeutils"
-	"github.com/hlandau/acme/storage"
-	"golang.org/x/net/context"
-	"gopkg.in/square/go-jose.v1"
-	"io/ioutil"
-	"os"
-	"path/filepath"
-	"regexp"
-	"strings"
-)
-
-func cmdImportLE() {
-	s, err := storage.NewFDB(*stateFlag)
-	log.Fatale(err, "storage")
-
-	lePath := *importLEArg
-	accountNames, err := getLEAccountNames(lePath)
-	log.Fatale(err, "cannot inspect accounts directory - do you have permissions to read the Let's Encrypt directory (i.e. are you root)?")
-
-	// In order to import a Let's Encrypt state directory, we must:
-	//   - import the account keys
-	//   - import the certificate keys
-	//   - import the certificates
-
-	// Import account keys.
-	durls := map[string]struct{}{}
-
-	for _, accountName := range accountNames {
-		acct, err := importLEAccount(s, lePath, accountName)
-		log.Fatale(err, "import account")
-
-		durls[acct.DirectoryURL] = struct{}{}
-	}
-
-	keyFiles, err := filepath.Glob(filepath.Join(lePath, "keys", "*.pem"))
-	log.Fatale(err)
-
-	// Import certificate keys.
-	for _, keyFile := range keyFiles {
-		err := importKey(s, keyFile)
-		log.Fatale(err, "import key")
-	}
-
-	// Import certificates.
-	certFiles, err := filepath.Glob(filepath.Join(lePath, "archive", "*", "cert*.pem"))
-	log.Fatale(err)
-
-	for _, certFile := range certFiles {
-		err := importCert(s, certFile)
-		log.Fatale(err, "import certificate")
-	}
-
-	// If there is no default provider set, and we have only one directory URL
-	// imported, set it as the default provider.
-	if len(durls) == 1 && s.DefaultTarget().Request.Provider == "" {
-		for p := range durls {
-			s.DefaultTarget().Request.Provider = p
-			err := s.SaveTarget(s.DefaultTarget())
-			log.Fatale(err, "couldn't set default provider")
-			break
-		}
-	}
-}
-
-var knownProviderURLs = map[string]struct{}{}
-
-func importLEAccount(s storage.Store, lePath, accountName string) (*storage.Account, error) {
-	providerURL, err := getProviderURLFromAccountName(accountName)
-	if err != nil {
-		return nil, err
-	}
-
-	knownProviderURLs[providerURL] = struct{}{}
-
-	pkPath := filepath.Join(lePath, "accounts", accountName, "private_key.json")
-	b, err := ioutil.ReadFile(pkPath)
-	if err != nil {
-		return nil, err
-	}
-
-	k := jose.JsonWebKey{}
-	err = k.UnmarshalJSON(b)
-	if err != nil {
-		return nil, err
-	}
-
-	acct, err := s.ImportAccount(providerURL, k.Key)
-	if err != nil {
-		return nil, err
-	}
-
-	return acct, nil
-}
-
-func importKey(s storage.Store, filename string) error {
-	b, err := ioutil.ReadFile(filename)
-	if err != nil {
-		return err
-	}
-
-	pk, err := acmeutils.LoadPrivateKey(b)
-	if err != nil {
-		return err
-	}
-
-	_, err = s.ImportKey(pk)
-	return err
-}
-
-func importCert(s storage.Store, filename string) error {
-	certURL, err := determineLECertificateURL(filename)
-	if err != nil {
-		return err
-	}
-
-	_, err = s.ImportCertificate(certURL)
-	return err
-}
-
-// The Let's Encrypt state directory format keeps certificates but not their
-// URLs. Since boulder uses the serial number to form the URL, we can
-// reconstruct the URL. But since not even the provider association is stored,
-// we have to guess.
-func determineLECertificateURL(certFilename string) (string, error) {
-	b, err := ioutil.ReadFile(certFilename)
-	if err != nil {
-		return "", err
-	}
-
-	certs, err := acmeutils.LoadCertificates(b)
-	if err != nil {
-		return "", err
-	}
-
-	if len(certs) == 0 {
-		return "", fmt.Errorf("no certs")
-	}
-
-	c, err := x509.ParseCertificate(certs[0])
-	if err != nil {
-		return "", err
-	}
-
-	// Don't need directory URL, direct certificate URL load only.
-	cl := acmeapi.Client{}
-
-	_, certURL, err := acmeendpoints.CertificateToEndpointURL(&cl, c, context.TODO())
-	if err != nil {
-		return "", err
-	}
-
-	return certURL, nil
-}
-
-func getProviderURLFromAccountName(accountName string) (string, error) {
-	idx := strings.LastIndexByte(accountName, '/')
-	if idx < 0 || idx != len(accountName)-33 {
-		return "", fmt.Errorf("does not appear to be an account name: %#v", accountName)
-	}
-	return "https://" + accountName[0:idx], nil
-}
-
-func getLEAccountNames(path string) (accountNames []string, err error) {
-	err = filepath.Walk(filepath.Join(path, "accounts"), func(path string, fi os.FileInfo, err error) error {
-		if err != nil {
-			return err
-		}
-
-		m := re_leAccountPath.FindStringSubmatch(path)
-
-		if fi.IsDir() && m != nil {
-			accountNames = append(accountNames, m[1])
-		}
-
-		return nil
-	})
-	if err != nil {
-		return nil, err
-	}
-
-	return accountNames, nil
-}
-
-var re_leAccountPath = regexp.MustCompilePOSIX(`.*/([^/]+/directory/[0-9a-f]{32})$`)
diff --git a/cmd/acmetool/main.go b/cmd/acmetool/main.go
index 7e03e47..90f2998 100644
--- a/cmd/acmetool/main.go
+++ b/cmd/acmetool/main.go
@@ -1,499 +1,9 @@
-// acmetool, an automated certificate acquisition tool for ACME servers.
+// Legacy entrypoint for people using github.com/hlandau/acme/cmd/acmetool.
+// Moved to git.devever.net/hlandau/acmetool.
 package main
 
-import (
-	"bytes"
-	"fmt"
-	"io/ioutil"
-	"os"
-	"path/filepath"
-	"syscall"
-
-	"github.com/hlandau/acme/acmeapi"
-	"github.com/hlandau/acme/acmeapi/acmeutils"
-	"github.com/hlandau/acme/hooks"
-	"github.com/hlandau/acme/interaction"
-	"github.com/hlandau/acme/redirector"
-	"github.com/hlandau/acme/responder"
-	"github.com/hlandau/acme/storage"
-	"github.com/hlandau/acme/storageops"
-	"github.com/hlandau/dexlogconfig"
-	"github.com/hlandau/xlog"
-	"gopkg.in/alecthomas/kingpin.v2"
-	"gopkg.in/hlandau/easyconfig.v1/adaptflag"
-	"gopkg.in/hlandau/service.v2"
-	"gopkg.in/square/go-jose.v1"
-	"gopkg.in/yaml.v2"
-)
-
-var log, Log = xlog.New("acmetool")
-
-var (
-	stateFlag = kingpin.Flag("state", "Path to the state directory (env: ACME_STATE_DIR)").
-			Default(storage.RecommendedPath).
-			Envar("ACME_STATE_DIR").
-			PlaceHolder(storage.RecommendedPath).
-			String()
-
-	hooksFlag = kingpin.Flag("hooks", "Path to the notification hooks directory (env: ACME_HOOKS_DIR)").
-			Default(hooks.RecommendedPath).
-			Envar("ACME_HOOKS_DIR").
-			PlaceHolder(hooks.RecommendedPath).
-			String()
-
-	batchFlag = kingpin.Flag("batch", "Do not attempt interaction; useful for cron jobs. (acmetool can still obtain responses from a response file, if one was provided.)").
-			Bool()
-
-	stdioFlag = kingpin.Flag("stdio", "Don't attempt to use console dialogs; fall back to stdio prompts").Bool()
-
-	responseFileFlag = kingpin.Flag("response-file", "Read dialog responses from the given file (default: $ACME_STATE_DIR/conf/responses)").ExistingFile()
-
-	reconcileCmd = kingpin.Command("reconcile", reconcileHelp).Default()
-
-	cullCmd          = kingpin.Command("cull", "Delete expired, unused certificates")
-	cullSimulateFlag = cullCmd.Flag("simulate", "Show which certificates would be deleted without deleting any").Short('n').Bool()
-
-	statusCmd = kingpin.Command("status", "Show active configuration")
-
-	wantCmd       = kingpin.Command("want", "Add a target with one or more hostnames")
-	wantReconcile = wantCmd.Flag("reconcile", "Specify --no-reconcile to skip reconcile after adding target").Default("1").Bool()
-	wantArg       = wantCmd.Arg("hostname", "hostnames for which a certificate should be obtained").Required().Strings()
-
-	unwantCmd = kingpin.Command("unwant", "Modify targets to remove any mentions of the given hostnames")
-	unwantArg = unwantCmd.Arg("hostname", "hostnames which should be removed from all target files").Required().Strings()
-
-	quickstartCmd = kingpin.Command("quickstart", "Interactively ask some getting started questions (recommended)")
-	expertFlag    = quickstartCmd.Flag("expert", "Ask more questions in quickstart wizard").Bool()
-
-	redirectorCmd            = kingpin.Command("redirector", "HTTP to HTTPS redirector with challenge response support")
-	redirectorPathFlag       = redirectorCmd.Flag("path", "Path to serve challenge files from").String()
-	redirectorGIDFlag        = redirectorCmd.Flag("challenge-gid", "GID to chgrp the challenge path to (optional)").String()
-	redirectorReadTimeout    = redirectorCmd.Flag("read-timeout", "Maximum duration before timing out read of the request (default: '10s')").Default("10s").Duration()
-	redirectorWriteTimeout   = redirectorCmd.Flag("write-timeout", "Maximum duration before timing out write of the request (default: '20s')").Default("20s").Duration()
-	redirectorStatusCodeFlag = redirectorCmd.Flag("status-code", "HTTP status code to use when redirecting (default '308')").Default("308").Int()
-
-	testNotifyCmd = kingpin.Command("test-notify", "Test-execute notification hooks as though given hostnames were updated")
-	testNotifyArg = testNotifyCmd.Arg("hostname", "hostnames which have been updated").Strings()
-
-	importJWKAccountCmd = kingpin.Command("import-jwk-account", "Import a JWK account key")
-	importJWKURLArg     = importJWKAccountCmd.Arg("provider-url", "Provider URL (e.g. https://acme-v01.api.letsencrypt.org/directory)").Required().String()
-	importJWKPathArg    = importJWKAccountCmd.Arg("private-key-file", "Path to private_key.json").Required().ExistingFile()
-
-	importPEMAccountCmd = kingpin.Command("import-pem-account", "Import a PEM account key")
-	importPEMURLArg     = importPEMAccountCmd.Arg("provider-url", "Provider URL (e.g. https://acme-v01.api.letsencrypt.org/directory)").Required().String()
-	importPEMPathArg    = importPEMAccountCmd.Arg("private-key-file", "Path to private key PEM file").Required().ExistingFile()
-
-	importKeyCmd = kingpin.Command("import-key", "Import a certificate private key")
-	importKeyArg = importKeyCmd.Arg("private-key-file", "Path to PEM-encoded private key").Required().ExistingFile()
-
-	importLECmd = kingpin.Command("import-le", "Import a Let's Encrypt client state directory")
-	importLEArg = importLECmd.Arg("le-state-path", "Path to Let's Encrypt state directory").Default("/etc/letsencrypt").ExistingDir()
-
-	// Arguments we should probably support for revocation:
-	//   A certificate ID
-	//   A key ID
-	//   A path to a PEM-encoded certificate - TODO
-	//   A path to a PEM-encoded private key (revoke all known certificates with that key) - TODO
-	//   A path to a certificate directory - TODO
-	//   A path to a key directory - TODO
-	//   A certificate URL - TODO
-	revokeCmd = kingpin.Command("revoke", "Revoke a certificate")
-	revokeArg = revokeCmd.Arg("certificate-id-or-path", "Certificate ID to revoke").String()
-
-	accountThumbprintCmd = kingpin.Command("account-thumbprint", "Prints account thumbprints")
-)
-
-const reconcileHelp = `Reconcile ACME state, idempotently requesting and renewing certificates to satisfy configured targets.
-
-This is the default command.`
+import "git.devever.net/hlandau/acmetool/cli"
 
 func main() {
-	syscall.Umask(0) // make sure webroot files can be world-readable
-
-	adaptflag.Adapt()
-	cmd := kingpin.Parse()
-
-	var err error
-	*stateFlag, err = filepath.Abs(*stateFlag)
-	log.Fatale(err, "state directory path")
-	*hooksFlag, err = filepath.Abs(*hooksFlag)
-	log.Fatale(err, "hooks directory path")
-
-	hooks.DefaultPath = *hooksFlag
-	acmeapi.UserAgent = "acmetool"
-	dexlogconfig.Init()
-
-	if *batchFlag {
-		interaction.NonInteractive = true
-	}
-
-	if *stdioFlag {
-		interaction.NoDialog = true
-	}
-
-	if *responseFileFlag == "" {
-		p := filepath.Join(*stateFlag, "conf/responses")
-		if _, err := os.Stat(p); err == nil {
-			*responseFileFlag = p
-		}
-	}
-
-	if *responseFileFlag != "" {
-		err := loadResponseFile(*responseFileFlag)
-		log.Errore(err, "cannot load response file, continuing anyway")
-	}
-
-	switch cmd {
-	case "reconcile":
-		cmdReconcile()
-	case "cull":
-		cmdCull()
-	case "status":
-		cmdStatus()
-	case "account-thumbprint":
-		cmdAccountThumbprint()
-	case "want":
-		cmdWant()
-		if *wantReconcile {
-			cmdReconcile()
-		}
-	case "unwant":
-		cmdUnwant()
-	case "quickstart":
-		cmdQuickstart()
-	case "redirector":
-		cmdRunRedirector()
-	case "test-notify":
-		cmdRunTestNotify()
-	case "import-key":
-		cmdImportKey()
-	case "import-jwk-account":
-		cmdImportJWKAccount()
-	case "import-pem-account":
-		cmdImportPEMAccount()
-	case "import-le":
-		cmdImportLE()
-		cmdReconcile()
-	case "revoke":
-		cmdRevoke()
-	}
-}
-
-func cmdImportJWKAccount() {
-	s, err := storage.NewFDB(*stateFlag)
-	log.Fatale(err, "storage")
-
-	f, err := os.Open(*importJWKPathArg)
-	log.Fatale(err, "cannot open private key file")
-	defer f.Close()
-
-	b, err := ioutil.ReadAll(f)
-	log.Fatale(err, "cannot read file")
-
-	k := jose.JsonWebKey{}
-	err = k.UnmarshalJSON(b)
-	log.Fatale(err, "cannot unmarshal key")
-
-	_, err = s.ImportAccount(*importJWKURLArg, k.Key)
-	log.Fatale(err, "cannot import account key")
-}
-
-func cmdImportPEMAccount() {
-	s, err := storage.NewFDB(*stateFlag)
-	log.Fatale(err, "storage")
-
-	f, err := os.Open(*importPEMPathArg)
-	log.Fatale(err, "cannot open private key file")
-	defer f.Close()
-
-	b, err := ioutil.ReadAll(f)
-	log.Fatale(err, "cannot read file")
-
-	pk, err := acmeutils.LoadPrivateKey(b)
-	log.Fatale(err, "cannot parse private key")
-
-	_, err = s.ImportAccount(*importPEMURLArg, pk)
-	log.Fatale(err, "cannot import account key")
-}
-
-func cmdImportKey() {
-	s, err := storage.NewFDB(*stateFlag)
-	log.Fatale(err, "storage")
-
-	err = importKey(s, *importKeyArg)
-	log.Fatale(err, "import key")
-}
-
-func cmdReconcile() {
-	s, err := storage.NewFDB(*stateFlag)
-	log.Fatale(err, "storage")
-
-	err = storageops.Reconcile(s)
-	log.Fatale(err, "reconcile")
-}
-
-func cmdCull() {
-	s, err := storage.NewFDB(*stateFlag)
-	log.Fatale(err, "storage")
-
-	err = storageops.Cull(s, *cullSimulateFlag)
-	log.Fatale(err, "cull")
-}
-
-func cmdStatus() {
-	s, err := storage.NewFDB(*stateFlag)
-	log.Fatale(err, "storage")
-
-	info := StatusString(s)
-	log.Fatale(err, "status")
-
-	fmt.Print(info)
-}
-
-func StatusString(s storage.Store) string {
-	var buf bytes.Buffer
-	fmt.Fprintf(&buf, "Settings:\n")
-	fmt.Fprintf(&buf, "  ACME_STATE_DIR: %s\n", s.Path())
-	fmt.Fprintf(&buf, "  ACME_HOOKS_DIR: %s\n", hooks.DefaultPath)
-	fmt.Fprintf(&buf, "  Default directory URL: %s\n", s.DefaultTarget().Request.Provider)
-	fmt.Fprintf(&buf, "  Preferred key type: %v\n", &s.DefaultTarget().Request.Key)
-	fmt.Fprintf(&buf, "  Additional webroots:\n")
-	for _, wr := range s.DefaultTarget().Request.Challenge.WebrootPaths {
-		fmt.Fprintf(&buf, "    %s\n", wr)
-	}
-
-	fmt.Fprintf(&buf, "\nAvailable accounts:\n")
-	s.VisitAccounts(func(a *storage.Account) error {
-		fmt.Fprintf(&buf, "  %v\n", a)
-		thumbprint, _ := acmeutils.Base64Thumbprint(a.PrivateKey)
-		fmt.Fprintf(&buf, "    thumbprint: %s\n", thumbprint)
-		return nil
-	})
-
-	fmt.Fprintf(&buf, "\n")
-	s.VisitTargets(func(t *storage.Target) error {
-		fmt.Fprintf(&buf, "%v\n", t)
-
-		c, err := storageops.FindBestCertificateSatisfying(s, t)
-		if err != nil {
-			fmt.Fprintf(&buf, "  error: %v\n", err)
-			return nil // continue
-		}
-
-		renewStr := ""
-		if storageops.CertificateNeedsRenewing(c) {
-			renewStr = " needs-renewing"
-		}
-
-		fmt.Fprintf(&buf, "  best: %v%s\n", c, renewStr)
-		return nil
-	})
-
-	if storageops.HaveUncachedCertificates(s) {
-		fmt.Fprintf(&buf, "\nThere are uncached certificates.\n")
-	}
-
-	return buf.String()
-}
-
-func cmdAccountThumbprint() {
-	s, err := storage.NewFDB(*stateFlag)
-	log.Fatale(err, "storage")
-
-	s.VisitAccounts(func(a *storage.Account) error {
-		thumbprint, _ := acmeutils.Base64Thumbprint(a.PrivateKey)
-		fmt.Printf("%s\t%s\n", thumbprint, a.ID())
-		return nil
-	})
-}
-
-func cmdWant() {
-	hostnames := *wantArg
-
-	// Ensure all hostnames provided are valid.
-	for idx := range hostnames {
-		norm, err := acmeutils.NormalizeHostname(hostnames[idx])
-		if err != nil {
-			log.Fatalf("invalid hostname: %#v: %v", hostnames[idx], err)
-			return
-		}
-		hostnames[idx] = norm
-	}
-
-	// Determine whether there already exists a target satisfying all given
-	// hostnames or a superset thereof.
-	s, err := storage.NewFDB(*stateFlag)
-	log.Fatale(err, "storage")
-
-	alreadyExists := false
-	s.VisitTargets(func(t *storage.Target) error {
-		nm := map[string]struct{}{}
-		for _, n := range t.Satisfy.Names {
-			nm[n] = struct{}{}
-		}
-
-		for _, w := range hostnames {
-			if _, ok := nm[w]; !ok {
-				return nil
-			}
-		}
-
-		alreadyExists = true
-		return nil
-	})
-
-	if alreadyExists {
-		return
-	}
-
-	// Add the target.
-	tgt := storage.Target{
-		Satisfy: storage.TargetSatisfy{
-			Names: hostnames,
-		},
-	}
-
-	err = s.SaveTarget(&tgt)
-	log.Fatale(err, "add target")
-}
-
-func cmdUnwant() {
-	s, err := storage.NewFDB(*stateFlag)
-	log.Fatale(err, "storage")
-
-	for _, hn := range *unwantArg {
-		err = storageops.RemoveTargetHostname(s, hn)
-		log.Fatale(err, "remove target hostname ", hn)
-	}
-}
-
-func cmdRunRedirector() {
-	rpath := *redirectorPathFlag
-	if rpath == "" {
-		// redirector process is internet-facing and must never touch private keys
-		storage.Neuter()
-		rpath = determineWebroot()
-	}
-
-	service.Main(&service.Info{
-		Name:          "acmetool",
-		Description:   "acmetool HTTP redirector",
-		DefaultChroot: rpath,
-		NewFunc: func() (service.Runnable, error) {
-			return redirector.New(redirector.Config{
-				Bind:          ":80",
-				ChallengePath: rpath,
-				ChallengeGID:  *redirectorGIDFlag,
-				ReadTimeout:   *redirectorReadTimeout,
-				WriteTimeout:  *redirectorWriteTimeout,
-				StatusCode:    *redirectorStatusCodeFlag,
-			})
-		},
-	})
-}
-
-func determineWebroot() string {
-	s, err := storage.NewFDB(*stateFlag)
-	log.Fatale(err, "storage")
-
-	webrootPaths := s.DefaultTarget().Request.Challenge.WebrootPaths
-	if len(webrootPaths) > 0 {
-		return webrootPaths[0]
-	}
-
-	return responder.StandardWebrootPath
-}
-
-func cmdRunTestNotify() {
-	ctx := &hooks.Context{
-		HooksDir: *hooksFlag,
-		StateDir: *stateFlag,
-	}
-	err := hooks.NotifyLiveUpdated(ctx, *testNotifyArg)
-	log.Errore(err, "notify")
-}
-
-// YAML response file loading.
-
-func loadResponseFile(path string) error {
-	b, err := ioutil.ReadFile(path)
-	if err != nil {
-		return err
-	}
-
-	m := map[string]interface{}{}
-	err = yaml.Unmarshal(b, &m)
-	if err != nil {
-		return err
-	}
-
-	for k, v := range m {
-		r, err := parseResponse(v)
-		if err != nil {
-			log.Errore(err, "response for ", k, " invalid")
-			continue
-		}
-		interaction.SetResponse(k, r)
-	}
-
-	return nil
-}
-
-func parseResponse(v interface{}) (*interaction.Response, error) {
-	switch x := v.(type) {
-	case string:
-		return &interaction.Response{
-			Value: x,
-		}, nil
-	case int:
-		return &interaction.Response{
-			Value: fmt.Sprintf("%d", x),
-		}, nil
-	case bool:
-		return &interaction.Response{
-			Cancelled: !x,
-		}, nil
-	default:
-		return nil, fmt.Errorf("unknown response value")
-	}
-}
-
-func cmdRevoke() {
-	certSpec := *revokeArg
-	f, _ := os.Open(certSpec)
-	//var fi os.FileInfo
-	if f != nil {
-		defer f.Close()
-		//var err error
-		//fi, err = f.Stat()
-		//log.Panice(err)
-	}
-	//u, _ := url.Parse(certSpec)
-
-	switch {
-	//case f != nil && !fi.IsDir(): // is a file path
-
-	//case f != nil && fi.IsDir(): // is a directory path
-	//  f, _ = os.Open(filepath.Join(certSpec, "cert"))
-
-	//case u != nil && u.IsAbs() && acmeapi.ValidURL(certSpec): // is an URL
-
-	case storage.IsWellFormattedCertificateOrKeyID(certSpec):
-		// key or certificate ID
-		revokeByCertificateID(certSpec)
-
-	default:
-		log.Fatalf("don't understand argument, must be a certificate or key ID: %q", certSpec)
-	}
-}
-
-func revokeByCertificateID(certID string) {
-	s, err := storage.NewFDB(*stateFlag)
-	log.Fatale(err, "storage")
-
-	err = storageops.RevokeByCertificateOrKeyID(s, certID)
-	log.Fatale(err, "revoke")
-
-	err = storageops.Reconcile(s)
-	log.Fatale(err, "reconcile")
+	cli.Main()
 }
diff --git a/fdb/fdb.go b/fdb/fdb.go
index f617fdc..2fafd83 100644
--- a/fdb/fdb.go
+++ b/fdb/fdb.go
@@ -136,9 +136,11 @@ func (db *DB) Verify() error {
 		return err
 	}
 
-	err = db.conformPermissions()
-	if err != nil {
-		return err
+	if len(db.cfg.Permissions) > 0 {
+		err = db.conformPermissions()
+		if err != nil {
+			return err
+		}
 	}
 
 	return nil
diff --git a/fdb/mkdir.go b/fdb/mkdir.go
index d26546d..f77c39a 100644
--- a/fdb/mkdir.go
+++ b/fdb/mkdir.go
@@ -14,7 +14,7 @@ func mkdirAllWithOwner(absPath string, perm os.FileMode, uid, gid int) error {
 		if dir.IsDir() {
 			return nil
 		}
-		return &os.PathError{"mkdir", absPath, syscall.ENOTDIR}
+		return &os.PathError{Op: "mkdir", Path: absPath, Err: syscall.ENOTDIR}
 	}
 
 	// Slow path: make sure parent exists and then call Mkdir for path.
diff --git a/fdb/parseperm.go b/fdb/parseperm.go
index 258a609..82e630c 100644
--- a/fdb/parseperm.go
+++ b/fdb/parseperm.go
@@ -12,7 +12,7 @@ import (
 	"strings"
 )
 
-var re_permissionLine = regexp.MustCompile(`^(?P<path>[^\s]+)\s+(?P<value>inherit|(?P<fileMode>[0-7]{3,4})\s+(?P<dirMode>[0-7]{3,4})(\s+(?P<uid>[^\s]+)\s+(?P<gid>[^\s]+))?)$`)
+var rePermissionLine = regexp.MustCompile(`^(?P<path>[^\s]+)\s+(?P<value>inherit|(?P<fileMode>[0-7]{3,4})\s+(?P<dirMode>[0-7]{3,4})(\s+(?P<uid>[^\s]+)\s+(?P<gid>[^\s]+))?)$`)
 
 func parsePermissions(r io.Reader) (ps []Permission, erasePaths map[string]struct{}, err error) {
 	br := bufio.NewReader(r)
@@ -36,14 +36,14 @@ func parsePermissions(r io.Reader) (ps []Permission, erasePaths map[string]struc
 		}
 
 		// keys/*/privkey 0640 0750 - -
-		m := re_permissionLine.FindStringSubmatch(L)
+		m := rePermissionLine.FindStringSubmatch(L)
 		if m == nil {
 			return nil, nil, fmt.Errorf("line %d: badly formatted line: %q", Lnum, L)
 		}
 
 		path := filepath.Clean(m[1])
 		if path == ".." || strings.HasPrefix(path, "../") || filepath.IsAbs(path) {
-			return nil, nil, fmt.Errorf("line %d: path must remain within the DB root", Lnum, L)
+			return nil, nil, fmt.Errorf("line %d: path must remain within the DB root: %q", Lnum, L)
 		}
 
 		if _, seen := seenPaths[path]; seen {
diff --git a/fdb/parseperm_test.go b/fdb/parseperm_test.go
index ba2b129..29755e0 100644
--- a/fdb/parseperm_test.go
+++ b/fdb/parseperm_test.go
@@ -20,20 +20,20 @@ func TestParsePerm(t *testing.T) {
      # this is a comment
      foo/bar 0644 0755
      foo/*/baz  0640  0750  
-     alpha  0644 0755  root daemon
+     alpha  0644 0755  root root
      beta  0644 0755  42 42
      gamma  0644 0755  $r $r
      delta   inherit
      x 0644 0755 root -
-     y 0644 0755 - daemon
+     y 0644 0755 - root
      `, []Permission{
 			{Path: "foo/bar", FileMode: 0644, DirMode: 0755},
 			{Path: "foo/*/baz", FileMode: 0640, DirMode: 0750},
-			{Path: "alpha", FileMode: 0644, DirMode: 0755, UID: "root", GID: "daemon"},
+			{Path: "alpha", FileMode: 0644, DirMode: 0755, UID: "root", GID: "root"},
 			{Path: "beta", FileMode: 0644, DirMode: 0755, UID: "42", GID: "42"},
 			{Path: "gamma", FileMode: 0644, DirMode: 0755, UID: "$r", GID: "$r"},
 			{Path: "x", FileMode: 0644, DirMode: 0755, UID: "root", GID: ""},
-			{Path: "y", FileMode: 0644, DirMode: 0755, UID: "", GID: "daemon"},
+			{Path: "y", FileMode: 0644, DirMode: 0755, UID: "", GID: "root"},
 		}, map[string]struct{}{"delta": struct{}{}}},
 	}
 
diff --git a/hooks/hooks.go b/hooks/hooks.go
index 2256d29..7b5b5af 100644
--- a/hooks/hooks.go
+++ b/hooks/hooks.go
@@ -15,19 +15,24 @@ import (
 // Log site.
 var log, Log = xlog.New("acme.hooks")
 
-// The recommended hook path is the path at which executable hooks are looked
-// for. On POSIX-like systems, this is usually "/usr/lib/acme/hooks" (or
-// "/usr/libexec/acme/hooks" if /usr/libexec exists).
-var RecommendedPath string
+// The recommended hook paths are the paths at which executable hooks are
+// looked for. On POSIX-like systems, this is usually "/usr/lib/acme/hooks" and
+// "/usr/libexec/acme/hooks".
+var RecommendedPaths []string
 
-// The default hook path defaults to the recommended hook path but could be
+// The default hook paths default to the recommended hook paths but could be
 // changed at runtime.
+var DefaultPaths []string
+
+// Do not use. For build-time use by distributions only. If set to a non-empty
+// string at build time, DefaultPaths is set to a slice containing only this
+// value.
 var DefaultPath string
 
 // Provides contextual configuration information when executing a hook.
 type Context struct {
-	// The hook directory to use. May be "" for the default.
-	HooksDir string
+	// The hook directories to use. If zero-length, uses DefaultPaths.
+	HookDirs []string
 
 	// The state directory to report. Required.
 	StateDir string
@@ -38,17 +43,27 @@ type Context struct {
 
 func init() {
 	// Allow overriding at build time.
-	p := DefaultPath
-	if p == "" {
-		p = "/usr/lib/acme/hooks"
+	if DefaultPath != "" {
+		DefaultPaths = []string{DefaultPath}
+		RecommendedPaths = DefaultPaths
+		return
 	}
 
-	if _, err := os.Stat("/usr/libexec"); strings.HasPrefix(p, "/usr/lib/") && err == nil {
-		p = "/usr/libexec" + p[8:]
+	DefaultPaths = []string{"/usr/libexec/acme/hooks", "/usr/lib/acme/hooks"}
+
+	// Put the preferred directory first.
+	prefDir, err := preferredHookDir(DefaultPaths)
+	if err == nil {
+		newDefaultPaths := []string{prefDir}
+		for _, dp := range DefaultPaths {
+			if dp != prefDir {
+				newDefaultPaths = append(newDefaultPaths, dp)
+			}
+		}
+		DefaultPaths = newDefaultPaths
 	}
 
-	DefaultPath = p
-	RecommendedPath = p
+	RecommendedPaths = DefaultPaths
 }
 
 // Notifies hook programs that a live symlink has been updated.
@@ -95,14 +110,21 @@ func ChallengeTLSSNIStop(ctx *Context, hostname, targetFileName, validationName1
 		"challenge-tls-sni-stop", hostname, targetFileName, validationName1, validationName2)
 }
 
+func challengeDNS(ctx *Context, op, hostname, targetFileName, body string) (installed bool, err error) {
+	wildcardFlag := ""
+	if strings.HasPrefix(hostname, "*.") {
+		hostname = hostname[2:]
+		wildcardFlag = "wildcard"
+	}
+	return runParts(ctx, nil, op, hostname, targetFileName, body, wildcardFlag)
+}
+
 func ChallengeDNSStart(ctx *Context, hostname, targetFileName, body string) (installed bool, err error) {
-	return runParts(ctx, nil,
-		"challenge-dns-start", hostname, targetFileName, body)
+	return challengeDNS(ctx, "challenge-dns-start", hostname, targetFileName, body)
 }
 
 func ChallengeDNSStop(ctx *Context, hostname, targetFileName, body string) (uninstalled bool, err error) {
-	return runParts(ctx, nil,
-		"challenge-dns-stop", hostname, targetFileName, body)
+	return challengeDNS(ctx, "challenge-dns-stop", hostname, targetFileName, body)
 }
 
 func mergeEnvMap(m map[string]string, e []string) {
@@ -134,31 +156,41 @@ func mergeEnv(envs ...[]string) []string {
 // Implements functionality similar to the "run-parts" command on many distros.
 // Implementations vary, so it is reimplemented here.
 func runParts(ctx *Context, stdinData []byte, args ...string) (anySucceeded bool, err error) {
-	directory := ctx.HooksDir
-	if directory == "" {
-		directory = DefaultPath
+	dirs := ctx.HookDirs
+	if len(dirs) == 0 {
+		dirs = DefaultPaths
 	}
 
-	fi, err := os.Stat(directory)
-	if err != nil {
-		if os.IsNotExist(err) {
-			// Not an error if the directory doesn't exist; nothing to do.
-			return false, nil
+	var dirs2 []string
+	for _, directory := range dirs {
+		fi, err := os.Stat(directory)
+		if err == nil {
+			// Do not execute a world-writable directory.
+			if (fi.Mode() & 02) != 0 {
+				return false, fmt.Errorf("refusing to execute hooks, directory is world-writable: %s", directory)
+			}
+
+			dirs2 = append(dirs2, directory)
+		} else if !os.IsNotExist(err) {
+			return false, err
 		}
+	}
 
-		return false, err
+	if len(dirs2) == 0 {
+		// None of the directories exist; nothing to do.
+		return false, nil
 	}
 
 	env := mergeEnv(os.Environ(), flattenEnvMap(ctx.Env), []string{"ACME_STATE_DIR=" + ctx.StateDir})
 
-	// Do not execute a world-writable directory.
-	if (fi.Mode() & 02) != 0 {
-		return false, fmt.Errorf("refusing to execute hooks, directory is world-writable: %s", directory)
-	}
+	var ms []string
+	for _, directory := range dirs2 {
+		m, err := filepath.Glob(filepath.Join(directory, "*"))
+		if err != nil {
+			return false, err
+		}
 
-	ms, err := filepath.Glob(filepath.Join(directory, "*"))
-	if err != nil {
-		return false, err
+		ms = append(ms, m...)
 	}
 
 	for _, m := range ms {
diff --git a/hooks/hooks_test.go b/hooks/hooks_test.go
index 786aab8..c465763 100644
--- a/hooks/hooks_test.go
+++ b/hooks/hooks_test.go
@@ -45,15 +45,17 @@ func TestNotify(t *testing.T) {
 
 	defer os.RemoveAll(dir)
 
-	notifyDir := filepath.Join(dir, "notify")
+	notify1 := filepath.Join(dir, "notify1")
+	notify2 := filepath.Join(dir, "notify2")
+	notifyDirs := []string{notify1, notify2}
 
 	for i := 0; i < 2; i++ {
-		err = Replace(notifyDir, "alpha", fmt.Sprintf(fileTpl, "", i*2+0))
+		err = Replace(notifyDirs, "alpha", fmt.Sprintf(fileTpl, "", i*2+0))
 		if err != nil {
 			t.Fatal(err)
 		}
 
-		err = Replace(notifyDir, "beta", fmt.Sprintf(fileTpl, "#!acmetool-managed!#", i*2+1))
+		err = Replace(notifyDirs, "beta", fmt.Sprintf(fileTpl, "#!acmetool-managed!#", i*2+1))
 		if err != nil {
 			t.Fatal(err)
 		}
@@ -61,7 +63,7 @@ func TestNotify(t *testing.T) {
 		os.Remove(filepath.Join(dir, "log"))
 
 		ctx := &Context{
-			HooksDir: notifyDir,
+			HookDirs: notifyDirs,
 			StateDir: dir,
 		}
 		err = NotifyLiveUpdated(ctx, []string{"a.b", "c.d", "e.f.g"})
diff --git a/hooks/install.go b/hooks/install.go
index 34b7caf..3bc2894 100644
--- a/hooks/install.go
+++ b/hooks/install.go
@@ -2,16 +2,38 @@ package hooks
 
 import (
 	"bytes"
+	"fmt"
 	"os"
 	"path/filepath"
 )
 
+// Given a set of hook directories, returns whether a hook with the given name exists in any of them.
+func Exists(hookDirs []string, hookName string) bool {
+	for _, hookDir := range hookDirs {
+		_, err := os.Stat(filepath.Join(hookDir, hookName))
+		if err == nil {
+			return true
+		}
+	}
+	return false
+}
+
 // Installs a hook in the hooks directory. If the file already exists, it is
 // not overwritten unless it contains the string "#!acmetool-managed!#" in its
 // first 4096 bytes.
-func Replace(hookDirectory, name, data string) error {
-	if hookDirectory == "" {
-		hookDirectory = DefaultPath
+func Replace(hookDirs []string, name, data string) error {
+	if len(hookDirs) == 0 {
+		hookDirs = DefaultPaths
+	}
+	if len(hookDirs) == 0 {
+		return fmt.Errorf("no hooks directory configured")
+	}
+
+	// Find the directory in the filesystem which has the most parent components
+	// of it already created.
+	hookDirectory, err := preferredHookDir(hookDirs)
+	if err != nil {
+		return err
 	}
 
 	filename := filepath.Join(hookDirectory, name)
@@ -24,6 +46,40 @@ func Replace(hookDirectory, name, data string) error {
 	return err
 }
 
+func preferredHookDir(hookDirs []string) (hookDirectory string, err error) {
+	bestLA := 255
+	for _, dir := range hookDirs {
+		var la int
+		la, err = levelsAbsent(dir)
+		if err != nil {
+			return
+		}
+
+		if la < bestLA {
+			hookDirectory = dir
+			bestLA = la
+		}
+	}
+	if hookDirectory == "" {
+		hookDirectory = hookDirs[0]
+	}
+
+	return
+}
+
+func levelsAbsent(dir string) (int, error) {
+	for i := 0; dir != "." && dir != "/"; i++ {
+		_, err := os.Stat(dir)
+		if err == nil {
+			return i, nil
+		}
+
+		dir = filepath.Join(dir, "..")
+	}
+
+	return 255, fmt.Errorf("cannot find a level which exists")
+}
+
 func writeHook(filename, data string) error {
 	err := os.MkdirAll(filepath.Dir(filename), 0755)
 	if err != nil {
diff --git a/main.go b/main.go
new file mode 100644
index 0000000..a9243ea
--- /dev/null
+++ b/main.go
@@ -0,0 +1,7 @@
+package main
+
+import "git.devever.net/hlandau/acmetool/cli"
+
+func main() {
+	cli.Main()
+}
diff --git a/redirector/redirector.go b/redirector/redirector.go
index 5ebdcae..dcbf77e 100644
--- a/redirector/redirector.go
+++ b/redirector/redirector.go
@@ -53,6 +53,10 @@ func New(cfg Config) (*Redirector, error) {
 		},
 	}
 
+	if r.cfg.StatusCode == 0 {
+		r.cfg.StatusCode = 308
+	}
+
 	// Try and make the challenge path if it doesn't exist.
 	err := os.MkdirAll(r.cfg.ChallengePath, 0755)
 	if err != nil {
diff --git a/responder/dns.go b/responder/dns.go
index 28bf685..fefb49d 100644
--- a/responder/dns.go
+++ b/responder/dns.go
@@ -4,11 +4,12 @@ import (
 	"crypto"
 	"encoding/json"
 	"fmt"
-	"github.com/hlandau/acme/acmeapi/acmeutils"
+	"git.devever.net/hlandau/acmeapi/acmeutils"
 )
 
 type DNSChallengeInfo struct {
-	Body string
+	Hostname string
+	Body     string
 }
 
 type dnsResponder struct {
@@ -19,15 +20,15 @@ type dnsResponder struct {
 
 func newDNSResponder(rcfg Config) (Responder, error) {
 	s := &dnsResponder{
-		rcfg: rcfg,
+		rcfg:       rcfg,
+		validation: []byte("{}"),
 	}
 
-	var err error
-	s.validation, err = acmeutils.ChallengeResponseJSON(rcfg.AccountKey, rcfg.Token, "dns-01")
-	if err != nil {
-		return nil, err
+	if rcfg.Hostname == "" {
+		return nil, fmt.Errorf("must provide a hostname")
 	}
 
+	var err error
 	s.dnsString, err = acmeutils.DNSKeyAuthorization(rcfg.AccountKey, rcfg.Token)
 	if err != nil {
 		return nil, err
@@ -41,7 +42,8 @@ func (s *dnsResponder) Start() error {
 	// Try hooks.
 	if startFunc := s.rcfg.ChallengeConfig.StartHookFunc; startFunc != nil {
 		err := startFunc(&DNSChallengeInfo{
-			Body: s.dnsString,
+			Hostname: s.rcfg.Hostname,
+			Body:     s.dnsString,
 		})
 		return err
 	}
@@ -54,7 +56,8 @@ func (s *dnsResponder) Stop() error {
 	// Try hooks.
 	if stopFunc := s.rcfg.ChallengeConfig.StopHookFunc; stopFunc != nil {
 		err := stopFunc(&DNSChallengeInfo{
-			Body: s.dnsString,
+			Hostname: s.rcfg.Hostname,
+			Body:     s.dnsString,
 		})
 		log.Warne(err, "failed to uninstall DNS challenge via hook (ignoring)")
 		return nil
diff --git a/responder/http.go b/responder/http.go
index 499ee01..a1d7d52 100644
--- a/responder/http.go
+++ b/responder/http.go
@@ -6,10 +6,10 @@ import (
 	"crypto/tls"
 	"encoding/json"
 	"fmt"
-	"github.com/hlandau/acme/acmeapi/acmeutils"
+	"git.devever.net/hlandau/acmeapi/acmeutils"
+	"git.devever.net/hlandau/acmetool/responder/reshttp"
 	denet "github.com/hlandau/goutils/net"
 	deos "github.com/hlandau/goutils/os"
-	"gopkg.in/tylerb/graceful.v1"
 	"io/ioutil"
 	"net"
 	"net/http"
@@ -19,11 +19,17 @@ import (
 	"sort"
 	"strconv"
 	"strings"
-	"sync"
 	"time"
 )
 
+// For testing use only. Determines the HTTP port which is listened on. This is
+// used because Pebble tries to talk to the client's HTTP responder on a
+// different HTTP port than the standard one. This use of non-privileged ports
+// eases testing.
+var InternalHTTPPort = 80
+
 type HTTPChallengeInfo struct {
+	Hostname string
 	Filename string
 	Body     string
 }
@@ -31,10 +37,9 @@ type HTTPChallengeInfo struct {
 type httpResponder struct {
 	rcfg Config
 
-	serveMux            *http.ServeMux
 	response            []byte
 	requestDetectedChan chan struct{}
-	stopFuncs           []func()
+	portClaims          []reshttp.PortClaim
 	ka                  []byte
 	validation          []byte
 	filePath            string
@@ -45,13 +50,14 @@ type httpResponder struct {
 func newHTTP(rcfg Config) (Responder, error) {
 	s := &httpResponder{
 		rcfg:                rcfg,
-		serveMux:            http.NewServeMux(),
 		requestDetectedChan: make(chan struct{}, 1),
 		notifySupported:     true,
+		validation:          []byte("{}"),
 	}
 
-	// Configure the HTTP server
-	s.serveMux.HandleFunc("/.well-known/acme-challenge/"+rcfg.Token, s.handle)
+	if rcfg.Hostname == "" {
+		return nil, fmt.Errorf("must provide a hostname")
+	}
 
 	ka, err := acmeutils.KeyAuthorization(rcfg.AccountKey, rcfg.Token)
 	if err != nil {
@@ -59,23 +65,9 @@ func newHTTP(rcfg Config) (Responder, error) {
 	}
 
 	s.ka = []byte(ka)
-
-	s.validation, err = acmeutils.ChallengeResponseJSON(rcfg.AccountKey, rcfg.Token, "http-01")
-	if err != nil {
-		return nil, err
-	}
-
 	return s, nil
 }
 
-// HTTP handler.
-func (s *httpResponder) handle(rw http.ResponseWriter, req *http.Request) {
-	// Send the precomputed response.
-	rw.Header().Set("Content-Type", "text/plain")
-	rw.Write(s.ka)
-	s.notify()
-}
-
 func (s *httpResponder) notify() {
 	// Notify callers that a request has been detected.
 	select {
@@ -92,10 +84,10 @@ func (s *httpResponder) Start() error {
 	}
 
 	if !s.rcfg.ChallengeConfig.HTTPNoSelfTest {
-		log.Debug("http-01 self test")
+		log.Debugf("http-01 self test for %q", s.rcfg.Hostname)
 		err = s.selfTest()
 		if err != nil {
-			log.Infoe(err, "http-01 self test failed")
+			log.Infoe(err, "http-01 self test failed: ", s.rcfg.Hostname)
 			s.Stop()
 			return err
 		}
@@ -121,6 +113,9 @@ func (s *httpResponder) selfTest() error {
 		Host:   s.rcfg.Hostname,
 		Path:   "/.well-known/acme-challenge/" + s.rcfg.Token,
 	}
+	if InternalHTTPPort != 80 {
+		u.Host = net.JoinHostPort(u.Host, fmt.Sprintf("%d", InternalHTTPPort))
+	}
 
 	trans := &http.Transport{
 		TLSClientConfig:   &tls.Config{InsecureSkipVerify: true},
@@ -139,7 +134,7 @@ func (s *httpResponder) selfTest() error {
 
 	defer res.Body.Close()
 	if res.StatusCode != 200 {
-		return fmt.Errorf("non-200 status code when doing self-test")
+		return fmt.Errorf("hostname %q: non-200 status code when doing self-test", s.rcfg.Hostname)
 	}
 
 	b, err := ioutil.ReadAll(denet.LimitReader(res.Body, 1*1024*1024))
@@ -149,7 +144,7 @@ func (s *httpResponder) selfTest() error {
 
 	b = bytes.TrimSpace(b)
 	if !bytes.Equal(b, s.ka) {
-		return fmt.Errorf("got 200 response when doing self-test, but with the wrong data")
+		return fmt.Errorf("hostname %q: got 200 response when doing self-test, but with the wrong data", s.rcfg.Hostname)
 	}
 
 	// If we detected a request, we support notifications, otherwise we don't.
@@ -300,8 +295,8 @@ func (a addrSorter) Less(i, j int) bool {
 func determineListenAddrs(userAddrs []string) []string {
 	// Here's our brute force method: listen on everything that might work.
 	addrs := parseListenAddrs(userAddrs)
-	addrs["[::]:80"] = struct{}{} // OpenBSD
-	addrs[":80"] = struct{}{}
+	addrs[fmt.Sprintf("[::]:%d", InternalHTTPPort)] = struct{}{} // OpenBSD
+	addrs[fmt.Sprintf(":%d", InternalHTTPPort)] = struct{}{}
 	addrs["[::1]:402"] = struct{}{}
 	addrs["127.0.0.1:402"] = struct{}{}
 	addrs["[::1]:4402"] = struct{}{}
@@ -324,7 +319,10 @@ func (s *httpResponder) startActual() error {
 	addrs := determineListenAddrs(s.rcfg.ChallengeConfig.HTTPPorts)
 
 	for _, a := range addrs {
-		s.startListener(a)
+		pc, err := reshttp.AcquirePort(a, s.rcfg.Token, s.ka, s.notify)
+		if err == nil {
+			s.portClaims = append(s.portClaims, pc)
+		}
 	}
 
 	// Even if none of the listeners managed to start, the webroot or redirector
@@ -334,6 +332,7 @@ func (s *httpResponder) startActual() error {
 	// Try hooks.
 	if startFunc := s.rcfg.ChallengeConfig.StartHookFunc; startFunc != nil {
 		err := startFunc(&HTTPChallengeInfo{
+			Hostname: s.rcfg.Hostname,
 			Filename: s.rcfg.Token,
 			Body:     string(s.ka),
 		})
@@ -343,52 +342,12 @@ func (s *httpResponder) startActual() error {
 	return nil
 }
 
-func (s *httpResponder) startListener(addr string) error {
-	svr := &graceful.Server{
-		NoSignalHandling: true,
-		Server: &http.Server{
-			Addr:    addr,
-			Handler: s.serveMux,
-		},
-	}
-
-	l, err := net.Listen("tcp", svr.Addr)
-	if err != nil {
-		log.Debuge(err, "failed to listen on ", svr.Addr)
-		return err
-	}
-
-	log.Debugf("listening on %v", svr.Addr)
-
-	go func() {
-		defer l.Close()
-		svr.Serve(l)
-	}()
-
-	stopFunc := func() {
-		svr.Stop(10 * time.Millisecond)
-		<-svr.StopChan()
-	}
-
-	s.stopFuncs = append(s.stopFuncs, stopFunc)
-	return nil
-}
-
 // Stop handling HTTP requests.
 func (s *httpResponder) Stop() error {
-	var wg sync.WaitGroup
-	wg.Add(len(s.stopFuncs))
-
-	call := func(f func()) {
-		defer wg.Done()
-		f()
-	}
-
-	for _, f := range s.stopFuncs {
-		go call(f)
+	for _, pc := range s.portClaims {
+		pc.Close()
 	}
-	wg.Wait()
-	s.stopFuncs = nil
+	s.portClaims = nil
 
 	// Try and remove challenges.
 	webrootRemoveChallenge(s.getWebroots(), s.rcfg.Token)
@@ -396,6 +355,7 @@ func (s *httpResponder) Stop() error {
 	// Try and stop hooks.
 	if stopFunc := s.rcfg.ChallengeConfig.StopHookFunc; stopFunc != nil {
 		err := stopFunc(&HTTPChallengeInfo{
+			Hostname: s.rcfg.Hostname,
 			Filename: s.rcfg.Token,
 			Body:     string(s.ka),
 		})
diff --git a/responder/possession.go b/responder/possession.go
deleted file mode 100644
index d804a72..0000000
--- a/responder/possession.go
+++ /dev/null
@@ -1,102 +0,0 @@
-package responder
-
-import (
-	"crypto"
-	"crypto/x509"
-	"encoding/json"
-	"fmt"
-	"github.com/hlandau/acme/acmeapi"
-	"gopkg.in/square/go-jose.v1"
-)
-
-type proofOfPossessionResponder struct {
-	validation []byte
-	pk         crypto.PrivateKey
-}
-
-func (rcfg *Config) findAcceptablePrivateKey() (crypto.PrivateKey, error) {
-	for _, der := range rcfg.AcceptableCertificates {
-		crt, err := x509.ParseCertificate(der)
-		if err != nil {
-			continue
-		}
-
-		if rcfg.ChallengeConfig.PriorKeyFunc == nil {
-			continue
-		}
-
-		pk, err := rcfg.ChallengeConfig.PriorKeyFunc(crt.PublicKey)
-		if err != nil {
-			return nil, err
-		}
-
-		if pk != nil {
-			return pk, nil
-		}
-	}
-
-	return nil, nil
-}
-
-func newProofOfPossessionResponder(rcfg Config) (Responder, error) {
-	if rcfg.Hostname == "" {
-		return nil, fmt.Errorf("hostname is required for proofOfPossession")
-	}
-
-	pk, err := rcfg.findAcceptablePrivateKey()
-	if err != nil {
-		return nil, err
-	}
-	if pk == nil {
-		return nil, fmt.Errorf("no acceptable private keys could be found")
-	}
-
-	r := &proofOfPossessionResponder{
-		pk: pk,
-	}
-
-	info := map[string]interface{}{
-		"resource": "challenge",
-		"type":     "proofOfPossession",
-		"identifiers": []acmeapi.Identifier{
-			{
-				Type:  "dns",
-				Value: rcfg.Hostname,
-			},
-		},
-		"accountKey": &jose.JsonWebKey{
-			Key: rcfg.AccountKey,
-		},
-	}
-
-	r.validation, err = json.Marshal(&info)
-	if err != nil {
-		return nil, err
-	}
-
-	return r, nil
-}
-
-func (r *proofOfPossessionResponder) Start() error {
-	return nil
-}
-
-func (r *proofOfPossessionResponder) Stop() error {
-	return nil
-}
-
-func (r *proofOfPossessionResponder) RequestDetectedChan() <-chan struct{} {
-	return nil
-}
-
-func (r *proofOfPossessionResponder) Validation() json.RawMessage {
-	return json.RawMessage(r.validation)
-}
-
-func (r *proofOfPossessionResponder) ValidationSigningKey() crypto.PrivateKey {
-	return r.pk
-}
-
-func init() {
-	RegisterResponder("proofOfPossession", newProofOfPossessionResponder)
-}
diff --git a/responder/reshttp/reshttp.go b/responder/reshttp/reshttp.go
new file mode 100644
index 0000000..17f65ed
--- /dev/null
+++ b/responder/reshttp/reshttp.go
@@ -0,0 +1,151 @@
+// Package reshttp allows multiple goroutines to register challenge responses
+// on an HTTP server concurrently.
+package reshttp
+
+import (
+	"github.com/hlandau/xlog"
+	"gopkg.in/tylerb/graceful.v1"
+	"net"
+	"net/http"
+	"strings"
+	"sync"
+	"time"
+)
+
+var log, Log = xlog.New("acmetool.reshttp")
+
+type PortClaim interface {
+	Close() error
+}
+
+type portClaim struct {
+	port       *port
+	released   bool
+	filename   string
+	body       []byte
+	notifyFunc func()
+}
+
+func (pc *portClaim) Close() error {
+	mutex.Lock()
+	defer mutex.Unlock()
+
+	if pc.released {
+		return nil
+	}
+
+	delete(pc.port.claims, pc.filename)
+
+	pc.port.refcount--
+	if pc.port.refcount == 0 {
+		pc.port.Destroy()
+	}
+
+	pc.released = true
+	return nil
+}
+
+type port struct {
+	addr     string
+	refcount int
+	server   *graceful.Server
+	claims   map[string]*portClaim
+}
+
+func (p *port) Init() error {
+	p.claims = map[string]*portClaim{}
+
+	p.server = &graceful.Server{
+		NoSignalHandling: true,
+		Server: &http.Server{
+			Addr:    p.addr,
+			Handler: p,
+		},
+	}
+
+	l, err := net.Listen("tcp", p.addr)
+	if err != nil {
+		log.Debuge(err, "failed to listen on ", p.addr)
+		return err
+	}
+
+	log.Debugf("listening on %v", p.addr)
+
+	go func() {
+		defer l.Close()
+		p.server.Serve(l)
+	}()
+
+	return nil
+}
+
+func (p *port) Destroy() {
+	delete(ports, p.addr)
+	p.server.Stop(10 * time.Millisecond)
+	<-p.server.StopChan()
+}
+
+func (p *port) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
+	if !strings.HasPrefix(req.URL.Path, "/.well-known/acme-challenge/") {
+		http.NotFound(rw, req)
+		return
+	}
+
+	fn := req.URL.Path[28:]
+	body, notifyFunc := p.getClaim(fn)
+	if body == nil {
+		http.NotFound(rw, req)
+		return
+	}
+
+	rw.Header().Set("Content-Type", "text/plain")
+	rw.Write(body)
+
+	if notifyFunc != nil {
+		notifyFunc()
+	}
+}
+
+func (p *port) getClaim(filename string) (body []byte, notifyFunc func()) {
+	mutex.Lock()
+	defer mutex.Unlock()
+
+	pc, ok := p.claims[filename]
+	if !ok {
+		return nil, nil
+	}
+
+	return pc.body, pc.notifyFunc
+}
+
+var mutex sync.Mutex
+var ports = map[string]*port{}
+
+func AcquirePort(bindAddr, filename string, body []byte, notifyFunc func()) (PortClaim, error) {
+	log.Debugf("acquire port %q %q", bindAddr, filename)
+	mutex.Lock()
+	defer mutex.Unlock()
+
+	p, ok := ports[bindAddr]
+	if !ok {
+		p = &port{
+			addr:     bindAddr,
+			refcount: 0,
+		}
+		err := p.Init()
+		if err != nil {
+			return nil, err
+		}
+		ports[bindAddr] = p
+	}
+
+	p.refcount++
+	pc := &portClaim{
+		port:       p,
+		filename:   filename,
+		body:       body,
+		notifyFunc: notifyFunc,
+	}
+	p.claims[filename] = pc
+	return pc, nil
+}
diff --git a/responder/responder.go b/responder/responder.go
index 7f6dd83..d3978bd 100644
--- a/responder/responder.go
+++ b/responder/responder.go
@@ -50,15 +50,10 @@ type Config struct {
 	AccountKey crypto.PrivateKey // The account private key.
 	Token      string            // The challenge token.
 
-	// "http-01", "proofOfPossession": The hostname being verified. May be used
-	// for pre-initiation self-testing. Optional. Required for
-	// proofOfPossession.
+	// "http-01", "dns-01": The hostname being verified. May be used for
+	// pre-initiation self-testing. Required.
 	Hostname string
 
-	// "proofOfPossession": The certificates which are acceptable. Each entry is
-	// a DER X.509 certificate.
-	AcceptableCertificates [][]byte
-
 	ChallengeConfig ChallengeConfig
 }
 
@@ -76,15 +71,6 @@ type ChallengeConfig struct {
 	// Do not perform self test, but assume challenge is completable.
 	HTTPNoSelfTest bool
 
-	// "proofOfPossession": Function which returns the private key for a given
-	// public key.  This may be called multiple times for a given challenge as
-	// multiple public keys may be permitted. If a private key for the given
-	// public key cannot be found, return nil and do not return an error.
-	// Returning an error short circuits.
-	//
-	// If not specified, proofOfPossession challenges always fail.
-	PriorKeyFunc PriorKeyFunc
-
 	StartHookFunc HookFunc
 	StopHookFunc  HookFunc
 }
diff --git a/responder/tlssni.go b/responder/tlssni.go
deleted file mode 100644
index bf91e47..0000000
--- a/responder/tlssni.go
+++ /dev/null
@@ -1,235 +0,0 @@
-package responder
-
-import (
-	"crypto"
-	"crypto/tls"
-	"encoding/json"
-	"fmt"
-	"github.com/hlandau/acme/acmeapi/acmeutils"
-	"net"
-	"strings"
-)
-
-type TLSSNIChallengeInfo struct {
-	Hostname1, Hostname2 string // must appear in certificate
-	Certificate          []byte
-	Key                  crypto.PrivateKey
-}
-
-type tlssniResponder struct {
-	requestDetectedChan chan struct{}
-	notifySupported     bool
-	rcfg                Config
-
-	stoppedChan        chan struct{}
-	cfg                *tls.Config
-	l                  net.Listener
-	validation         []byte
-	validationHostname string
-	cert               []byte
-	privateKey         crypto.PrivateKey
-}
-
-func newTLSSNIResponder(rcfg Config) (Responder, error) {
-	r := &tlssniResponder{
-		rcfg:                rcfg,
-		requestDetectedChan: make(chan struct{}, 1),
-		stoppedChan:         make(chan struct{}),
-		notifySupported:     true,
-	}
-
-	// Validation hostname.
-	var err error
-	r.validationHostname, err = acmeutils.TLSSNIHostname(rcfg.AccountKey, rcfg.Token)
-	if err != nil {
-		return nil, err
-	}
-
-	// Certificate and private key.
-	r.cert, r.privateKey, err = acmeutils.CreateTLSSNICertificate(r.validationHostname)
-	if err != nil {
-		return nil, err
-	}
-
-	c := &tls.Certificate{
-		Certificate: [][]byte{r.cert},
-		PrivateKey:  r.privateKey,
-	}
-
-	r.cfg = &tls.Config{
-		Certificates: []tls.Certificate{*c},
-	}
-
-	// Validation response.
-	r.validation, err = acmeutils.ChallengeResponseJSON(rcfg.AccountKey, rcfg.Token, "tls-sni-01")
-	if err != nil {
-		return nil, err
-	}
-
-	return r, nil
-}
-
-// Internal use only. This can be used to change the port the TLSSNI responder
-// listens on for development purposes.
-var InternalTLSSNIPort uint16 = 443
-
-func (r *tlssniResponder) Start() error {
-	listenErr := r.startListener()
-	log.Debuge(listenErr, "failed to start TLS-SNI listener")
-
-	// Try hooks.
-	var hookErr error
-	if startFunc := r.rcfg.ChallengeConfig.StartHookFunc; startFunc != nil {
-		hookErr = startFunc(&TLSSNIChallengeInfo{
-			Hostname1:   r.validationHostname,
-			Hostname2:   r.validationHostname,
-			Certificate: r.cert,
-			Key:         r.privateKey,
-		})
-		log.Debuge(hookErr, "failed to install TLS-SNI challenge via hook")
-	}
-
-	if listenErr != nil && hookErr != nil {
-		return listenErr
-	}
-
-	err := r.selfTest()
-	if err != nil {
-		log.Debuge(err, "tls-sni-01 self-test failed")
-		r.Stop()
-		return err
-	}
-
-	return nil
-}
-
-func (r *tlssniResponder) startListener() error {
-	l, err := tls.Listen("tcp", fmt.Sprintf(":%d", InternalTLSSNIPort), r.cfg)
-	if err != nil {
-		return err
-	}
-
-	r.l = l
-	go func() {
-		defer close(r.stoppedChan)
-		defer l.Close()
-
-		for {
-			c, err := l.Accept()
-			if err != nil {
-				break
-			}
-
-			c.(*tls.Conn).Handshake() // Ignore error
-			c.Close()
-			r.notify()
-		}
-	}()
-
-	return nil
-}
-
-func (r *tlssniResponder) Stop() error {
-	if r.l != nil {
-		r.l.Close()
-		<-r.stoppedChan
-		r.l = nil
-	}
-
-	// Try hooks.
-	if stopFunc := r.rcfg.ChallengeConfig.StopHookFunc; stopFunc != nil {
-		err := stopFunc(&TLSSNIChallengeInfo{
-			Hostname1:   r.validationHostname,
-			Hostname2:   r.validationHostname,
-			Certificate: r.cert,
-			Key:         r.privateKey,
-		})
-		log.Errore(err, "failed to uninstall TLS-SNI challenge via hook")
-	}
-
-	return nil
-}
-
-func containsHostname(hostname string, hostnames []string) bool {
-	for _, x := range hostnames {
-		if strings.TrimSuffix(strings.ToLower(x), ".") == hostname {
-			return true
-		}
-	}
-	return false
-}
-
-func (r *tlssniResponder) selfTest() error {
-	if r.rcfg.Hostname == "" {
-		return nil
-	}
-
-	conn, err := tls.Dial("tcp", net.JoinHostPort(r.rcfg.Hostname, fmt.Sprintf("%d", InternalTLSSNIPort)), &tls.Config{
-		ServerName:         r.validationHostname,
-		InsecureSkipVerify: true,
-	})
-	if err != nil {
-		return err
-	}
-
-	defer conn.Close()
-	err = conn.Handshake()
-	if err != nil {
-		return err
-	}
-
-	certs := conn.ConnectionState().PeerCertificates
-	if len(certs) != 1 {
-		return fmt.Errorf("when doing self-test, got %d certificates, expected 1", len(certs))
-	}
-
-	if !containsHostname(r.validationHostname, certs[0].DNSNames) {
-		return fmt.Errorf("certificate does not contain expected challenge name")
-	}
-
-	// If we detected a request, we support notifications, otherwise we don't.
-	select {
-	case <-r.requestDetectedChan:
-	default:
-		r.notifySupported = false
-	}
-
-	// Drain the notification channel in case we somehow made several requests.
-L:
-	for {
-		select {
-		case <-r.requestDetectedChan:
-		default:
-			break L
-		}
-	}
-
-	return nil
-}
-
-func (r *tlssniResponder) notify() {
-	select {
-	case r.requestDetectedChan <- struct{}{}:
-	default:
-	}
-}
-
-func (r *tlssniResponder) RequestDetectedChan() <-chan struct{} {
-	if !r.notifySupported {
-		return nil
-	}
-
-	return r.requestDetectedChan
-}
-
-func (r *tlssniResponder) Validation() json.RawMessage {
-	return json.RawMessage(r.validation)
-}
-
-func (r *tlssniResponder) ValidationSigningKey() crypto.PrivateKey {
-	return nil
-}
-
-func init() {
-	RegisterResponder("tls-sni-01", newTLSSNIResponder)
-}
diff --git a/solver/order.go b/solver/order.go
new file mode 100644
index 0000000..bc5e6dc
--- /dev/null
+++ b/solver/order.go
@@ -0,0 +1,479 @@
+package solver
+
+import (
+	"context"
+	"fmt"
+	"git.devever.net/hlandau/acmeapi"
+	"git.devever.net/hlandau/acmetool/responder"
+	"git.devever.net/hlandau/acmetool/util"
+	denet "github.com/hlandau/goutils/net"
+	"github.com/hlandau/xlog"
+	"sync"
+	"time"
+)
+
+var log, Log = xlog.New("acmetool.solver")
+
+type blacklist struct {
+	mutex sync.Mutex
+	m     map[string]struct{}
+}
+
+func blacklistKey(hostname, challengeType string) string {
+	return challengeType + "\n" + hostname
+}
+
+func (b *blacklist) Check(hostname, challengeType string) bool {
+	b.mutex.Lock()
+	defer b.mutex.Unlock()
+
+	_, ok := b.m[blacklistKey(hostname, challengeType)]
+	return ok
+}
+
+func (b *blacklist) Add(hostname, challengeType string) {
+	b.mutex.Lock()
+	defer b.mutex.Unlock()
+
+	b.m[blacklistKey(hostname, challengeType)] = struct{}{}
+}
+
+// Creates, fulfils and finalises an order. Automatically tries different
+// challenges to the extent possible, and creates orders again if necessary
+// after challenge failure, until success or unrecoverable failure.
+func Order(ctx context.Context, rc *acmeapi.RealmClient, acct *acmeapi.Account, orderTemplate *acmeapi.Order, csr []byte, ccfg *responder.ChallengeConfig) (*acmeapi.Order, error) {
+
+	// Make order.
+	// Progress the order. => result: Success | Retry | Fail
+
+	// Fulfil authorizations.
+	//   Fulfil challenges by preference/previously failed info; keep prev. failed for (hostname, challenge type)
+	//   Retry stuff
+	//   Start again if authorization becomes permanently failed
+	//   Have faith
+	// Finalise
+
+	bl := blacklist{m: map[string]struct{}{}}
+
+	for {
+		order := *orderTemplate
+
+		err := rc.NewOrder(ctx, acct, &order)
+		if err != nil {
+			return nil, err
+		}
+
+		shouldRetry, err := orderProcess(ctx, rc, acct, &order, csr, ccfg, &bl)
+		if err == nil {
+			return &order, nil
+		}
+		if !shouldRetry {
+			return nil, err
+		}
+	}
+}
+
+// Take a newly created order object as far as possible.
+//
+// Returns in one of three states:
+//   - Success:                       err == nil  -- OK
+//       We're done.
+//   - Fail:    shouldRetry == true,  err != nil  -- Order failed but keep making new orders
+//       Causes a new order to be made to start the process again.
+//   - Fatal:   shouldRetry == false, err != nil	-- Order failed and we will never succeed, so stop
+//       Stops the order process.
+func orderProcess(ctx context.Context, rc *acmeapi.RealmClient, acct *acmeapi.Account, order *acmeapi.Order, csr []byte, ccfg *responder.ChallengeConfig, bl *blacklist) (shouldRetry bool, err error) {
+	// We just created the order, so it shouldn't be invalid. If it is, there's
+	// no way we can get anywhere no matter how many times we try..
+	switch order.Status {
+	case acmeapi.OrderPending:
+	case acmeapi.OrderReady:
+		break
+	default:
+		return false, fmt.Errorf("order (%q) was in state %q as soon as it was created, cannot continue", order.URL, order.Status)
+	}
+
+	if order.Status == acmeapi.OrderPending {
+		shouldRetry, err := orderAuthorizeAll(ctx, rc, acct, order, ccfg, bl)
+		if err != nil {
+			return shouldRetry, err
+		}
+
+		// Get a fresh picture of the order status. orderAuthorizeAll doesn't refresh it.
+		err = rc.LoadOrder(ctx, order)
+		if err != nil {
+			return true, err
+		}
+	}
+
+	// TODO: REMOVE LET'S ENCRYPT WORKAROUND once they fix this
+	allowBoulderBugfix := true
+
+	if order.Status != acmeapi.OrderReady && (!allowBoulderBugfix || order.Status != acmeapi.OrderPending) {
+		return false, fmt.Errorf("finished authorizing order (%q) but status is not ready, got %q", order.URL, order.Status)
+	}
+
+	// Request issuance.
+	err = rc.Finalize(ctx, acct, order, csr)
+	if err != nil {
+		// If finalization failed, this suggests something wrong with the CSR and retrying will be
+		// pointless, so stop here.
+		return false, err
+	}
+
+	return false, nil
+}
+
+// Tries to complete all the authorizations on an order.
+//
+// Returns in one of three states:
+//   - Success:                        err == nil  -- OK
+//       We're done
+//   - Fail:     shouldRetry == true,  err != nil  -- One or more authorizations are dead, but subsequent orders might succeed
+//       Cause a new order to be made to start the process again.
+//   - Fatal:    shouldRetry == false, err != nil  -- One or more authorizations are unfulfillable and subsequent orders will never succeed
+//       Stops the order process.
+func orderAuthorizeAll(ctx context.Context, rc *acmeapi.RealmClient, acct *acmeapi.Account, order *acmeapi.Order, ccfg *responder.ChallengeConfig, bl *blacklist) (shouldRetry bool, err error) {
+	type result struct {
+		isFatal bool
+		err     error
+	}
+
+	ch := make(chan result, len(order.AuthorizationURLs))
+
+	for i := range order.AuthorizationURLs {
+		authURL := order.AuthorizationURLs[i]
+		go func() {
+			ctxAuth := ctx // TODO
+			isFatal, err := orderAuthorizeOne(ctxAuth, rc, acct, authURL, ccfg, bl)
+			ch <- result{isFatal, err}
+		}()
+	}
+
+	var errors util.MultiError
+	isFatal := false
+	for i := 0; i < len(order.AuthorizationURLs); i++ {
+		r := <-ch
+		if r.isFatal {
+			// CANCEL ALL
+			isFatal = true
+		}
+
+		if r.err != nil {
+			errors = append(errors, r.err)
+		}
+	}
+
+	if len(errors) > 0 {
+		return !isFatal, errors
+	}
+
+	return true, nil
+}
+
+// Tries to complete one authorization given the URL to it. Tries challenges in
+// sequence until the authorization becomes invalid or it is determined that
+// none of the challenges will work. Avoids challenges which are already
+// blacklisted and blacklists challenges which fail for the given (hostname,
+// challengeType).
+//
+// Returns in one of three states:
+//   - Success:                           err == nil  -- OK
+//       We're done, authorization is now good
+//   - Fail:            isFatal == false, err != nil  -- Authorization is unfulfillable but subsequent orders might succeed
+//       Cause a new order to be made to start the process again. Challenge
+//       blacklisting means a different strategy to complete the authorization
+//       will be attempted next time.
+//   - Fatal:           isFatal == true,  err != nil  -- Authorization is unfulfillable and subsequent orders will never succeed
+//       Authorization process failed and it has been determined that no
+//       corresponding successor authorization in a subsequent order could ever
+//       succeed either. Give up.
+func orderAuthorizeOne(ctx context.Context, rc *acmeapi.RealmClient, acct *acmeapi.Account, authURL string, ccfg *responder.ChallengeConfig, bl *blacklist) (isFatal bool, err error) {
+	authz := &acmeapi.Authorization{
+		URL: authURL,
+	}
+
+	// Load authorization.
+	err = rc.LoadAuthorization(ctx, acct, authz)
+	if err != nil {
+		// Assume a transient problem, return FAIL. If there is e.g. a network
+		// issue, creation of a new order will fail and that will be fatal, so not
+		// checking for fatal errors here is of little consequence.
+		return
+	}
+
+	// If an authorization was invalid at the outset, consider this a fatal
+	// error, otherwise we will just retry with new orders forever but never be
+	// able to make any progress. We can only get here if the order is not
+	// invalid, so this should only happen if the server creates new orders with
+	// a non-final order status but an invalid authorization, which shouldn't
+	// happen. Guard against it just in case.
+	if authz.Status == acmeapi.AuthorizationInvalid {
+		// Return FATAL.
+		isFatal = true
+		err = fmt.Errorf("authorization %q is invalid from the outset, even though order isn't", authz.URL)
+		return
+	}
+
+	var challengeErrors util.MultiError
+	outOfChallenges := false
+	for {
+		// If authorization has come to have a final state, return.
+		//
+		// This will occur either because
+		//   - this function has now successfully completed the authorization, or
+		//   - because the authorization was created in a final state (e.g. valid)
+		//     as soon as the order was created; this can happen if the server
+		//     carries over previous successful authorizations, etc.
+		// This also handles cases where an authorization randomly transitions to
+		// valid, though these aren't expected.
+		if authz.Status.IsFinal() {
+			if authz.Status == acmeapi.AuthorizationValid {
+				// Return SUCCESS.
+				return
+			}
+
+			// Authorization is dead and cannot be recovered. Return FAIL,
+			// creating a new order and starting the process again.
+			isFatal = outOfChallenges
+			err = util.NewWrapError(challengeErrors, "authorization %q has non-valid final status %q", authz.URL, authz.Status)
+			return
+		}
+
+		// If any challenge is valid, WTF? Return FATAL.
+		for i := range authz.Challenges {
+			if authz.Challenges[i].Status == acmeapi.ChallengeValid {
+				err = fmt.Errorf("authorization %q has non-final status but contains a valid challenge: %q", authz.URL, authz.Status)
+				isFatal = true
+				return
+			}
+		}
+
+		// If the authorization is not for a DNS identifier, return FATAL.
+		if authz.Identifier.Type != acmeapi.IdentifierTypeDNS {
+			err = fmt.Errorf("unsupported authorization identifier type %q, value %q", authz.Identifier.Type, authz.Identifier.Value)
+			isFatal = true
+			return
+		}
+
+		// Sort challenges by preference.
+		preferenceOrder := SortChallenges(authz, PreferFast)
+
+		// Initiate most preferred non-invalid challenge.
+		preferred := ""
+		secondBestPreferred := ""
+		for _, i := range preferenceOrder {
+			ch := &authz.Challenges[i]
+			if !bl.Check(authz.Identifier.Value, ch.Type) && !ch.Status.IsFinal() {
+				if preferred == "" {
+					preferred = ch.URL
+				} else if secondBestPreferred == "" {
+					secondBestPreferred = ch.URL
+				} else {
+					break
+				}
+			}
+		}
+
+		// If we've blacklisted all challenges, return FATAL.
+		if preferred == "" {
+			err = util.NewWrapError(challengeErrors, "exhausted all possible challenges in authorization %q", authz.URL)
+			isFatal = true
+			return
+		}
+
+		// Try and complete our preferred challenge. If it fails, blacklist it.
+		// orderCompleteChallenge returns once the challenge has succeeded, or once
+		// it has been determined that it definitely cannot be completed, or once a
+		// reasonable effort has been made (e.g. retry limit reached) without
+		// success. In failure cases (err != nil), the authorization may or may not
+		// have entered a final-invalid state as a result of this, so don't assume
+		// the authorization has become final-invalid.
+		ch, ok := findChallengeByURL(authz, preferred)
+		if !ok {
+			panic("challenge disappeared")
+		}
+
+		var authWasLoaded bool
+		authWasLoaded, err = orderCompleteChallenge(ctx, rc, acct, authz, ch.URL, ccfg)
+		if err != nil {
+			// This (hostname, challengeType) failed, so blacklist it so we don't try
+			// it again for the duration of this ordering process.
+			bl.Add(authz.Identifier.Value, ch.Type)
+
+			// As an optimisation, return FATAL instead of FAIL if the challenge we
+			// just blacklisted was the final non-blacklisted challenge. This is an
+			// optimization; if we don't do this, we'll create another order and call
+			// this function, orderAuthorizeOne, again before bailing at "exhausted
+			// all possible challenges" above. We can avoid this unnecessary creation
+			// of an unused order by checking if this is the last non-blacklisted
+			// challenge we're blacklisting.
+			outOfChallenges = (secondBestPreferred == "")
+
+			// Record the error.
+			challengeErrors = append(challengeErrors, err)
+		}
+
+		// Whether or not orderCompleteChallenge thinks the challenge apparently
+		// failed or not, just reload the authorization to check its current state
+		// and take that as the actual source of truth (unless
+		// orderCompleteChallenge just loaded it). This should be the most reliable
+		// strategy. We check whether the authorization has gone final when we
+		// continue the loop.
+		if !authWasLoaded {
+			err = rc.LoadAuthorization(ctx, acct, authz)
+			if err != nil {
+				return
+			}
+		}
+	}
+}
+
+// Tries to complete a single challenge. Returns after it has been completed,
+// after it has been determined that it can no longer be completed, or after a
+// reasonable effort has been made to complete it.
+//
+// (If the server implements some manner of evergreen challenge which never
+// goes invalid, we don't want to retry forever as the means of completing the
+// challenge may not be setup, so we only try once. Retries after spurious
+// errors can be handled by the higher levels which invoke this, e.g. at the
+// next invocation of acmetool — we probably can't reliably ascertain whether
+// an error is spurious ourselves, so we just try once and assume that retries
+// will be handled by our invoker.)
+//
+// Returns in one of two states:
+//   - Success:      err == nil  -- OK
+//       Challenge was successfully completed; authorization should now be
+//       final-valid.
+//   - Fail:         err != nil  -- Challenge was attempted one time and failed, authorization MAY OR MAY NOT be final-invalid
+//       Challenge was not successfully completed. This may or may not have
+//       caused the authorization to transition to final-invalid; for example,
+//       some challenges may fail before making any request to the ACME server
+//       at all, for example if they detect that they have not been configured
+//       (e.g. DNS challenges without any DNS hooks installed). By not assuming
+//       the authorization has become invalid we can avoid creating unnecessary
+//       orders.
+//
+// As an optimization, we return whether we reloaded the authorization after
+// any possible status changes, which means the caller doesn't need to reload
+// it again.
+func orderCompleteChallenge(ctx context.Context, rc *acmeapi.RealmClient, acct *acmeapi.Account, authz *acmeapi.Authorization, challengeURL string, ccfg *responder.ChallengeConfig) (authWasLoaded bool, err error) {
+	oldCh, ok := findChallengeByURL(authz, challengeURL)
+	if !ok {
+		err = fmt.Errorf("challenge %q does not appear in authorization %q", challengeURL, authz.URL)
+		return
+	}
+
+	// A challenge might remain pending after we fail to complete it if the
+	// server is still willing to retry it. Since we want to limit how long we
+	// wait for a challenge to complete, we count the number of errors listed for
+	// the challenge by the server. When the number of errors increase (or the
+	// challenge goes valid), we consider that to be one attempt and stop.
+	oldCount := countErrors(&oldCh)
+
+	// Get responder ready.
+	r, err := responder.New(responder.Config{
+		Type:            oldCh.Type,
+		Token:           oldCh.Token,
+		AccountKey:      acct.PrivateKey,
+		Hostname:        authz.Identifier.Value,
+		ChallengeConfig: *ccfg,
+	})
+	if err != nil {
+		log.Debuge(err, "challenge instantiation failed")
+		return
+	}
+
+	err = r.Start()
+	if err != nil {
+		log.Debuge(err, "challenge start failed")
+		return
+	}
+
+	defer r.Stop()
+
+	// RESPOND
+	err = rc.RespondToChallenge(ctx, acct, &oldCh, r.Validation()) //r.ValidationSigningKey()
+	if err != nil {
+		return
+	}
+
+	b := denet.Backoff{
+		InitialDelay: 5 * time.Second,
+		MaxDelay:     30 * time.Second,
+	}
+
+	for {
+		// Wait until we have some suspicion that the challenge may have been
+		// completed.
+		log.Debugf("challenge %q (%q): waiting to poll", oldCh.URL, oldCh.Type)
+		select {
+		case <-ctx.Done():
+			err = ctx.Err()
+			return
+		case <-r.RequestDetectedChan():
+			log.Debugf("challenge %q (%q): request detected", oldCh.URL, oldCh.Type)
+		case <-time.After(b.NextDelay()):
+			log.Debugf("challenge %q (%q): periodically checking", oldCh.URL, oldCh.Type)
+		}
+
+		// We could reload just the challenge, but there's not much point, since
+		// the challenges are embedded inline in the authorization, and this keeps
+		// the authorization object up-to-date too.
+		log.Debugf("challenge %q (%q): querying status", oldCh.URL, oldCh.Type)
+		err = rc.WaitLoadAuthorization(ctx, acct, authz)
+		if err != nil {
+			return
+		}
+
+		authWasLoaded = true
+
+		updatedCh, ok := findChallengeByURL(authz, challengeURL)
+		if !ok {
+			err = fmt.Errorf("challenge %q has disappeared from authorization %q", challengeURL, authz.URL)
+			return
+		}
+
+		if updatedCh.Status == acmeapi.ChallengeValid {
+			// Challenge is valid, we're done here.
+			err = nil
+			return
+		}
+
+		if updatedCh.Status.IsFinal() {
+			// The challenge is final but not valid; there is no further prospect of
+			// completing this challenge.
+			err = util.NewWrapError(updatedCh.Error, "authorization %q challenge %q failed into final non-valid status %v", authz.URL, challengeURL, updatedCh.Status)
+			log.Infoe(err, "unsuccessful challenge")
+			return
+		}
+
+		// TODO: allow number of error-tries to be tolerated before bailing to be
+		// configured; currently fix it at 1.
+		if countErrors(&updatedCh) != oldCount {
+			err = util.NewWrapError(updatedCh.Error, "authorization %q challenge %q failed", authz.URL, challengeURL)
+			log.Infoe(err, "unsuccessful challenge")
+			return
+		}
+	}
+}
+
+func findChallengeByURL(authz *acmeapi.Authorization, challengeURL string) (acmeapi.Challenge, bool) {
+	for i := range authz.Challenges {
+		if authz.Challenges[i].URL == challengeURL {
+			return authz.Challenges[i], true
+		}
+	}
+	return acmeapi.Challenge{}, false
+}
+
+func countErrors(ch *acmeapi.Challenge) int {
+	if ch == nil || ch.Error == nil {
+		return 0
+	}
+	n := len(ch.Error.Subproblem)
+	if n == 0 {
+		return 1
+	}
+	return n
+}
diff --git a/solver/preference.go b/solver/preference.go
index 083fdcf..d5bae2b 100644
--- a/solver/preference.go
+++ b/solver/preference.go
@@ -1,57 +1,57 @@
 package solver
 
 import (
-	"github.com/hlandau/acme/acmeapi"
+	"git.devever.net/hlandau/acmeapi"
 	"sort"
 )
 
 // Any challenge having a preference at or below this value will never be used.
 const NonviableThreshold int32 = -1000000
 
-// Sorter.
 type sorter struct {
 	authz       *acmeapi.Authorization
+	order       []int
 	preferencer Preferencer
 }
 
 func (s *sorter) Len() int {
-	return len(s.authz.Combinations)
+	return len(s.order)
 }
 
 func (s *sorter) Swap(i, j int) {
-	s.authz.Combinations[i], s.authz.Combinations[j] = s.authz.Combinations[j], s.authz.Combinations[i]
+	s.order[i], s.order[j] = s.order[j], s.order[i]
 }
 
 func (s *sorter) Less(i, j int) bool {
-	pi := s.preference(s.authz.Combinations[i]...)
-	pj := s.preference(s.authz.Combinations[j]...)
+	pi := s.preference(&s.authz.Challenges[i])
+	pj := s.preference(&s.authz.Challenges[j])
 	return pi < pj
 }
 
-func (s *sorter) preference(idx ...int) int32 {
-	p := int32(0)
-	for _, i := range idx {
-		if i >= len(s.authz.Challenges) || p <= NonviableThreshold {
-			return NonviableThreshold
-		}
-
-		v := s.preferencer.Preference(s.authz.Challenges[i])
-		p = satAdd(p, v)
+func (s *sorter) preference(ch *acmeapi.Challenge) int32 {
+	v := s.preferencer.Preference(ch)
+	if v <= NonviableThreshold {
+		return NonviableThreshold
 	}
-	return p
+
+	return v
 }
 
-func satAdd(x, y int32) int32 {
-	v := int64(x) + int64(y)
-	if v > int64(-NonviableThreshold) {
-		return -NonviableThreshold
+// Returns a list of indices to authz.Challenges, sorted by preference, most
+// preferred first.
+func SortChallenges(authz *acmeapi.Authorization, preferencer Preferencer) (preferenceOrder []int) {
+	preferenceOrder = make([]int, len(authz.Challenges))
+	for i := 0; i < len(authz.Challenges); i++ {
+		preferenceOrder[i] = i
 	}
 
-	if v < int64(NonviableThreshold) {
-		return NonviableThreshold
+	s := sorter{
+		authz:       authz,
+		order:       preferenceOrder,
+		preferencer: preferencer,
 	}
-
-	return int32(v)
+	sort.Stable(sort.Reverse(&s))
+	return
 }
 
 // TypePreferencer returns a preference according to the type of the challenge.
@@ -80,16 +80,13 @@ func (p TypePreferencer) Copy() TypePreferencer {
 
 // PreferFast prefers fast types.
 var PreferFast = TypePreferencer{
+	"tls-sni-02": 2,
 	"tls-sni-01": 1,
 	"http-01":    0,
 
 	// Disable DNS challenges for now. They're practically unusable and the Let's
 	// Encrypt live server doesn't support them at this time anyway.
 	"dns-01": -10,
-
-	// Avoid unless necessary. In future we might want to determine whether we
-	// have a key and prefer this accordingly.
-	"proofOfPossession:": -40,
 }
 
 // Determines the degree to which a challenge is preferred. Higher values are
@@ -98,21 +95,3 @@ type Preferencer interface {
 	// Get the preference for the given challenge.
 	Preference(ch *acmeapi.Challenge) int32
 }
-
-// Sort authorization combinations by preference. Crops Combinations to viable
-// combinations.
-func SortCombinations(authz *acmeapi.Authorization, preferencer Preferencer) {
-	s := sorter{
-		authz:       authz,
-		preferencer: preferencer,
-	}
-	sort.Stable(sort.Reverse(&s))
-
-	for i := range authz.Combinations {
-		pi := s.preference(authz.Combinations[i]...)
-		if pi <= NonviableThreshold {
-			authz.Combinations = authz.Combinations[0:i]
-			return
-		}
-	}
-}
diff --git a/solver/register.go b/solver/register.go
index 6e8b717..120448f 100644
--- a/solver/register.go
+++ b/solver/register.go
@@ -2,67 +2,96 @@ package solver
 
 import (
 	"fmt"
-	"github.com/hlandau/acme/acmeapi"
-	"github.com/hlandau/acme/interaction"
+	"git.devever.net/hlandau/acmeapi"
+	"git.devever.net/hlandau/acmetool/interaction"
 	"golang.org/x/net/context"
 	"net/mail"
 )
 
-// Using the given client and interactor (or interaction.Auto if nil), register
-// the client account if it does not already exist.
+// Using the given client, account and interactor (or interaction.Auto if nil),
+// register the client account if it does not already exist. Does not do anything
+// and does NOT update the registration if the account is already registered.
 //
 // The interactor is used to prompt for terms of service agreement, if
 // agreement has not already been obtained. An e. mail address is prompted for.
-func AssistedUpsertRegistration(cl *acmeapi.Client, interactor interaction.Interactor, ctx context.Context) error {
+func AssistedRegistration(ctx context.Context, cl *acmeapi.RealmClient, acct *acmeapi.Account, interactor interaction.Interactor) error {
 	interactor = defaultInteraction(interactor)
 
-	email := ""
+	// We know for a fact the account has already been registered because we know
+	// its URL. Don't do anything.
+	if acct.URL != "" {
+		return nil
+	}
 
-	reg := &acmeapi.Registration{}
-	agreementURIs := map[string]struct{}{}
-	for {
-		err := cl.AgreeRegistration(reg, agreementURIs, ctx)
-		if err != nil {
-			if e, ok := err.(*acmeapi.AgreementError); ok {
-				res, err := interactor.Prompt(&interaction.Challenge{
-					Title:        "Terms of Service Agreement Required",
-					YesLabel:     "I Agree",
-					NoLabel:      "Cancel",
-					ResponseType: interaction.RTYesNo,
-					UniqueID:     "acme-agreement:" + e.URI,
-					Prompt:       "Do you agree to the Terms of Service?",
-					Body: fmt.Sprintf(`You must agree to the terms of service at the following URL to continue:
+	// See if the account has already been registered. If so, the URL gets stored
+	// in acct.URL and we're done.
+	err := cl.LocateAccount(ctx, acct)
+	if err == nil {
+		return nil
+	}
+
+	// Check that the error that occured was a not found error.
+	he, ok := err.(*acmeapi.HTTPError)
+	if !ok {
+		return err
+	}
+	if he.Problem == nil || he.Problem.Type != "urn:ietf:params:acme:error:accountDoesNotExist" {
+		return err
+	}
+
+	// Get the directory metadata so we can get the terms of service URL.
+	meta, err := cl.GetMeta(ctx)
+	if err != nil {
+		return err
+	}
+
+	// Prompt for ToS agreement if required.
+	acct.TermsOfServiceAgreed = false
+	if meta.TermsOfServiceURL != "" {
+		res, err := interactor.Prompt(&interaction.Challenge{
+			Title:        "Terms of Service Agreement Required",
+			YesLabel:     "I Agree",
+			NoLabel:      "Cancel",
+			ResponseType: interaction.RTYesNo,
+			UniqueID:     "acme-agreement:" + meta.TermsOfServiceURL,
+			Prompt:       "Do you agree to the Terms of Service?",
+			Body: fmt.Sprintf(`You must agree to the terms of service at the following URL to continue:
 
 %s
 
-Do you agree to the terms of service set out in the above document?`, e.URI),
-				})
-				if err != nil {
-					return err
-				}
-				if !res.Cancelled {
-					if email == "" {
-						email, err = getEmail(interactor)
-						if err != nil {
-							return err
-						}
-						if email == "-" {
-							return fmt.Errorf("e. mail input cancelled")
-						}
-					}
-
-					reg.AgreementURI = e.URI
-					agreementURIs[e.URI] = struct{}{}
-					if email != "" {
-						reg.ContactURIs = []string{"mailto:" + email}
-					}
-					continue
-				}
-			}
+Do you agree to the terms of service set out in the above document?`, meta.TermsOfServiceURL),
+		})
+		if err != nil {
+			return err
 		}
 
+		if res.Cancelled {
+			return fmt.Errorf("terms of service agreement is required, but user declined")
+		}
+
+		acct.TermsOfServiceAgreed = true
+	}
+
+	// Get e. mail.
+	email, err := getEmail(interactor)
+	if err != nil {
 		return err
 	}
+	if email == "-" {
+		return fmt.Errorf("e. mail input cancelled")
+	}
+
+	if email != "" {
+		acct.ContactURIs = []string{"mailto:" + email}
+	}
+
+	// Do the registration.
+	err = cl.RegisterAccount(ctx, acct)
+	if err != nil {
+		return err
+	}
+
+	return nil
 }
 
 func getEmail(interactor interaction.Interactor) (string, error) {
diff --git a/solver/respond.go b/solver/respond.go
deleted file mode 100644
index 81adc07..0000000
--- a/solver/respond.go
+++ /dev/null
@@ -1,189 +0,0 @@
-// Package solver figures out how to complete authorizations and completes them
-// by instantiating responders.
-package solver
-
-import (
-	"fmt"
-	"github.com/hlandau/acme/acmeapi"
-	"github.com/hlandau/acme/responder"
-	denet "github.com/hlandau/goutils/net"
-	"github.com/hlandau/xlog"
-	"golang.org/x/net/context"
-	"time"
-)
-
-var log, Log = xlog.New("acme.solver")
-
-// Returned if all combinations fail.
-var ErrFailedAllCombinations = fmt.Errorf("failed all combinations")
-
-type authState struct {
-	c            *acmeapi.Client
-	dnsName      string
-	ccfg         responder.ChallengeConfig
-	ctx          context.Context
-	pref         TypePreferencer
-	webPaths     []string
-	listenAddrs  []string
-	priorKeyFunc responder.PriorKeyFunc
-}
-
-// Attempts to authorize a hostname using the given client. webPaths and
-// priorKeyFunc are passed to responders. Returns the successfully validated
-// authorization on success.
-func Authorize(c *acmeapi.Client, dnsName string, ccfg responder.ChallengeConfig, ctx context.Context) (*acmeapi.Authorization, error) {
-	as := authState{
-		c:       c,
-		dnsName: dnsName,
-		ctx:     ctx,
-		pref:    PreferFast.Copy(),
-		ccfg:    ccfg,
-	}
-
-	for {
-		az, fatal, err := as.authorize()
-		if err == nil {
-			return az, nil
-		}
-
-		if fatal {
-			return nil, err
-		}
-	}
-}
-
-func (as *authState) authorize() (az *acmeapi.Authorization, fatal bool, err error) {
-	az, err = as.c.NewAuthorization(as.dnsName, as.ctx)
-	if err != nil {
-		return nil, true, err
-	}
-
-	SortCombinations(az, as.pref)
-
-	for _, com := range az.Combinations {
-		invalidated, err := as.attemptCombination(az, com)
-		if err != nil {
-			if !invalidated {
-				continue
-			}
-
-			// The combination failed and failed challenge types have been removed
-			// from the preference map. Assume that a newly created authorization
-			// will offer the same combinations. So, if we still don't have a
-			// viable combination, we fail here rather than creating an authorization
-			// that won't get used.
-			if !as.haveAnyViableCombinations(az) {
-				break
-			}
-
-			return nil, false, err
-		}
-		return az, false, nil
-	}
-
-	return nil, true, ErrFailedAllCombinations
-}
-
-func (as *authState) haveAnyViableCombinations(az *acmeapi.Authorization) bool {
-	for _, com := range az.Combinations {
-		for _, i := range com {
-			ch := az.Challenges[i]
-			p, ok := as.pref[ch.Type]
-			if ok && p > NonviableThreshold {
-				return true
-			}
-		}
-	}
-	return false
-}
-
-func (as *authState) attemptCombination(az *acmeapi.Authorization, combination []int) (invalidated bool, err error) {
-	for _, i := range combination {
-		ch := az.Challenges[i]
-		invalidated, err := CompleteChallenge(as.c, ch, as.dnsName, as.ccfg, as.ctx)
-		if err != nil {
-			delete(as.pref, ch.Type)
-			return invalidated, err
-		}
-	}
-
-	return false, nil
-}
-
-// Completes a given challenge, polling it until it is complete. Can be
-// cancelled using ctx.
-//
-// dnsName is the hostname which is being authorized. webPaths and priorKeyFunc
-// are passed to responders.
-//
-// The return value indicates whether the whole authorization has been invalidated
-// (set to "failed" status) as a result of an error. In this case a new authorization
-// must be created.
-func CompleteChallenge(c *acmeapi.Client, ch *acmeapi.Challenge, dnsName string, ccfg responder.ChallengeConfig, ctx context.Context) (invalidated bool, err error) {
-	log.Debugf("attempting challenge type %s", ch.Type)
-
-	var certs [][]byte
-	for _, c := range ch.Certs {
-		certs = append(certs, c)
-	}
-
-	r, err := responder.New(responder.Config{
-		Type:                   ch.Type,
-		Token:                  ch.Token,
-		AccountKey:             c.AccountKey,
-		Hostname:               dnsName,
-		AcceptableCertificates: certs,
-		ChallengeConfig:        ccfg,
-	})
-
-	if err != nil {
-		log.Debuge(err, "challenge instantiation failed")
-		return false, err
-	}
-
-	err = r.Start()
-	if err != nil {
-		log.Debuge(err, "challenge start failed")
-		return false, err
-	}
-
-	defer r.Stop()
-
-	err = c.RespondToChallenge(ch, r.Validation(), r.ValidationSigningKey(), ctx)
-	if err != nil {
-		return false /* ??? */, err
-	}
-
-	b := denet.Backoff{
-		InitialDelay: 5 * time.Second,
-		MaxDelay:     30 * time.Second,
-	}
-
-	for {
-		log.Debug("waiting to poll challenge")
-		select {
-		case <-ctx.Done():
-			return true, ctx.Err()
-		case <-r.RequestDetectedChan():
-			log.Debug("request detected")
-		case <-time.After(b.NextDelay()):
-		}
-
-		log.Debug("querying challenge status")
-		err := c.WaitLoadChallenge(ch, ctx)
-		if err != nil {
-			return false, err
-		}
-
-		if ch.Status.Final() {
-			log.Debug("challenge now in final state")
-			break
-		}
-	}
-
-	if ch.Status != "valid" {
-		return true, fmt.Errorf("challenge failed with status %#v", ch.Status)
-	}
-
-	return false, nil
-}
diff --git a/storage/abs.go b/storage/abs.go
index 62ebaf4..8ead29d 100644
--- a/storage/abs.go
+++ b/storage/abs.go
@@ -51,4 +51,5 @@ type Store interface {
 	WriteMiscellaneousConfFile(filename string, data []byte) error
 }
 
+// Return this sentinel value to stop visitation.
 var StopVisiting = errors.New("[stop visiting]")
diff --git a/storage/config.go b/storage/config.go
index 03b3542..f3f2cf7 100644
--- a/storage/config.go
+++ b/storage/config.go
@@ -2,7 +2,7 @@ package storage
 
 import (
 	"crypto/elliptic"
-	"github.com/hlandau/acme/fdb"
+	"git.devever.net/hlandau/acmetool/fdb"
 	"strings"
 )
 
diff --git a/storage/storage-fdb.go b/storage/storage-fdb.go
index f7784aa..2081d58 100644
--- a/storage/storage-fdb.go
+++ b/storage/storage-fdb.go
@@ -6,16 +6,16 @@ import (
 	"crypto"
 	"crypto/x509"
 	"fmt"
-	"github.com/hlandau/acme/acmeapi"
-	"github.com/hlandau/acme/acmeapi/acmeutils"
-	"github.com/hlandau/acme/fdb"
+	"git.devever.net/hlandau/acmeapi"
+	"git.devever.net/hlandau/acmeapi/acmeutils"
+	"git.devever.net/hlandau/acmetool/fdb"
+	"git.devever.net/hlandau/acmetool/util"
 	"github.com/hlandau/xlog"
 	"gopkg.in/yaml.v2"
 	"io"
 	"io/ioutil"
 	"os"
 	"strings"
-	"time"
 )
 
 var log, Log = xlog.New("acme.storage")
@@ -208,13 +208,17 @@ func NewFDB(path string) (Store, error) {
 		path = RecommendedPath
 	}
 
-	db, err := fdb.Open(fdb.Config{
-		Path:            path,
-		Permissions:     storePermissions,
-		PermissionsPath: "conf/perm",
-	})
+	dbCfg := fdb.Config{
+		Path: path,
+	}
+	if !isNeutered {
+		dbCfg.Permissions = storePermissions
+		dbCfg.PermissionsPath = "conf/perm"
+	}
+
+	db, err := fdb.Open(dbCfg)
 	if err != nil {
-		return nil, err
+		return nil, fmt.Errorf("open fdb: %v", err)
 	}
 
 	s := &fdbStore{
@@ -336,9 +340,8 @@ func (s *fdbStore) validateAccount(serverName, accountName string, c *fdb.Collec
 	}
 
 	account := &Account{
-		PrivateKey:     pk,
-		DirectoryURL:   directoryURL,
-		Authorizations: map[string]*Authorization{},
+		PrivateKey:   pk,
+		DirectoryURL: directoryURL,
 	}
 
 	accountID := account.ID()
@@ -349,54 +352,6 @@ func (s *fdbStore) validateAccount(serverName, accountName string, c *fdb.Collec
 
 	s.accounts[accountID] = account
 
-	err = s.validateAuthorizations(account, c)
-	if err != nil {
-		return err
-	}
-
-	return nil
-}
-
-func (s *fdbStore) validateAuthorizations(account *Account, c *fdb.Collection) error {
-	ac := c.Collection("authorizations")
-
-	auths, err := ac.List()
-	if err != nil {
-		return err
-	}
-
-	for _, auth := range auths {
-		auc := ac.Collection(auth)
-		err := s.validateAuthorization(account, auth, auc)
-		log.Errore(err, "failed to load authorization, ignoring: ", auth)
-	}
-
-	return nil
-}
-
-func (s *fdbStore) validateAuthorization(account *Account, authName string, c *fdb.Collection) error {
-	ss, err := fdb.String(c.Open("expiry"))
-	if err != nil {
-		return err
-	}
-
-	expiry, err := time.Parse(time.RFC3339, strings.TrimSpace(ss))
-	if err != nil {
-		return err
-	}
-
-	azURL, _ := fdb.String(c.Open("url"))
-	if !acmeapi.ValidURL(azURL) {
-		azURL = ""
-	}
-
-	az := &Authorization{
-		Name:    authName,
-		URL:     strings.TrimSpace(azURL),
-		Expires: expiry,
-	}
-
-	account.Authorizations[authName] = az
 	return nil
 }
 
@@ -494,7 +449,7 @@ func (s *fdbStore) validateCert(certID string, c *fdb.Collection) error {
 
 	ss = strings.TrimSpace(ss)
 	if !acmeapi.ValidURL(ss) {
-		return fmt.Errorf("certificate has invalid URI")
+		return fmt.Errorf("certificate order has invalid URI")
 	}
 
 	actualCertID := determineCertificateID(ss)
@@ -752,20 +707,6 @@ func (s *fdbStore) SaveAccount(a *Account) error {
 
 	w.Close()
 
-	for _, auth := range a.Authorizations {
-		c := coll.Collection("authorizations/" + auth.Name)
-
-		err := fdb.WriteBytes(c, "expiry", []byte(auth.Expires.Format(time.RFC3339)))
-		if err != nil {
-			return err
-		}
-
-		err = fdb.WriteBytes(c, "url", []byte(auth.URL))
-		if err != nil {
-			return err
-		}
-	}
-
 	return nil
 }
 
@@ -832,7 +773,7 @@ func (s *fdbStore) ImportKey(privateKey crypto.PrivateKey) (*Key, error) {
 }
 
 // Given a certificate URL, imports the certificate into the store. The
-// certificate will be retrirved on the next reconcile. If a certificate with
+// certificate will be retrieved on the next reconcile. If a certificate with
 // that URL already exists, this is a no-op and returns nil.
 func (s *fdbStore) ImportCertificate(url string) (*Certificate, error) {
 	certID := determineCertificateID(url)
@@ -939,7 +880,7 @@ func (s *fdbStore) revokeByKeyID(keyID string) error {
 		return fmt.Errorf("cannot find certificate or key with given ID: %q", keyID)
 	}
 
-	var merr MultiError
+	var merr util.MultiError
 	for _, c := range s.certs {
 		if c.Key != k {
 			continue
diff --git a/storage/types.go b/storage/types.go
index d4cebbb..d1d7cda 100644
--- a/storage/types.go
+++ b/storage/types.go
@@ -2,13 +2,13 @@ package storage
 
 import (
 	"crypto"
+	"crypto/ecdsa"
+	"crypto/rsa"
 	"encoding/base32"
 	"fmt"
-	"github.com/hlandau/acme/acmeapi"
-	"github.com/jmhodges/clock"
+	"git.devever.net/hlandau/acmeapi"
 	"github.com/satori/go.uuid"
 	"strings"
-	"time"
 )
 
 // Represents stored account data.
@@ -19,9 +19,6 @@ type Account struct {
 	// N. Server directory URL.
 	DirectoryURL string
 
-	// Disposable. Authorizations.
-	Authorizations map[string]*Authorization
-
 	// ID: determined from DirectoryURL and PrivateKey.
 	// Path: formed from ID.
 	// Registration URL: can be recovered automatically.
@@ -44,21 +41,12 @@ func (a *Account) String() string {
 	return fmt.Sprintf("Account(%v)", a.ID())
 }
 
-// Represents an authorization.
-type Authorization struct {
-	// N. The authorized hostname.
-	Name string
-
-	// N. The authorization URL.
-	URL string
-
-	// D. Can be derived from the URL. The authorization expiry time.
-	Expires time.Time
-}
-
-// Returns true iff the authorization is unexpired.
-func (a *Authorization) IsValid(clock clock.Clock) bool {
-	return clock.Now().Before(a.Expires)
+// Convert storage Account object to a new acmeapi.Account suitable for making
+// requests.
+func (a *Account) ToAPI() *acmeapi.Account {
+	return &acmeapi.Account{
+		PrivateKey: a.PrivateKey,
+	}
 }
 
 // Represents the "satisfy" section of a target file.
@@ -68,8 +56,22 @@ type TargetSatisfy struct {
 	// doesn't support those yet.
 	Names []string `yaml:"names,omitempty"`
 
-	// D. Reduced name set, after disjunction operation. Derived from Names.
-	ReducedNames []string `yaml:"-"`
+	// N. Renewal margin in days. Defaults to 30.
+	Margin int `yaml:"margin,omitempty"`
+
+	// D. Reduced name set, after disjunction operation. Derived from Names for
+	// each label (or label "").
+	//ReducedNamesByLabel map[string][]string `yaml:"-"`
+
+	// N. Key configuration items which are required to satisfy a target.
+	Key TargetSatisfyKey `yaml:"key,omitempty"`
+}
+
+// Represents the "satisfy": "key" section of a target file.
+type TargetSatisfyKey struct {
+	// N. Type of key to require. "" means do not require any specific type of
+	// key.
+	Type string `yaml:"type,omitempty"`
 }
 
 // Represents the "request" section of a target file.
@@ -154,9 +156,12 @@ type Target struct {
 	// Specifies parameters used when requesting certificates.
 	Request TargetRequest `yaml:"request,omitempty"`
 
-	// N. Priority. See state storage specification.
+	// N. Priority. Controls symlink generation. See state storage specification.
 	Priority int `yaml:"priority,omitempty"`
 
+	// N. Label. Controls symlink generation. See state storage specification.
+	Label string `yaml:"label,omitempty"`
+
 	// LEGACY. Names to be satisfied. Moved to Satisfy.Names.
 	LegacyNames []string `yaml:"names,omitempty"`
 
@@ -180,8 +185,8 @@ func (t *Target) Validate() error {
 	return nil
 }
 
-func (tgt *Target) ensureFilename() {
-	if tgt.Filename != "" {
+func (t *Target) ensureFilename() {
+	if t.Filename != "" {
 		return
 	}
 
@@ -190,14 +195,14 @@ func (tgt *Target) ensureFilename() {
 	// We have to use a random name.
 
 	nprefix := ""
-	if len(tgt.Satisfy.Names) > 0 {
-		nprefix = tgt.Satisfy.Names[0] + "-"
+	if len(t.Satisfy.Names) > 0 {
+		nprefix = t.Satisfy.Names[0] + "-"
 	}
 
 	b := uuid.Must(uuid.NewV4()).Bytes()
 	str := strings.ToLower(strings.TrimRight(base32.StdEncoding.EncodeToString(b), "="))
 
-	tgt.Filename = nprefix + str
+	t.Filename = nprefix + str
 }
 
 // Returns a copy of the target.
@@ -228,14 +233,15 @@ func (t *Target) CopyGeneric() *Target {
 
 func (t *Target) genericise() {
 	t.Satisfy.Names = nil
-	t.Satisfy.ReducedNames = nil
+	//t.Satisfy.ReducedNamesByLabel = nil
 	t.Request.Names = nil
 	t.LegacyNames = nil
 }
 
 // Represents stored certificate information.
 type Certificate struct {
-	// N. URL from which the certificate can be retrieved.
+	// N. URL to the order used to obtain the certificate. Not a direct URL to
+	// the certificate blob.
 	URL string
 
 	// N. Whether this certificate should be revoked.
@@ -283,3 +289,15 @@ type Key struct {
 func (k *Key) String() string {
 	return fmt.Sprintf("Key(%v)", k.ID)
 }
+
+// Returns the type name of the key ("rsa" or "ecdsa").
+func (k *Key) Type() string {
+	switch k.PrivateKey.(type) {
+	case *rsa.PrivateKey:
+		return "rsa"
+	case *ecdsa.PrivateKey:
+		return "ecdsa"
+	default:
+		return ""
+	}
+}
diff --git a/storage/util.go b/storage/util.go
index bb19557..05d4b7b 100644
--- a/storage/util.go
+++ b/storage/util.go
@@ -9,7 +9,7 @@ import (
 	"crypto/x509"
 	"encoding/base32"
 	"fmt"
-	"github.com/hlandau/acme/acmeapi/acmeutils"
+	"git.devever.net/hlandau/acmeapi/acmeutils"
 	"io"
 	"math/big"
 	"net/url"
@@ -173,6 +173,7 @@ func (ppk *psuedoPrivateKey) Sign(io.Reader, []byte, crypto.SignerOpts) ([]byte,
 	return []byte{0}, nil
 }
 
+// Given a public key, returns the key ID.
 func DetermineKeyIDFromPublicKey(pubk crypto.PublicKey) (string, error) {
 	// Trick crypto/x509 into creating a certificate so we can grab the
 	// subjectPublicKeyInfo by giving it a fake private key generating an invalid
@@ -220,12 +221,12 @@ func determineCertificateID(url string) string {
 	return strings.ToLower(strings.TrimRight(base32.StdEncoding.EncodeToString(b), "="))
 }
 
-var re_certID = regexp.MustCompile(`^[a-z0-9]{52}$`)
+var reCertID = regexp.MustCompile(`^[a-z0-9]{52}$`)
 
 // Returns true iff the given string could (possibly) be a valid certificate
 // (or key) ID.
 func IsWellFormattedCertificateOrKeyID(certificateID string) bool {
-	return re_certID.MatchString(certificateID)
+	return reCertID.MatchString(certificateID)
 }
 
 func targetGt(a *Target, b *Target) bool {
@@ -267,18 +268,3 @@ func normalizeNames(names []string) error {
 
 	return nil
 }
-
-// Used to return multiple errors, for example when several targets cannot be
-// reconciled. This prevents one failing target from blocking others.
-type MultiError []error
-
-func (merr MultiError) Error() string {
-	s := ""
-	for _, e := range merr {
-		if s != "" {
-			s += "; \n"
-		}
-		s += e.Error()
-	}
-	return "the following errors occurred:\n" + s
-}
diff --git a/storageops/config.go b/storageops/config.go
index f3f8a1f..781b7a2 100644
--- a/storageops/config.go
+++ b/storageops/config.go
@@ -1,6 +1,6 @@
 package storageops
 
-import "github.com/hlandau/acme/storage"
+import "git.devever.net/hlandau/acmetool/storage"
 
 // Update targets to remove any mention of hostname from all targets. The
 // targets are resaved to disk.
diff --git a/storageops/cull.go b/storageops/cull.go
index 88eaebf..0bd3a99 100644
--- a/storageops/cull.go
+++ b/storageops/cull.go
@@ -1,6 +1,6 @@
 package storageops
 
-import "github.com/hlandau/acme/storage"
+import "git.devever.net/hlandau/acmetool/storage"
 
 func Cull(s storage.Store, simulate bool) error {
 	certificatesToCull := map[string]*storage.Certificate{}
diff --git a/storageops/reconcile-util.go b/storageops/reconcile-util.go
new file mode 100644
index 0000000..6853f87
--- /dev/null
+++ b/storageops/reconcile-util.go
@@ -0,0 +1,207 @@
+package storageops
+
+import (
+	"crypto/x509"
+	"fmt"
+	"git.devever.net/hlandau/acmetool/storage"
+)
+
+func HaveUncachedCertificates(s storage.Store) bool {
+	haveUncached := false
+
+	s.VisitCertificates(func(c *storage.Certificate) error {
+		if !c.Cached {
+			haveUncached = true
+		}
+
+		return nil
+	})
+
+	return haveUncached
+}
+
+// Returns the strings in ys not contained in xs.
+func stringsNotIn(xs, ys []string) []string {
+	m := map[string]struct{}{}
+	for _, x := range xs {
+		m[x] = struct{}{}
+	}
+	var zs []string
+	for _, y := range ys {
+		_, ok := m[y]
+		if !ok {
+			zs = append(zs, y)
+		}
+	}
+	return zs
+}
+
+func ensureConceivablySatisfiable(t *storage.Target) {
+	// We ensure that every stipulation in the satisfy section can be met by the request
+	// parameters.
+	excludedNames := stringsNotIn(t.Request.Names, t.Satisfy.Names)
+	if len(excludedNames) > 0 {
+		log.Warnf("%v can never be satisfied because names to be requested are not a superset of the names to be satisfied; adding names automatically to render target satisfiable", t)
+	}
+
+	for _, n := range excludedNames {
+		t.Request.Names = append(t.Request.Names, n)
+	}
+
+	if t.Satisfy.Key.Type != "" {
+		t.Request.Key.Type = t.Satisfy.Key.Type
+	}
+}
+
+func DoesCertificateSatisfy(c *storage.Certificate, t *storage.Target) bool {
+	if c.Revoked {
+		log.Debugf("%v cannot satisfy %v because it is revoked", c, t)
+		return false
+	}
+
+	if len(c.Certificates) == 0 {
+		log.Debugf("%v cannot satisfy %v because it has no actual certificates", c, t)
+		return false
+	}
+
+	if c.Key == nil {
+		// A certificate we don't have the key for is unusable.
+		log.Debugf("%v cannot satisfy %v because we do not have a key for it", c, t)
+		return false
+	}
+
+	cc, err := x509.ParseCertificate(c.Certificates[0])
+	if err != nil {
+		log.Debugf("%v cannot satisfy %v because we cannot parse it: %v", c, t, err)
+		return false
+	}
+
+	names := map[string]struct{}{}
+	for _, name := range cc.DNSNames {
+		names[name] = struct{}{}
+	}
+
+	for _, name := range t.Satisfy.Names {
+		_, ok := names[name]
+		if !ok {
+			log.Debugf("%v cannot satisfy %v because required hostname %q is not listed on it: %#v", c, t, name, cc.DNSNames)
+			return false
+		}
+	}
+
+	if t.Satisfy.Key.Type != "" && t.Satisfy.Key.Type != c.Key.Type() {
+		log.Debugf("%v cannot satisfy %v because required key type (%q) does not match (%q)", c, t, t.Satisfy.Key.Type, c.Key.Type())
+		return false
+	}
+
+	log.Debugf("%v satisfies %v", c, t)
+	return true
+}
+
+func FindBestCertificateSatisfying(s storage.Store, t *storage.Target) (*storage.Certificate, error) {
+	var bestCert *storage.Certificate
+
+	err := s.VisitCertificates(func(c *storage.Certificate) error {
+		if DoesCertificateSatisfy(c, t) {
+			isBetterThan, err := CertificateBetterThan(c, bestCert)
+			if err != nil {
+				return err
+			}
+
+			if isBetterThan {
+				log.Tracef("findBestCertificateSatisfying: %v > %v", c, bestCert)
+				bestCert = c
+			} else {
+				log.Tracef("findBestCertificateSatisfying: %v <= %v", c, bestCert)
+			}
+		}
+
+		return nil
+	})
+	if err != nil {
+		return nil, err
+	}
+
+	if bestCert == nil {
+		return nil, fmt.Errorf("%v: no certificate satisfies this target", t)
+	}
+
+	return bestCert, nil
+}
+
+func CertificateBetterThan(a, b *storage.Certificate) (bool, error) {
+	if b == nil || a == nil {
+		return (b == nil && a != nil), nil
+	}
+
+	if len(a.Certificates) == 0 || len(b.Certificates) == 0 {
+		return false, fmt.Errorf("need two certificates to compare")
+	}
+
+	ac, err := x509.ParseCertificate(a.Certificates[0])
+	bc, err2 := x509.ParseCertificate(b.Certificates[0])
+	if err != nil || err2 != nil {
+		if err == nil && err2 != nil {
+			log.Tracef("certBetterThan: parseable certificate is better than unparseable certificate")
+			return true, nil
+		}
+
+		return false, nil
+	}
+
+	isAfter := ac.NotAfter.After(bc.NotAfter)
+	log.Tracef("certBetterThan: (%v > %v)=%v", ac.NotAfter, bc.NotAfter, isAfter)
+	return isAfter, nil
+}
+
+func CertificateNeedsRenewing(c *storage.Certificate, t *storage.Target) bool {
+	if len(c.Certificates) == 0 {
+		log.Debugf("%v: not renewing because it has no actual certificates (???)", c)
+		return false
+	}
+
+	cc, err := x509.ParseCertificate(c.Certificates[0])
+	if err != nil {
+		log.Debugf("%v: not renewing because its end certificate is unparseable", c)
+		return false
+	}
+
+	renewTime := renewTime(cc.NotBefore, cc.NotAfter, t)
+	needsRenewing := !InternalClock.Now().Before(renewTime)
+
+	log.Debugf("%v needsRenewing=%v notAfter=%v", c, needsRenewing, cc.NotAfter)
+	return needsRenewing
+}
+
+// This is used to detertmine whether to cull certificates.
+func CertificateGenerallyValid(c *storage.Certificate) bool {
+	// This function is very conservative because if we return false
+	// the certificate will get deleted. Revocation and expiry are
+	// good reasons to delete. We already know the certificate is
+	// unreferenced.
+
+	if c.Revoked {
+		log.Debugf("%v not generally valid because it is revoked", c)
+		return false
+	}
+
+	if len(c.Certificates) == 0 {
+		// If we have no actual certificates, give the benefit of the doubt.
+		// Maybe the certificate is undownloaded.
+		log.Debugf("%v has no actual certificates, assuming valid", c)
+		return true
+	}
+
+	cc, err := x509.ParseCertificate(c.Certificates[0])
+	if err != nil {
+		log.Debugf("%v cannot be parsed, assuming valid", c)
+		return false
+	}
+
+	if !InternalClock.Now().Before(cc.NotAfter) {
+		log.Debugf("%v not generally valid because it is expired", c)
+		return false
+	}
+
+	return true
+}
diff --git a/storageops/reconcile.go b/storageops/reconcile.go
index aefff4e..6ea4ceb 100644
--- a/storageops/reconcile.go
+++ b/storageops/reconcile.go
@@ -2,49 +2,64 @@
 package storageops
 
 import (
-	"bytes"
+	"context"
 	"crypto"
 	"crypto/rand"
 	"crypto/x509"
 	"crypto/x509/pkix"
 	"encoding/asn1"
 	"fmt"
-	"github.com/hlandau/acme/acmeapi"
-	"github.com/hlandau/acme/acmeapi/acmeendpoints"
-	"github.com/hlandau/acme/acmeapi/acmeutils"
-	"github.com/hlandau/acme/hooks"
-	"github.com/hlandau/acme/responder"
-	"github.com/hlandau/acme/solver"
-	"github.com/hlandau/acme/storage"
+	"git.devever.net/hlandau/acmeapi"
+	"git.devever.net/hlandau/acmeapi/acmeendpoints"
+	"git.devever.net/hlandau/acmetool/hooks"
+	"git.devever.net/hlandau/acmetool/responder"
+	"git.devever.net/hlandau/acmetool/solver"
+	"git.devever.net/hlandau/acmetool/storage"
+	"git.devever.net/hlandau/acmetool/util"
 	"github.com/hlandau/xlog"
 	"github.com/jmhodges/clock"
-	"golang.org/x/net/context"
+	"net/http"
+	"path/filepath"
 	"sort"
 	"strings"
+	"time"
 )
 
-var log, Log = xlog.New("acme.storageops")
+var log, Log = xlog.New("acmetool.storageops")
 
 // Internal use only. Used for testing purposes. Do not change.
 var InternalClock = clock.Default()
 
+// Internal use only. Used for testing purposes. Do not change.
+var InternalHTTPClient *http.Client
+
+// Optional configuration for the Reconcile operation.
+type ReconcileConfig struct {
+	// If non-empty, a set of target names/paths to limit reconciliation to.
+	// Essentially, the reconciliation engine acts as if only these targets
+	// exist. Otherwise all targets are used.
+	Targets []string
+}
+
 type reconcile struct {
 	store storage.Store
 
+	cfg ReconcileConfig
+
 	// Cache of account clients to avoid duplicated directory lookups.
-	accountClients map[*storage.Account]*acmeapi.Client
+	accountClients map[*storage.Account]*acmeapi.RealmClient
 }
 
-func makeReconcile(store storage.Store) *reconcile {
+func makeReconcile(store storage.Store, cfg ReconcileConfig) *reconcile {
 	return &reconcile{
 		store:          store,
-		accountClients: map[*storage.Account]*acmeapi.Client{},
+		cfg:            cfg,
+		accountClients: map[*storage.Account]*acmeapi.RealmClient{},
 	}
 }
 
 func EnsureRegistration(store storage.Store) error {
-	r := makeReconcile(store)
-	return r.EnsureRegistration()
+	return makeReconcile(store, ReconcileConfig{}).EnsureRegistration()
 }
 
 func (r *reconcile) EnsureRegistration() error {
@@ -53,22 +68,25 @@ func (r *reconcile) EnsureRegistration() error {
 		return err
 	}
 
-	cl := r.getClientForAccount(a)
-	return solver.AssistedUpsertRegistration(cl, nil, context.TODO())
+	cl, err := r.getClientForAccount(a)
+	if err != nil {
+		return err
+	}
+
+	return solver.AssistedRegistration(context.TODO(), cl, a.ToAPI(), nil)
 }
 
-// Runs the reconcilation operation.
-func Reconcile(store storage.Store) error {
-	r := makeReconcile(store)
+func Reconcile(store storage.Store, cfg ReconcileConfig) error {
+	r := makeReconcile(store, cfg)
 
 	reconcileErr := r.Reconcile()
 	log.Errore(reconcileErr, "failed to reconcile")
 
 	reloadErr := r.store.Reload()
-	log.Errore(reloadErr, "failed to reload after reconcilation")
+	log.Errore(reloadErr, "failed to reload after reconciliation")
 
 	relinkErr := r.Relink()
-	log.Errore(relinkErr, "failed to relink after reconcilation")
+	log.Errore(relinkErr, "failed to relink after reconciliation")
 
 	err := reconcileErr
 	if err == nil {
@@ -81,11 +99,8 @@ func Reconcile(store storage.Store) error {
 	return err
 }
 
-// Runs the relink operation without running the reconcile operation.
 func Relink(store storage.Store) error {
-	r := makeReconcile(store)
-
-	err := r.Relink()
+	err := makeReconcile(store, ReconcileConfig{}).Relink()
 	log.Errore(err, "failed to relink")
 	return err
 }
@@ -119,7 +134,6 @@ func (r *reconcile) Relink() error {
 	}
 
 	ctx := &hooks.Context{
-		HooksDir: "",
 		StateDir: r.store.Path(),
 	}
 
@@ -140,21 +154,32 @@ func (r *reconcile) disjoinTargets() (hostnameTargetMapping map[string]*storage.
 	sort.Stable(sort.Reverse(targetSorter(targets)))
 
 	// Hostname-target mapping.
+	//
+	// N.B. The 'Reduced Names'/'Reduced Names By Label' data isn't actually used
+	// for anything currently, so we disable computation of it currently.
 	hostnameTargetMapping = map[string]*storage.Target{}
 	for _, tgt := range targets {
-		tgt.Satisfy.ReducedNames = nil
+		//tgt.Satisfy.ReducedNamesByLabel = nil
 		for _, name := range tgt.Satisfy.Names {
-			_, exists := hostnameTargetMapping[name]
+			key := name
+			if tgt.Label != "" {
+				key += ":" + tgt.Label
+			}
+			_, exists := hostnameTargetMapping[key]
 			if !exists {
-				hostnameTargetMapping[name] = tgt
-				tgt.Satisfy.ReducedNames = append(tgt.Satisfy.ReducedNames, name)
+				hostnameTargetMapping[key] = tgt
+				//if tgt.Satisfy.ReducedNamesByLabel == nil {
+				//	tgt.Satisfy.ReducedNamesByLabel = map[string][]string{}
+				//}
+				//reducedNames, _ := tgt.Satisfy.ReducedNamesByLabel[tgt.Label]
+				//tgt.Satisfy.ReducedNamesByLabel[tgt.Label] = append(reducedNames, name)
 			}
 		}
 	}
 
 	// Debugging information.
 	for name, tgt := range hostnameTargetMapping {
-		log.Debugf("disjoint hostname mapping: %s -> %v", name, tgt)
+		log.Debugf("disjoint hostname mapping: %q -> %v", name, tgt)
 	}
 
 	return
@@ -166,8 +191,8 @@ func (r *reconcile) Reconcile() error {
 		return err
 	}
 
-	err = r.processPendingRevocations()
-	log.Errore(err, "could not process pending revocations")
+	//err = r.processPendingRevocations()
+	//log.Errore(err, "could not process pending revocations")
 
 	err = r.processTargets()
 	log.Errore(err, "error while processing targets")
@@ -208,350 +233,31 @@ func (r *reconcile) processUncachedCertificates() error {
 	return nil
 }
 
-func HaveUncachedCertificates(s storage.Store) bool {
-	haveUncached := false
-
-	s.VisitCertificates(func(c *storage.Certificate) error {
-		if !c.Cached {
-			haveUncached = true
-		}
-
-		return nil
-	})
-
-	return haveUncached
-}
-
 func (r *reconcile) downloadUncachedCertificates() error {
 	return r.store.VisitCertificates(func(c *storage.Certificate) error {
 		if c.Cached {
 			return nil
 		}
 
-		return r.downloadCertificate(c)
-	})
-}
-
-func (r *reconcile) downloadCertificate(c *storage.Certificate) error {
-	log.Debugf("downloading certificate %v", c)
-
-	cl := r.getGenericClient()
-
-	crt := acmeapi.Certificate{
-		URI: c.URL,
-	}
-
-	err := cl.WaitForCertificate(&crt, context.TODO())
-	if err != nil {
-		return err
-	}
-
-	if len(crt.Certificate) == 0 {
-		return fmt.Errorf("nil certificate?")
-	}
-
-	c.Certificates = [][]byte{crt.Certificate}
-	c.Certificates = append(c.Certificates, crt.ExtraCertificates...)
-	c.Cached = true
-
-	err = r.store.SaveCertificate(c)
-	if err != nil {
-		log.Errore(err, "failed to save certificate after retrieval: %v", c)
-		return err
-	}
-
-	return nil
-}
-
-func (r *reconcile) processPendingRevocations() error {
-	var me storage.MultiError
-
-	r.store.VisitCertificates(func(c *storage.Certificate) error {
-		if c.Revoked || !c.RevocationDesired {
-			return nil
-		}
-
-		err := r.revokeCertificate(c)
+		err := r.downloadCertificateAdaptive(c)
 		if err != nil {
-			me = append(me, fmt.Errorf("failed to revoke %v: %v", c, err))
-			// keep processing revocations
-		}
-
-		return nil
-	})
-
-	if len(me) > 0 {
-		return me
-	}
-
-	return nil
-}
-
-func (r *reconcile) revokeCertificate(c *storage.Certificate) error {
-	err := r.revokeCertificateInner(c)
-	if err != nil {
-		return err
-	}
-
-	c.Revoked = true
-	err = r.store.SaveCertificate(c)
-	if err != nil {
-		log.Errore(err, "failed to save certificate after revocation: ", c)
-		return err
-	}
-
-	return nil
-}
-
-func (r *reconcile) revokeCertificateInner(c *storage.Certificate) error {
-	if len(c.Certificates) == 0 {
-		return fmt.Errorf("no certificates in certificate to revoke: %v", c)
-	}
-
-	endCertificate := c.Certificates[0]
-
-	crt, err := x509.ParseCertificate(endCertificate)
-	if err != nil {
-		return err
-	}
-
-	// Get the endpoint which issued the certificate.
-	endpoint, err := acmeendpoints.CertificateToEndpoint(r.getGenericClient(), crt, context.TODO())
-	if err != nil {
-		return fmt.Errorf("could not map certificate %v to endpoint: %v", c, err)
-	}
-
-	// In order to revoke a certificate, one needs either the private key of the
-	// certificate, or the account key with authorizations for all names on the
-	// certificate. Try and find the private key first.
-	var client *acmeapi.Client
-	var revocationKey crypto.PrivateKey
-	if c.Key != nil {
-		revocationKey = c.Key.PrivateKey
-		client = r.getClientForDirectoryURL(endpoint.DirectoryURL)
-	}
-
-	if revocationKey == nil {
-		acct, err := r.getAccountByDirectoryURL(endpoint.DirectoryURL)
-		if err != nil {
-			return err
-		}
-
-		client = r.getClientForAccount(acct)
-
-		// If we have no private key for the certificate, obtain all necessary
-		// authorizations.
-		err = r.getRevocationAuthorizations(acct, crt)
-		if err != nil {
-			return err
-		}
-	}
-
-	return client.Revoke(endCertificate, revocationKey, context.TODO())
-}
-
-func (r *reconcile) getGenericClient() *acmeapi.Client {
-	return &acmeapi.Client{}
-}
-
-func (r *reconcile) getClientForDirectoryURL(directoryURL string) *acmeapi.Client {
-	cl := r.getGenericClient()
-	cl.DirectoryURL = directoryURL
-	return cl
-}
-
-func (r *reconcile) getClientForAccount(a *storage.Account) *acmeapi.Client {
-	cl := r.accountClients[a]
-	if cl == nil {
-		cl = r.getClientForDirectoryURL(a.DirectoryURL)
-		cl.AccountKey = a.PrivateKey
-		r.accountClients[a] = cl
-	}
-
-	return cl
-}
-
-func (r *reconcile) getRevocationAuthorizations(acct *storage.Account, crt *x509.Certificate) error {
-	log.Debugf("obtaining authorizations needed to facilitate revocation")
-	return r.obtainNecessaryAuthorizations(crt.DNSNames, acct, "", &r.store.DefaultTarget().Request.Challenge)
-}
-
-func (r *reconcile) obtainNecessaryAuthorizations(names []string, a *storage.Account, targetFilename string, ccfg *storage.TargetRequestChallenge) error {
-	authsNeeded := r.determineNecessaryAuthorizations(names, a)
-
-	for _, name := range authsNeeded {
-		log.Debugf("trying to obtain authorization for %q", name)
-		err := r.obtainAuthorization(name, a, targetFilename, ccfg)
-		if err != nil {
-			log.Errore(err, "could not obtain authorization for ", name)
-			return err
-		}
-	}
-
-	return nil
-}
-
-func (r *reconcile) determineNecessaryAuthorizations(names []string, a *storage.Account) []string {
-	needed := map[string]struct{}{}
-	for _, n := range names {
-		needed[n] = struct{}{}
-	}
-
-	for _, auth := range a.Authorizations {
-		if auth.IsValid(InternalClock) {
-			delete(needed, auth.Name)
-		}
-	}
-
-	// Preserve the order of the names in case the user considers that important.
-	var neededs []string
-	for _, name := range names {
-		if _, ok := needed[name]; ok {
-			neededs = append(neededs, name)
-		}
-	}
-
-	return neededs
-}
-
-func generateHookPEM(info *responder.TLSSNIChallengeInfo) (string, error) {
-	b := bytes.Buffer{}
-
-	err := acmeutils.SaveCertificates(&b, info.Certificate)
-	if err != nil {
-		return "", err
-	}
-
-	err = acmeutils.SavePrivateKey(&b, info.Key)
-	if err != nil {
-		return "", err
-	}
-
-	return b.String(), nil
-}
-
-func (r *reconcile) obtainAuthorization(name string, a *storage.Account, targetFilename string, trc *storage.TargetRequestChallenge) error {
-	cl := r.getClientForAccount(a)
-
-	ctx := &hooks.Context{
-		HooksDir: "",
-		StateDir: r.store.Path(),
-		Env:      map[string]string{},
-	}
-	for k, v := range trc.InheritedEnv {
-		ctx.Env[k] = v
-	}
-	for k, v := range trc.Env {
-		ctx.Env[k] = v
-	}
-
-	startHookFunc := func(challengeInfo interface{}) error {
-		switch v := challengeInfo.(type) {
-		case *responder.HTTPChallengeInfo:
-			_, err := hooks.ChallengeHTTPStart(ctx, name, targetFilename, v.Filename, v.Body)
-			return err
-		case *responder.TLSSNIChallengeInfo:
-			hookPEM, err := generateHookPEM(v)
-			if err != nil {
-				return err
-			}
-
-			_, err = hooks.ChallengeTLSSNIStart(ctx, name, targetFilename, v.Hostname1, v.Hostname2, hookPEM)
-			return err
-		case *responder.DNSChallengeInfo:
-			installed, err := hooks.ChallengeDNSStart(ctx, name, targetFilename, v.Body)
-			if err == nil && !installed {
-				return fmt.Errorf("could not install DNS challenge, no hooks succeeded")
-			}
-			return err
-		default:
-			return nil
-		}
-	}
-
-	stopHookFunc := func(challengeInfo interface{}) error {
-		switch v := challengeInfo.(type) {
-		case *responder.HTTPChallengeInfo:
-			return hooks.ChallengeHTTPStop(ctx, name, targetFilename, v.Filename, v.Body)
-		case *responder.TLSSNIChallengeInfo:
-			hookPEM, err := generateHookPEM(v)
-			if err != nil {
+			// If the download fails, consider whether the error is permanent or
+			// temporary. If temporary, don't hold up other certificates and continue
+			// for now. We'll try again when next invoked.
+			if util.IsTemporary(err) {
+				// continue visitation
+				log.Errore(err, "temporary error when trying to download certificate")
+				return nil
+			} else {
+				// Permanent error, stop.
+				// TODO: We might want to switch this to deleting the certificate at
+				// some point.
 				return err
 			}
-
-			_, err = hooks.ChallengeTLSSNIStop(ctx, name, targetFilename, v.Hostname1, v.Hostname2, hookPEM)
-			return err
-		case *responder.DNSChallengeInfo:
-			uninstalled, err := hooks.ChallengeDNSStop(ctx, name, targetFilename, v.Body)
-			if err == nil && !uninstalled {
-				return fmt.Errorf("could not uninstall DNS challenge, no hooks succeeded")
-			}
-			return err
-		default:
-			return nil
 		}
-	}
-
-	httpSelfTest := true
-	if trc.HTTPSelfTest != nil {
-		httpSelfTest = *trc.HTTPSelfTest
-	}
-
-	ccfg := responder.ChallengeConfig{
-		WebPaths:       trc.WebrootPaths,
-		HTTPPorts:      trc.HTTPPorts,
-		HTTPNoSelfTest: !httpSelfTest,
-		PriorKeyFunc:   r.getPriorKey,
-		StartHookFunc:  startHookFunc,
-		StopHookFunc:   stopHookFunc,
-	}
-
-	az, err := solver.Authorize(cl, name, ccfg, context.TODO())
-	if err != nil {
-		return err
-	}
 
-	err = cl.LoadAuthorization(az, context.TODO())
-	if err != nil {
-		// Try proceeding anyway.
 		return nil
-	}
-
-	if a.Authorizations == nil {
-		a.Authorizations = map[string]*storage.Authorization{}
-	}
-
-	a.Authorizations[az.Identifier.Value] = &storage.Authorization{
-		URL:     az.URI,
-		Name:    az.Identifier.Value,
-		Expires: az.Expires,
-	}
-
-	err = r.store.SaveAccount(a)
-	if err != nil {
-		return err
-	}
-
-	return nil
-}
-
-func (r *reconcile) getPriorKey(publicKey crypto.PublicKey) (crypto.PrivateKey, error) {
-	// Returning an error here short circuits. If any errors occur here, return (nil,nil).
-
-	keyID, err := storage.DetermineKeyIDFromPublicKey(publicKey)
-	if err != nil {
-		log.Errore(err, "failed to get key ID from public key")
-		return nil, nil
-	}
-
-	k := r.store.KeyByID(keyID)
-
-	if k == nil {
-		log.Infof("failed to find key ID wanted by proofOfPossession: %s", keyID)
-		return nil, nil // unknown key
-	}
-
-	return k.PrivateKey, nil
+	})
 }
 
 func (r *reconcile) getAccountByDirectoryURL(directoryURL string) (*storage.Account, error) {
@@ -595,13 +301,82 @@ func (r *reconcile) createNewAccount(directoryURL string) (*storage.Account, err
 	return a, nil
 }
 
+func (r *reconcile) getGenericClient() (*acmeapi.RealmClient, error) {
+	return r.getClientForDirectoryURL("")
+}
+
+func (r *reconcile) getClientForDirectoryURL(directoryURL string) (*acmeapi.RealmClient, error) {
+	return acmeapi.NewRealmClient(acmeapi.RealmClientConfig{
+		DirectoryURL: directoryURL,
+		HTTPClient:   InternalHTTPClient,
+	})
+}
+
+func (r *reconcile) getClientForAccount(a *storage.Account) (*acmeapi.RealmClient, error) {
+	cl := r.accountClients[a]
+	if cl == nil {
+		var err error
+		cl, err = r.getClientForDirectoryURL(a.DirectoryURL)
+		if err != nil {
+			return nil, err
+		}
+
+		r.accountClients[a] = cl
+	}
+
+	return cl, nil
+}
+
+func (r *reconcile) targetIsSelected(t *storage.Target) (selected bool, err error) {
+	if len(r.cfg.Targets) == 0 {
+		selected = true
+		return
+	}
+
+	for _, spec := range r.cfg.Targets {
+		// If the spec is just a one-component path ("foo"), treat it as a match on
+		// a name inside the "desired" directory.
+		if spec == t.Filename {
+			selected = true
+			return
+		}
+
+		// Get absolute path of target filename and absolute path of provided
+		// pathspec, interpreting it as a path, and see if they match.
+		var tgtFilename string
+		tgtFilename, err = filepath.Abs(filepath.Join(r.store.Path(), "desired", t.Filename))
+		if err != nil {
+			return
+		}
+
+		var absSpec string
+		absSpec, err = filepath.Abs(spec)
+		if err != nil {
+			return
+		}
+
+		if absSpec == tgtFilename {
+			selected = true
+			return
+		}
+	}
+
+	log.Debugf("target not selected: %q", t.Filename)
+	return
+}
+
 func (r *reconcile) processTargets() error {
-	var merr storage.MultiError
+	var merr util.MultiError
 
 	r.store.VisitTargets(func(t *storage.Target) error {
+		selected, err := r.targetIsSelected(t)
+		if err != nil || !selected {
+			return err
+		}
+
 		c, err := FindBestCertificateSatisfying(r.store, t)
 		log.Debugf("%v: best certificate satisfying is %v, err=%v", t, c, err)
-		if err == nil && !CertificateNeedsRenewing(c) {
+		if err == nil && !CertificateNeedsRenewing(c, t) {
 			log.Debugf("%v: have best certificate which does not need renewing, skipping target", t)
 			return nil // continue
 		}
@@ -644,38 +419,7 @@ func (r *reconcile) getRequestAccount(tr *storage.TargetRequest) (*storage.Accou
 	return acct, nil
 }
 
-// Returns the strings in ys not contained in xs.
-func stringsNotIn(xs, ys []string) []string {
-	m := map[string]struct{}{}
-	for _, x := range xs {
-		m[x] = struct{}{}
-	}
-	var zs []string
-	for _, y := range ys {
-		_, ok := m[y]
-		if !ok {
-			zs = append(zs, y)
-		}
-	}
-	return zs
-}
-
-func ensureConceivablySatisfiable(t *storage.Target) {
-	// We ensure that every stipulation in the satisfy section can be met by the request
-	// parameters.
-	excludedNames := stringsNotIn(t.Request.Names, t.Satisfy.Names)
-	if len(excludedNames) > 0 {
-		log.Warnf("%v can never be satisfied because names to be requested are not a superset of the names to be satisfied; adding names automatically to render target satisfiable", t)
-	}
-
-	for _, n := range excludedNames {
-		t.Request.Names = append(t.Request.Names, n)
-	}
-}
-
 func (r *reconcile) requestCertificateForTarget(t *storage.Target) error {
-	//return fmt.Errorf("not requesting certificate") // debugging neuter
-
 	ensureConceivablySatisfiable(t)
 
 	acct, err := r.getRequestAccount(&t.Request)
@@ -683,14 +427,14 @@ func (r *reconcile) requestCertificateForTarget(t *storage.Target) error {
 		return err
 	}
 
-	cl := r.getClientForAccount(acct)
-
-	err = solver.AssistedUpsertRegistration(cl, nil, context.TODO())
+	cl, err := r.getClientForAccount(acct)
 	if err != nil {
 		return err
 	}
 
-	err = r.obtainNecessaryAuthorizations(t.Request.Names, acct, t.Filename, &t.Request.Challenge)
+	apiAcct := acct.ToAPI()
+
+	err = solver.AssistedRegistration(context.TODO(), cl, apiAcct, nil)
 	if err != nil {
 		return err
 	}
@@ -700,28 +444,92 @@ func (r *reconcile) requestCertificateForTarget(t *storage.Target) error {
 		return err
 	}
 
-	log.Debugf("%v: requesting certificate", t)
-	acrt, err := cl.RequestCertificate(csr, context.TODO())
+	orderTpl := acmeapi.Order{}
+	for _, name := range t.Request.Names {
+		orderTpl.Identifiers = append(orderTpl.Identifiers, acmeapi.Identifier{
+			Type:  acmeapi.IdentifierTypeDNS,
+			Value: name,
+		})
+	}
+
+	log.Debugf("%v: ordering certificate", t)
+	order, err := solver.Order(context.TODO(), cl, apiAcct, &orderTpl, csr, r.targetToChallengeConfig(t))
 	if err != nil {
-		log.Errore(err, "could not request certificate")
 		return err
 	}
 
-	c, err := r.store.ImportCertificate(acrt.URI)
+	c, err := r.store.ImportCertificate(order.URL)
 	if err != nil {
 		log.Errore(err, "could not import certificate")
 		return err
 	}
 
-	err = r.downloadCertificate(c)
+	err = r.downloadCertificateAdaptive(c)
 	if err != nil {
-		log.Errore(err, "failed to download certificate")
 		return err
 	}
 
 	return nil
 }
 
+func (r *reconcile) targetToChallengeConfig(t *storage.Target) *responder.ChallengeConfig {
+	trc := &t.Request.Challenge
+	hctx := &hooks.Context{
+		StateDir: r.store.Path(),
+		Env:      map[string]string{},
+	}
+	for k, v := range trc.InheritedEnv {
+		hctx.Env[k] = v
+	}
+	for k, v := range trc.Env {
+		hctx.Env[k] = v
+	}
+
+	startHookFunc := func(challengeInfo interface{}) error {
+		switch v := challengeInfo.(type) {
+		case *responder.HTTPChallengeInfo:
+			_, err := hooks.ChallengeHTTPStart(hctx, v.Hostname, t.Filename, v.Filename, v.Body)
+			return err
+		case *responder.DNSChallengeInfo:
+			installed, err := hooks.ChallengeDNSStart(hctx, v.Hostname, t.Filename, v.Body)
+			if err == nil && !installed {
+				return fmt.Errorf("could not install DNS challenge, no hooks succeeded")
+			}
+			return err
+		default:
+			return nil
+		}
+	}
+
+	stopHookFunc := func(challengeInfo interface{}) error {
+		switch v := challengeInfo.(type) {
+		case *responder.HTTPChallengeInfo:
+			return hooks.ChallengeHTTPStop(hctx, v.Hostname, t.Filename, v.Filename, v.Body)
+		case *responder.DNSChallengeInfo:
+			uninstalled, err := hooks.ChallengeDNSStop(hctx, v.Hostname, t.Filename, v.Body)
+			if err == nil && !uninstalled {
+				return fmt.Errorf("could not uninstall DNS challenge, no hooks succeeded")
+			}
+			return err
+		default:
+			return nil
+		}
+	}
+
+	httpSelfTest := true
+	if trc.HTTPSelfTest != nil {
+		httpSelfTest = *trc.HTTPSelfTest
+	}
+
+	return &responder.ChallengeConfig{
+		WebPaths:       trc.WebrootPaths,
+		HTTPPorts:      trc.HTTPPorts,
+		HTTPNoSelfTest: !httpSelfTest,
+		StartHookFunc:  startHookFunc,
+		StopHookFunc:   stopHookFunc,
+	}
+}
+
 var (
 	oidTLSFeature          = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 1, 24}
 	mustStapleFeatureValue = []byte{0x30, 0x03, 0x02, 0x01, 0x05}
@@ -779,150 +587,80 @@ func (r *reconcile) generateOrGetKey(trk *storage.TargetRequestKey) (crypto.Priv
 	return generateKey(trk)
 }
 
-func DoesCertificateSatisfy(c *storage.Certificate, t *storage.Target) bool {
-	if c.Revoked {
-		log.Debugf("%v cannot satisfy %v because it is revoked", c, t)
-		return false
-	}
-
-	if len(c.Certificates) == 0 {
-		log.Debugf("%v cannot satisfy %v because it has no actual certificates", c, t)
-		return false
-	}
-
-	if c.Key == nil {
-		// A certificate we don't have the key for is unusable.
-		log.Debugf("%v cannot satisfy %v because we do not have a key for it", c, t)
-		return false
-	}
+func (r *reconcile) downloadCertificateAdaptive(c *storage.Certificate) error {
+	log.Debugf("downloading certificate %v", c)
 
-	cc, err := x509.ParseCertificate(c.Certificates[0])
+	cl, err := r.getGenericClient()
 	if err != nil {
-		log.Debugf("%v cannot satisfy %v because we cannot parse it: %v", c, t, err)
-		return false
-	}
-
-	names := map[string]struct{}{}
-	for _, name := range cc.DNSNames {
-		names[name] = struct{}{}
+		return err
 	}
 
-	for _, name := range t.Satisfy.Names {
-		_, ok := names[name]
-		if !ok {
-			log.Debugf("%v cannot satisfy %v because required hostname %q is not listed on it: %#v", c, t, name, cc.DNSNames)
-			return false
-		}
+	order := &acmeapi.Order{}
+	cert := &acmeapi.Certificate{}
+	isCert, err := cl.LoadOrderOrCertificate(context.TODO(), c.URL, order, cert)
+	if err != nil {
+		return err
 	}
 
-	log.Debugf("%v satisfies %v", c, t)
-	return true
-}
-
-func FindBestCertificateSatisfying(s storage.Store, t *storage.Target) (*storage.Certificate, error) {
-	var bestCert *storage.Certificate
-
-	err := s.VisitCertificates(func(c *storage.Certificate) error {
-		if DoesCertificateSatisfy(c, t) {
-			isBetterThan, err := CertificateBetterThan(c, bestCert)
-			if err != nil {
+	if !isCert {
+		// It's an order URL, so we need to a) wait for the order to be complete,
+		// and b) download the certificate via the URL given.
+
+		// Wait for the order to be complete.
+		waitLimit := time.Now().Add(10 * time.Minute)
+		for !order.Status.IsFinal() {
+			// How long should it take for an order to finish after finalization is
+			// requested? Probably not long for the Let's Encrypt use case, but it's
+			// not hard to imagine weird implementations where there's a long waiting
+			// time (e.g. manual approval). We don't want to hang forever waiting, so
+			// let's bail after a while in the expectation we'll try again later when
+			// cron next invokes us.
+			if time.Now().After(waitLimit) {
+				err = fmt.Errorf("took more than 10 minutes to wait for an order (%q, status %q) to become final; giving up for now", order.URL, order.Status)
+				err = util.NewPertError(true, err)
 				return err
 			}
 
-			if isBetterThan {
-				log.Tracef("findBestCertificateSatisfying: %v > %v", c, bestCert)
-				bestCert = c
-			} else {
-				log.Tracef("findBestCertificateSatisfying: %v <= %v", c, bestCert)
+			err = cl.WaitLoadOrder(context.TODO(), order)
+			if err != nil {
+				return err
 			}
 		}
 
-		return nil
-	})
-	if err != nil {
-		return nil, err
-	}
-
-	if bestCert == nil {
-		return nil, fmt.Errorf("%v: no certificate satisfies this target", t)
-	}
-
-	return bestCert, nil
-}
-
-func CertificateBetterThan(a, b *storage.Certificate) (bool, error) {
-	if b == nil || a == nil {
-		return (b == nil && a != nil), nil
-	}
-
-	if len(a.Certificates) == 0 || len(b.Certificates) == 0 {
-		return false, fmt.Errorf("need two certificates to compare")
-	}
-
-	ac, err := x509.ParseCertificate(a.Certificates[0])
-	bc, err2 := x509.ParseCertificate(b.Certificates[0])
-	if err != nil || err2 != nil {
-		if err == nil && err2 != nil {
-			log.Tracef("certBetterThan: parseable certificate is better than unparseable certificate")
-			return true, nil
+		if order.Status != acmeapi.OrderValid {
+			// Order is final not not valid, which means the server has reneged on an
+			// order after finalisation. Not sure whether this can happen, but it
+			// wouldn't surprise me if such implementations show up. As per ACME-SSS,
+			// we should treat this as a 'permanent error' and delete the certificate.
+			return fmt.Errorf("order became invalid after finalisation: %q (%q)", order.URL, order.Status)
 		}
 
-		return false, nil
-	}
-
-	isAfter := ac.NotAfter.After(bc.NotAfter)
-	log.Tracef("certBetterThan: (%v > %v)=%v", ac.NotAfter, bc.NotAfter, isAfter)
-	return isAfter, nil
-}
-
-func CertificateNeedsRenewing(c *storage.Certificate) bool {
-	if len(c.Certificates) == 0 {
-		log.Debugf("%v: not renewing because it has no actual certificates (???)", c)
-		return false
-	}
+		// Download the certificate.
+		cert = &acmeapi.Certificate{
+			URL: order.CertificateURL,
+		}
 
-	cc, err := x509.ParseCertificate(c.Certificates[0])
-	if err != nil {
-		log.Debugf("%v: not renewing because its end certificate is unparseable", c)
-		return false
+		err = cl.LoadCertificate(context.TODO(), cert)
+		if err != nil {
+			return err
+		}
 	}
 
-	renewTime := renewTime(cc.NotBefore, cc.NotAfter)
-	needsRenewing := !InternalClock.Now().Before(renewTime)
-
-	log.Debugf("%v needsRenewing=%v notAfter=%v", c, needsRenewing, cc.NotAfter)
-	return needsRenewing
-}
-
-// This is used to detertmine whether to cull certificates.
-func CertificateGenerallyValid(c *storage.Certificate) bool {
-	// This function is very conservative because if we return false
-	// the certificate will get deleted. Revocation and expiry are
-	// good reasons to delete. We already know the certificate is
-	// unreferenced.
-
-	if c.Revoked {
-		log.Debugf("%v not generally valid because it is revoked", c)
-		return false
+	// At this point we have the certificate in 'cert', and cert.URL is set.
+	if len(cert.CertificateChain) == 0 {
+		return fmt.Errorf("nil certificate?")
 	}
 
-	if len(c.Certificates) == 0 {
-		// If we have no actual certificates, give the benefit of the doubt.
-		// Maybe the certificate is undownloaded.
-		log.Debugf("%v has no actual certificates, assuming valid", c)
-		return true
-	}
+	c.Certificates = cert.CertificateChain
+	c.Cached = true
 
-	cc, err := x509.ParseCertificate(c.Certificates[0])
+	err = r.store.SaveCertificate(c)
 	if err != nil {
-		log.Debugf("%v cannot be parsed, assuming valid", c)
-		return false
-	}
-
-	if !InternalClock.Now().Before(cc.NotAfter) {
-		log.Debugf("%v not generally valid because it is expired", c)
-		return false
+		log.Errore(err, "failed to save certificate after retrieval: %v", c)
+		return err
 	}
 
-	return true
+	return nil
 }
+
+// todo change solver.Order to not wait for finalisation
diff --git a/storageops/revoke.go b/storageops/revoke.go
index 8eabaec..a9e56bc 100644
--- a/storageops/revoke.go
+++ b/storageops/revoke.go
@@ -2,7 +2,8 @@ package storageops
 
 import (
 	"fmt"
-	"github.com/hlandau/acme/storage"
+	"git.devever.net/hlandau/acmetool/storage"
+	"git.devever.net/hlandau/acmetool/util"
 )
 
 func RevokeByCertificateOrKeyID(s storage.Store, id string) error {
@@ -26,7 +27,7 @@ func revokeByKeyID(s storage.Store, keyID string) error {
 		return fmt.Errorf("cannot find certificate or key with given ID: %q", keyID)
 	}
 
-	var merr storage.MultiError
+	var merr util.MultiError
 	s.VisitCertificates(func(c *storage.Certificate) error {
 		if c.Key != k {
 			return nil // continue
diff --git a/storageops/util.go b/storageops/util.go
index d7ec06e..6fa9021 100644
--- a/storageops/util.go
+++ b/storageops/util.go
@@ -7,7 +7,7 @@ import (
 	"crypto/rsa"
 	"crypto/x509"
 	"fmt"
-	"github.com/hlandau/acme/storage"
+	"git.devever.net/hlandau/acmetool/storage"
 	"time"
 )
 
@@ -45,9 +45,16 @@ func targetGt(a *storage.Target, b *storage.Target) bool {
 
 // This is 30 days, which is a bit high, but Let's Encrypt sends expiration
 // emails at 19 days, so...
-const renewalMargin = 30 * 24 * time.Hour // close enough to 30 days
+const defaultRenewalMarginDays = 30
+
+func renewTime(notBefore, notAfter time.Time, t *storage.Target) time.Time {
+	renewalMarginDays := defaultRenewalMarginDays
+	if t.Satisfy.Margin > 0 {
+		renewalMarginDays = t.Satisfy.Margin
+	}
+
+	renewalMargin := time.Duration(renewalMarginDays) * 24 * time.Hour
 
-func renewTime(notBefore, notAfter time.Time) time.Time {
 	validityPeriod := notAfter.Sub(notBefore)
 	renewSpan := validityPeriod / 3
 	if renewSpan > renewalMargin {
diff --git a/util/multierror.go b/util/multierror.go
new file mode 100644
index 0000000..619a922
--- /dev/null
+++ b/util/multierror.go
@@ -0,0 +1,69 @@
+package util
+
+import "fmt"
+
+// Used to return multiple errors, for example when several targets cannot be
+// reconciled. This prevents one failing target from blocking others.
+type MultiError []error
+
+func (merr MultiError) Error() string {
+	s := ""
+	for _, e := range merr {
+		if s != "" {
+			s += "; \n"
+		}
+		s += e.Error()
+	}
+	return "the following errors occurred:\n" + s
+}
+
+// Used to return an error that wraps another error.
+type WrapError struct {
+	Msg string
+	Sub error
+}
+
+// Create a new error that wraps another error.
+func NewWrapError(sub error, msg string, args ...interface{}) *WrapError {
+	return &WrapError{
+		Msg: fmt.Sprintf(msg, args...),
+		Sub: sub,
+	}
+}
+
+func (werr *WrapError) Error() string {
+	return fmt.Sprintf("%s [due to inner error: %v]", werr.Msg, werr.Sub)
+}
+
+// PertError knows whether it's temporary or not.
+type PertError struct {
+	error
+	temporary bool
+}
+
+// Create an error that knows whether it's temporary or not.
+func NewPertError(isTemporary bool, sub error) error {
+	return &PertError{sub, isTemporary}
+}
+
+// Returns true iff the error is temporary. Compatible with the Temporary
+// method of the "net" package's OpError type.
+func (e *PertError) Temporary() bool {
+	return e.temporary
+}
+
+type tmp interface {
+	Temporary() bool
+}
+
+// Returns whether an error is temporary or not. An error is temporary if it
+// implements the interface { Temporary() bool } and that method returns true.
+// Errors which don't implement this interface aren't temporary.
+func IsTemporary(err error) bool {
+	x, ok := err.(tmp)
+	if !ok {
+		return false
+	}
+
+	return x.Temporary()
+}
